        -:    0:Source:/home/edd993/CLionProjects/hdr_generator/include/externals/tinyexr/tinyexr.h
        -:    0:Graph:/home/edd993/CLionProjects/hdr_generator/cmake-build-debug/CMakeFiles/hdr_generator.dir/main.cpp.gcno
        -:    0:Data:/home/edd993/CLionProjects/hdr_generator/cmake-build-debug/CMakeFiles/hdr_generator.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:Copyright (c) 2014 - 2015, Syoyo Fujita
        -:    3:All rights reserved.
        -:    4:
        -:    5:Redistribution and use in source and binary forms, with or without
        -:    6:modification, are permitted provided that the following conditions are met:
        -:    7:    * Redistributions of source code must retain the above copyright
        -:    8:      notice, this list of conditions and the following disclaimer.
        -:    9:    * Redistributions in binary form must reproduce the above copyright
        -:   10:      notice, this list of conditions and the following disclaimer in the
        -:   11:      documentation and/or other materials provided with the distribution.
        -:   12:    * Neither the name of the <organization> nor the
        -:   13:      names of its contributors may be used to endorse or promote products
        -:   14:      derived from this software without specific prior written permission.
        -:   15:
        -:   16:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   17:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   18:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   19:DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
        -:   20:DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   21:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   22:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
        -:   23:ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   24:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   25:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   26:*/
        -:   27:#ifndef __TINYEXR_H__
        -:   28:#define __TINYEXR_H__
        -:   29:
        -:   30://
        -:   31:// 
        -:   32://   Do this:
        -:   33://    #define TINYEXR_IMPLEMENTATION
        -:   34://   before you include this file in *one* C or C++ file to create the implementation.
        -:   35://
        -:   36://   // i.e. it should look like this:
        -:   37://   #include ...
        -:   38://   #include ...
        -:   39://   #include ...
        -:   40://   #define TINYEXR_IMPLEMENTATION
        -:   41://   #include "tinyexr.h"
        -:   42://
        -:   43://
        -:   44:
        -:   45:#include <stddef.h> // for size_t
        -:   46:
        -:   47:#ifdef __cplusplus
        -:   48:extern "C" {
        -:   49:#endif
        -:   50:
        -:   51:// pixel type: possible values are: UINT = 0 HALF = 1 FLOAT = 2
        -:   52:#define TINYEXR_PIXELTYPE_UINT (0)
        -:   53:#define TINYEXR_PIXELTYPE_HALF (1)
        -:   54:#define TINYEXR_PIXELTYPE_FLOAT (2)
        -:   55:
        -:   56:#define TINYEXR_MAX_ATTRIBUTES  (128)
        -:   57:
        -:   58:typedef struct _EXRAttribute {
        -:   59:  char *name; 
        -:   60:  char *type;
        -:   61:  int   size;
        -:   62:  unsigned char *value; // uint8_t*
        -:   63:} EXRAttribute;
        -:   64:
        -:   65:typedef struct _EXRImage {
        -:   66:  // Custom attributes(exludes required attributes(e.g. `channels`, `compression`, etc)
        -:   67:  EXRAttribute custom_attributes[TINYEXR_MAX_ATTRIBUTES];
        -:   68:  int num_custom_attributes;
        -:   69:
        -:   70:  int num_channels;
        -:   71:  const char **channel_names;
        -:   72:
        -:   73:  unsigned char **images; // image[channels][pixels]
        -:   74:  int *pixel_types; // Loaded pixel type(TINYEXR_PIXELTYPE_*) of `images` for
        -:   75:                    // each channel
        -:   76:
        -:   77:  int *requested_pixel_types; // Filled initially by
        -:   78:                              // ParseEXRHeaderFrom(Meomory|File), then users
        -:   79:                              // can edit it(only valid for HALF pixel type
        -:   80:                              // channel)
        -:   81:
        -:   82:  int width;
        -:   83:  int height;
        -:   84:  float pixel_aspect_ratio;
        -:   85:  int line_order;
        -:   86:  int data_window[4];
        -:   87:  int display_window[4];
        -:   88:  float screen_window_center[2];
        -:   89:  float screen_window_width;
        -:   90:} EXRImage;
        -:   91:
        -:   92:typedef struct _DeepImage {
        -:   93:  int num_channels;
        -:   94:  const char **channel_names;
        -:   95:  float ***image;     // image[channels][scanlines][samples]
        -:   96:  int **offset_table; // offset_table[scanline][offsets]
        -:   97:  int width;
        -:   98:  int height;
        -:   99:} DeepImage;
        -:  100:
        -:  101:// @deprecated { to be removed. }
        -:  102:// Loads single-frame OpenEXR image. Assume EXR image contains RGB(A) channels.
        -:  103:// Application must free image data as returned by `out_rgba`
        -:  104:// Result image format is: float x RGBA x width x hight
        -:  105:// Return 0 if success
        -:  106:// Returns error string in `err` when there's an error
        -:  107:inline int LoadEXR(float **out_rgba, int *width, int *height,
        -:  108:                   const char *filename, const char **err);
        -:  109:
        -:  110:// Parse single-frame OpenEXR header from a file and initialize `EXRImage`
        -:  111:// struct.
        -:  112:// Users then call LoadMultiChannelEXRFromFile to actually load image data into
        -:  113:// `EXRImage`
        -:  114:inline int ParseMultiChannelEXRHeaderFromFile(EXRImage *image,
        -:  115:                                              const char *filename,
        -:  116:                                              const char **err);
        -:  117:
        -:  118:// Parse single-frame OpenEXR header from a memory and initialize `EXRImage`
        -:  119:// struct.
        -:  120:// Users then call LoadMultiChannelEXRFromMemory to actually load image data
        -:  121:// into `EXRImage`
        -:  122:inline int ParseMultiChannelEXRHeaderFromMemory(EXRImage *image,
        -:  123:                                                const unsigned char *memory,
        -:  124:                                                const char **err);
        -:  125:
        -:  126:// Loads multi-channel, single-frame OpenEXR image from a file.
        -:  127:// Application must setup `ParseMultiChannelEXRHeaderFromFile` before calling
        -:  128:// `LoadMultiChannelEXRFromFile`.
        -:  129:// Application can free EXRImage using `FreeExrImage`
        -:  130:// Return 0 if success
        -:  131:// Returns error string in `err` when there's an error
        -:  132:inline int LoadMultiChannelEXRFromFile(EXRImage *image, const char *filename,
        -:  133:                                       const char **err);
        -:  134:
        -:  135:// Loads multi-channel, single-frame OpenEXR image from a memory.
        -:  136:// Application must setup `EXRImage` with `ParseMultiChannelEXRHeaderFromMemory`
        -:  137:// before calling `LoadMultiChannelEXRFromMemory`.
        -:  138:// Application can free EXRImage using `FreeExrImage`
        -:  139:// Return 0 if success
        -:  140:// Returns error string in `err` when there's an error
        -:  141:inline int LoadMultiChannelEXRFromMemory(EXRImage *image,
        -:  142:                                         const unsigned char *memory,
        -:  143:                                         const char **err);
        -:  144:
        -:  145:// Saves floating point RGBA image as OpenEXR.
        -:  146:// Image is compressed with ZIP.
        -:  147:// Return 0 if success
        -:  148:// Returns error string in `err` when there's an error
        -:  149:// extern int SaveEXR(const float *in_rgba, int width, int height,
        -:  150://                   const char *filename, const char **err);
        -:  151:
        -:  152:// Saves multi-channel, single-frame OpenEXR image to a file.
        -:  153:// Application must free EXRImage
        -:  154:// Returns 0 if success
        -:  155:// Returns error string in `err` when there's an error
        -:  156:inline int SaveMultiChannelEXRToFile(const EXRImage *image,
        -:  157:                                     const char *filename, const char **err);
        -:  158:
        -:  159:// Saves multi-channel, single-frame OpenEXR image to a memory.
        -:  160:// Application must free EXRImage
        -:  161:// Return the number of bytes if succes.
        -:  162:// Retruns 0 if success, negative number when failed.
        -:  163:// Returns error string in `err` when there's an error
        -:  164:inline size_t SaveMultiChannelEXRToMemory(const EXRImage *image,
        -:  165:                                          unsigned char **memory,
        -:  166:                                          const char **err);
        -:  167:
        -:  168:// Loads single-frame OpenEXR deep image.
        -:  169:// Application must free memory of variables in DeepImage(image, offset_table)
        -:  170:// Returns 0 if success
        -:  171:// Returns error string in `err` when there's an error
        -:  172:inline int LoadDeepEXR(DeepImage *out_image, const char *filename,
        -:  173:                       const char **err);
        -:  174:
        -:  175:// NOT YET IMPLEMENTED:
        -:  176:// Saves single-frame OpenEXR deep image.
        -:  177:// Return 0 if success
        -:  178:// Returns error string in `err` when there's an error
        -:  179:// extern int SaveDeepEXR(const DeepImage *in_image, const char *filename,
        -:  180://                       const char **err);
        -:  181:
        -:  182:// NOT YET IMPLEMENTED:
        -:  183:// Loads multi-part OpenEXR deep image.
        -:  184:// Application must free memory of variables in DeepImage(image, offset_table)
        -:  185:// extern int LoadMultiPartDeepEXR(DeepImage **out_image, int num_parts, const
        -:  186:// char *filename,
        -:  187://                       const char **err);
        -:  188:
        -:  189:// Initialize of EXRImage struct
        -:  190:inline void InitEXRImage(EXRImage *exrImage);
        -:  191:
        -:  192:// Free's internal data of EXRImage struct
        -:  193:// Returns 0 if success.
        -:  194:inline int FreeEXRImage(EXRImage *exrImage);
        -:  195:
        -:  196:// For emscripten.
        -:  197:// Parse single-frame OpenEXR header from memory.
        -:  198:// Return 0 if success
        -:  199:inline int ParseEXRHeaderFromMemory(EXRAttribute* customAttributes, int *numCustomAttributes, int *width, int *height,
        -:  200:                                    const unsigned char *memory);
        -:  201:
        -:  202:// For emscripten.
        -:  203:// Loads single-frame OpenEXR image from memory. Assume EXR image contains
        -:  204:// RGB(A) channels.
        -:  205:// `out_rgba` must have enough memory(at least sizeof(float) x 4(RGBA) x width x
        -:  206:// hight)
        -:  207:// Return 0 if success
        -:  208:// Returns error string in `err` when there's an error
        -:  209:inline int LoadEXRFromMemory(float *out_rgba, const unsigned char *memory,
        -:  210:                             const char **err);
        -:  211:
        -:  212:#ifdef __cplusplus
        -:  213:}
        -:  214:#endif
        -:  215:
        -:  216:#ifdef TINYEXR_IMPLEMENTATION
        -:  217:#include <cstdio>
        -:  218:#include <cstdlib>
        -:  219:#include <cassert>
        -:  220:#include <cstring>
        -:  221:#include <algorithm>
        -:  222:
        -:  223:#include <string>
        -:  224:#include <vector>
        -:  225:
        -:  226:#include "tinyexr.h"
        -:  227:
        -:  228:#ifdef _OPENMP
        -:  229:#include <omp.h>
        -:  230:#endif
        -:  231:
        -:  232:namespace {
        -:  233://#define MINIZ_NO_ARCHIVE_APIS
        -:  234://#define MINIZ_NO_STDIO
        -:  235:namespace miniz {
        -:  236:
        -:  237:/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP
        -:  238:   reading/writing/appending, PNG writing
        -:  239:   See "unlicense" statement at the end of this file.
        -:  240:   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
        -:  241:   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951:
        -:  242:   http://www.ietf.org/rfc/rfc1951.txt
        -:  243:
        -:  244:   Most API's defined in miniz.c are optional. For example, to disable the
        -:  245:   archive related functions just define
        -:  246:   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO
        -:  247:   (see the list below for more macros).
        -:  248:
        -:  249:   * Change History
        -:  250:     10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major
        -:  251:   release with Zip64 support (almost there!):
        -:  252:       - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug
        -:  253:   (thanks kahmyong.moon@hp.com) which could cause locate files to not find
        -:  254:   files. This bug
        -:  255:        would only have occured in earlier versions if you explicitly used this
        -:  256:   flag, OR if you used mz_zip_extract_archive_file_to_heap() or
        -:  257:   mz_zip_add_mem_to_archive_file_in_place()
        -:  258:        (which used this flag). If you can't switch to v1.15 but want to fix
        -:  259:   this bug, just remove the uses of this flag from both helper funcs (and of
        -:  260:   course don't use the flag).
        -:  261:       - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when
        -:  262:   pUser_read_buf is not NULL and compressed size is > uncompressed size
        -:  263:       - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract
        -:  264:   compressed data from directory entries, to account for weird zipfiles which
        -:  265:   contain zero-size compressed data on dir entries.
        -:  266:         Hopefully this fix won't cause any issues on weird zip archives,
        -:  267:   because it assumes the low 16-bits of zip external attributes are DOS
        -:  268:   attributes (which I believe they always are in practice).
        -:  269:       - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the
        -:  270:   internal attributes, just the filename and external attributes
        -:  271:       - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed
        -:  272:       - Added cmake support for Linux builds which builds all the examples,
        -:  273:   tested with clang v3.3 and gcc v4.6.
        -:  274:       - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti
        -:  275:       - Merged MZ_FORCEINLINE fix from hdeanclark
        -:  276:       - Fix <time.h> include before config #ifdef, thanks emil.brink
        -:  277:       - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping
        -:  278:   (super useful for OpenGL apps), and explicit control over the compression
        -:  279:   level (so you can
        -:  280:        set it to 1 for real-time compression).
        -:  281:       - Merged in some compiler fixes from paulharris's github repro.
        -:  282:       - Retested this build under Windows (VS 2010, including static analysis),
        -:  283:   tcc  0.9.26, gcc v4.6 and clang v3.3.
        -:  284:       - Added example6.c, which dumps an image of the mandelbrot set to a PNG
        -:  285:   file.
        -:  286:       - Modified example2 to help test the
        -:  287:   MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.
        -:  288:       - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix
        -:  289:   possible src file fclose() leak if alignment bytes+local header file write
        -:  290:   faiiled
        -:  291:                 - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader():
        -:  292:   Was pushing the wrong central dir header offset, appears harmless in this
        -:  293:   release, but it became a problem in the zip64 branch
        -:  294:     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE,
        -:  295:   #include <time.h> (thanks fermtect).
        -:  296:     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix
        -:  297:   mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.
        -:  298:       - Temporarily/locally slammed in "typedef unsigned long mz_ulong" and
        -:  299:   re-ran a randomized regression test on ~500k files.
        -:  300:       - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.
        -:  301:       - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze
        -:  302:   (static analysis) option and fixed all warnings (except for the silly
        -:  303:        "Use of the comma-operator in a tested expression.." analysis warning,
        -:  304:   which I purposely use to work around a MSVC compiler warning).
        -:  305:       - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and
        -:  306:   tested Linux executables. The codeblocks workspace is compatible with
        -:  307:   Linux+Win32/x64.
        -:  308:       - Added miniz_tester solution/project, which is a useful little app
        -:  309:   derived from LZHAM's tester app that I use as part of the regression test.
        -:  310:       - Ran miniz.c and tinfl.c through another series of regression testing on
        -:  311:   ~500,000 files and archives.
        -:  312:       - Modified example5.c so it purposely disables a bunch of high-level
        -:  313:   functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the
        -:  314:   MINIZ_NO_STDIO bug report.)
        -:  315:       - Fix ftell() usage in examples so they exit with an error on files which
        -:  316:   are too large (a limitation of the examples, not miniz itself).
        -:  317:     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple
        -:  318:   minor level_and_flags issues in the archive API's.
        -:  319:      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce
        -:  320:   Dawson <bruced@valvesoftware.com> for the feedback/bug report.
        -:  321:     5/28/11 v1.11 - Added statement from unlicense.org
        -:  322:     5/27/11 v1.10 - Substantial compressor optimizations:
        -:  323:      - Level 1 is now ~4x faster than before. The L1 compressor's throughput
        -:  324:   now varies between 70-110MB/sec. on a
        -:  325:      - Core i7 (actual throughput varies depending on the type of data, and x64
        -:  326:   vs. x86).
        -:  327:      - Improved baseline L2-L9 compression perf. Also, greatly improved
        -:  328:   compression perf. issues on some file types.
        -:  329:      - Refactored the compression code for better readability and
        -:  330:   maintainability.
        -:  331:      - Added level 10 compression level (L10 has slightly better ratio than
        -:  332:   level 9, but could have a potentially large
        -:  333:       drop in throughput on some files).
        -:  334:     5/15/11 v1.09 - Initial stable release.
        -:  335:
        -:  336:   * Low-level Deflate/Inflate implementation notes:
        -:  337:
        -:  338:     Compression: Use the "tdefl" API's. The compressor supports raw, static,
        -:  339:   and dynamic blocks, lazy or
        -:  340:     greedy parsing, match length filtering, RLE-only, and Huffman-only streams.
        -:  341:   It performs and compresses
        -:  342:     approximately as well as zlib.
        -:  343:
        -:  344:     Decompression: Use the "tinfl" API's. The entire decompressor is
        -:  345:   implemented as a single function
        -:  346:     coroutine: see tinfl_decompress(). It supports decompression into a 32KB
        -:  347:   (or larger power of 2) wrapping buffer, or into a memory
        -:  348:     block large enough to hold the entire file.
        -:  349:
        -:  350:     The low-level tdefl/tinfl API's do not make any use of dynamic memory
        -:  351:   allocation.
        -:  352:
        -:  353:   * zlib-style API notes:
        -:  354:
        -:  355:     miniz.c implements a fairly large subset of zlib. There's enough
        -:  356:   functionality present for it to be a drop-in
        -:  357:     zlib replacement in many apps:
        -:  358:        The z_stream struct, optional memory allocation callbacks
        -:  359:        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        -:  360:        inflateInit/inflateInit2/inflate/inflateEnd
        -:  361:        compress, compress2, compressBound, uncompress
        -:  362:        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly
        -:  363:   routines.
        -:  364:        Supports raw deflate streams or standard zlib streams with adler-32
        -:  365:   checking.
        -:  366:
        -:  367:     Limitations:
        -:  368:      The callback API's are not implemented yet. No support for gzip headers or
        -:  369:   zlib static dictionaries.
        -:  370:      I've tried to closely emulate zlib's various flavors of stream flushing
        -:  371:   and return status codes, but
        -:  372:      there are no guarantees that miniz.c pulls this off perfectly.
        -:  373:
        -:  374:   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function,
        -:  375:   originally written by
        -:  376:     Alex Evans. Supports 1-4 bytes/pixel images.
        -:  377:
        -:  378:   * ZIP archive API notes:
        -:  379:
        -:  380:     The ZIP archive API's where designed with simplicity and efficiency in
        -:  381:   mind, with just enough abstraction to
        -:  382:     get the job done with minimal fuss. There are simple API's to retrieve file
        -:  383:   information, read files from
        -:  384:     existing archives, create new archives, append new files to existing
        -:  385:   archives, or clone archive data from
        -:  386:     one archive to another. It supports archives located in memory or the heap,
        -:  387:   on disk (using stdio.h),
        -:  388:     or you can specify custom file read/write callbacks.
        -:  389:
        -:  390:     - Archive reading: Just call this function to read a single file from a
        -:  391:   disk archive:
        -:  392:
        -:  393:      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const
        -:  394:   char *pArchive_name,
        -:  395:        size_t *pSize, mz_uint zip_flags);
        -:  396:
        -:  397:     For more complex cases, use the "mz_zip_reader" functions. Upon opening an
        -:  398:   archive, the entire central
        -:  399:     directory is located and read as-is into memory, and subsequent file access
        -:  400:   only occurs when reading individual files.
        -:  401:
        -:  402:     - Archives file scanning: The simple way is to use this function to scan a
        -:  403:   loaded archive for a specific file:
        -:  404:
        -:  405:     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,
        -:  406:   const char *pComment, mz_uint flags);
        -:  407:
        -:  408:     The locate operation can optionally check file comments too, which (as one
        -:  409:   example) can be used to identify
        -:  410:     multiple versions of the same file in an archive. This function uses a
        -:  411:   simple linear search through the central
        -:  412:     directory, so it's not very fast.
        -:  413:
        -:  414:     Alternately, you can iterate through all the files in an archive (using
        -:  415:   mz_zip_reader_get_num_files()) and
        -:  416:     retrieve detailed info on each file by calling mz_zip_reader_file_stat().
        -:  417:
        -:  418:     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer
        -:  419:   immediately writes compressed file data
        -:  420:     to disk and builds an exact image of the central directory in memory. The
        -:  421:   central directory image is written
        -:  422:     all at once at the end of the archive file when the archive is finalized.
        -:  423:
        -:  424:     The archive writer can optionally align each file's local header and file
        -:  425:   data to any power of 2 alignment,
        -:  426:     which can be useful when the archive will be read from optical media. Also,
        -:  427:   the writer supports placing
        -:  428:     arbitrary data blobs at the very beginning of ZIP archives. Archives
        -:  429:   written using either feature are still
        -:  430:     readable by any ZIP tool.
        -:  431:
        -:  432:     - Archive appending: The simple way to add a single file to an archive is
        -:  433:   to call this function:
        -:  434:
        -:  435:      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename,
        -:  436:   const char *pArchive_name,
        -:  437:        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16
        -:  438:   comment_size, mz_uint level_and_flags);
        -:  439:
        -:  440:     The archive will be created if it doesn't already exist, otherwise it'll be
        -:  441:   appended to.
        -:  442:     Note the appending is done in-place and is not an atomic operation, so if
        -:  443:   something goes wrong
        -:  444:     during the operation it's possible the archive could be left without a
        -:  445:   central directory (although the local
        -:  446:     file headers and file data will be fine, so the archive will be
        -:  447:   recoverable).
        -:  448:
        -:  449:     For more complex archive modification scenarios:
        -:  450:     1. The safest way is to use a mz_zip_reader to read the existing archive,
        -:  451:   cloning only those bits you want to
        -:  452:     preserve into a new archive using using the
        -:  453:   mz_zip_writer_add_from_zip_reader() function (which compiles the
        -:  454:     compressed file data as-is). When you're done, delete the old archive and
        -:  455:   rename the newly written archive, and
        -:  456:     you're done. This is safe but requires a bunch of temporary disk space or
        -:  457:   heap memory.
        -:  458:
        -:  459:     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using
        -:  460:   mz_zip_writer_init_from_reader(),
        -:  461:     append new files as needed, then finalize the archive which will write an
        -:  462:   updated central directory to the
        -:  463:     original archive. (This is basically what
        -:  464:   mz_zip_add_mem_to_archive_file_in_place() does.) There's a
        -:  465:     possibility that the archive's central directory could be lost with this
        -:  466:   method if anything goes wrong, though.
        -:  467:
        -:  468:     - ZIP archive support limitations:
        -:  469:     No zip64 or spanning support. Extraction functions can only handle
        -:  470:   unencrypted, stored or deflated files.
        -:  471:     Requires streams capable of seeking.
        -:  472:
        -:  473:   * This is a header file library, like stb_image.c. To get only a header file,
        -:  474:   either cut and paste the
        -:  475:     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then
        -:  476:   include miniz.c from it.
        -:  477:
        -:  478:   * Important: For best perf. be sure to customize the below macros for your
        -:  479:   target platform:
        -:  480:     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
        -:  481:     #define MINIZ_LITTLE_ENDIAN 1
        -:  482:     #define MINIZ_HAS_64BIT_REGISTERS 1
        -:  483:
        -:  484:   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before
        -:  485:   including miniz.c to ensure miniz
        -:  486:     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be
        -:  487:   able to process large files
        -:  488:     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
        -:  489:*/
        -:  490:
        -:  491:#ifndef MINIZ_HEADER_INCLUDED
        -:  492:#define MINIZ_HEADER_INCLUDED
        -:  493:
        -:  494:#include <stdlib.h>
        -:  495:
        -:  496:// Defines to completely disable specific portions of miniz.c:
        -:  497:// If all macros here are defined the only functionality remaining will be
        -:  498:// CRC-32, adler-32, tinfl, and tdefl.
        -:  499:
        -:  500:// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on
        -:  501:// stdio for file I/O.
        -:  502://#define MINIZ_NO_STDIO
        -:  503:
        -:  504:// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able
        -:  505:// to get the current time, or
        -:  506:// get/set file times, and the C run-time funcs that get/set times won't be
        -:  507:// called.
        -:  508:// The current downside is the times written to your archives will be from 1979.
        -:  509://#define MINIZ_NO_TIME
        -:  510:
        -:  511:// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.
        -:  512://#define MINIZ_NO_ARCHIVE_APIS
        -:  513:
        -:  514:// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive
        -:  515:// API's.
        -:  516://#define MINIZ_NO_ARCHIVE_WRITING_APIS
        -:  517:
        -:  518:// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression
        -:  519:// API's.
        -:  520://#define MINIZ_NO_ZLIB_APIS
        -:  521:
        -:  522:// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent
        -:  523:// conflicts against stock zlib.
        -:  524://#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES
        -:  525:
        -:  526:// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
        -:  527:// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom
        -:  528:// user alloc/free/realloc
        -:  529:// callbacks to the zlib and archive API's, and a few stand-alone helper API's
        -:  530:// which don't provide custom user
        -:  531:// functions (such as tdefl_compress_mem_to_heap() and
        -:  532:// tinfl_decompress_mem_to_heap()) won't work.
        -:  533://#define MINIZ_NO_MALLOC
        -:  534:
        -:  535:#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
        -:  536:// TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc
        -:  537:// on Linux
        -:  538:#define MINIZ_NO_TIME
        -:  539:#endif
        -:  540:
        -:  541:#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
        -:  542:#include <time.h>
        -:  543:#endif
        -:  544:
        -:  545:#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) ||                \
        -:  546:    defined(__i386) || defined(__i486__) || defined(__i486) ||                 \
        -:  547:    defined(i386) || defined(__ia64__) || defined(__x86_64__)
        -:  548:// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.
        -:  549:#define MINIZ_X86_OR_X64_CPU 1
        -:  550:#endif
        -:  551:
        -:  552:#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
        -:  553:// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.
        -:  554:#define MINIZ_LITTLE_ENDIAN 1
        -:  555:#endif
        -:  556:
        -:  557:#if MINIZ_X86_OR_X64_CPU
        -:  558:// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient
        -:  559:// integer loads and stores from unaligned addresses.
        -:  560://#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
        -:  561:#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0 // disable to suppress compiler warnings
        -:  562:#endif
        -:  563:
        -:  564:#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) ||              \
        -:  565:    defined(_LP64) || defined(__LP64__) || defined(__ia64__) ||                \
        -:  566:    defined(__x86_64__)
        -:  567:// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are
        -:  568:// reasonably fast (and don't involve compiler generated calls to helper
        -:  569:// functions).
        -:  570:#define MINIZ_HAS_64BIT_REGISTERS 1
        -:  571:#endif
        -:  572:
        -:  573:#ifdef __cplusplus
        -:  574:extern "C" {
        -:  575:#endif
        -:  576:
        -:  577:// ------------------- zlib-style API Definitions.
        -:  578:
        -:  579:// For more compatibility with zlib, miniz.c uses unsigned long for some
        -:  580:// parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!
        -:  581:typedef unsigned long mz_ulong;
        -:  582:
        -:  583:// mz_free() internally uses the MZ_FREE() macro (which by default calls free()
        -:  584:// unless you've modified the MZ_MALLOC macro) to release a block allocated from
        -:  585:// the heap.
        -:  586:inline void mz_free(void *p);
        -:  587:
        -:  588:#define MZ_ADLER32_INIT (1)
        -:  589:// mz_adler32() returns the initial adler-32 value to use when called with
        -:  590:// ptr==NULL.
        -:  591:inline mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);
        -:  592:
        -:  593:#define MZ_CRC32_INIT (0)
        -:  594:// mz_crc32() returns the initial CRC-32 value to use when called with
        -:  595:// ptr==NULL.
        -:  596:inline mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);
        -:  597:
        -:  598:// Compression strategies.
        -:  599:enum {
        -:  600:  MZ_DEFAULT_STRATEGY = 0,
        -:  601:  MZ_FILTERED = 1,
        -:  602:  MZ_HUFFMAN_ONLY = 2,
        -:  603:  MZ_RLE = 3,
        -:  604:  MZ_FIXED = 4
        -:  605:};
        -:  606:
        -:  607:// Method
        -:  608:#define MZ_DEFLATED 8
        -:  609:
        -:  610:#ifndef MINIZ_NO_ZLIB_APIS
        -:  611:
        -:  612:// Heap allocation callbacks.
        -:  613:// Note that mz_alloc_func parameter types purpsosely differ from zlib's:
        -:  614:// items/size is size_t, not unsigned long.
        -:  615:typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
        -:  616:typedef void (*mz_free_func)(void *opaque, void *address);
        -:  617:typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items,
        -:  618:                                 size_t size);
        -:  619:
        -:  620:#define MZ_VERSION "9.1.15"
        -:  621:#define MZ_VERNUM 0x91F0
        -:  622:#define MZ_VER_MAJOR 9
        -:  623:#define MZ_VER_MINOR 1
        -:  624:#define MZ_VER_REVISION 15
        -:  625:#define MZ_VER_SUBREVISION 0
        -:  626:
        -:  627:// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The
        -:  628:// other values are for advanced use (refer to the zlib docs).
        -:  629:enum {
        -:  630:  MZ_NO_FLUSH = 0,
        -:  631:  MZ_PARTIAL_FLUSH = 1,
        -:  632:  MZ_SYNC_FLUSH = 2,
        -:  633:  MZ_FULL_FLUSH = 3,
        -:  634:  MZ_FINISH = 4,
        -:  635:  MZ_BLOCK = 5
        -:  636:};
        -:  637:
        -:  638:// Return status codes. MZ_PARAM_ERROR is non-standard.
        -:  639:enum {
        -:  640:  MZ_OK = 0,
        -:  641:  MZ_STREAM_END = 1,
        -:  642:  MZ_NEED_DICT = 2,
        -:  643:  MZ_ERRNO = -1,
        -:  644:  MZ_STREAM_ERROR = -2,
        -:  645:  MZ_DATA_ERROR = -3,
        -:  646:  MZ_MEM_ERROR = -4,
        -:  647:  MZ_BUF_ERROR = -5,
        -:  648:  MZ_VERSION_ERROR = -6,
        -:  649:  MZ_PARAM_ERROR = -10000
        -:  650:};
        -:  651:
        -:  652:// Compression levels: 0-9 are the standard zlib-style levels, 10 is best
        -:  653:// possible compression (not zlib compatible, and may be very slow),
        -:  654:// MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
        -:  655:enum {
        -:  656:  MZ_NO_COMPRESSION = 0,
        -:  657:  MZ_BEST_SPEED = 1,
        -:  658:  MZ_BEST_COMPRESSION = 9,
        -:  659:  MZ_UBER_COMPRESSION = 10,
        -:  660:  MZ_DEFAULT_LEVEL = 6,
        -:  661:  MZ_DEFAULT_COMPRESSION = -1
        -:  662:};
        -:  663:
        -:  664:// Window bits
        -:  665:#define MZ_DEFAULT_WINDOW_BITS 15
        -:  666:
        -:  667:struct mz_internal_state;
        -:  668:
        -:  669:// Compression/decompression stream struct.
        -:  670:typedef struct mz_stream_s {
        -:  671:  const unsigned char *next_in; // pointer to next byte to read
        -:  672:  unsigned int avail_in;        // number of bytes available at next_in
        -:  673:  mz_ulong total_in;            // total number of bytes consumed so far
        -:  674:
        -:  675:  unsigned char *next_out; // pointer to next byte to write
        -:  676:  unsigned int avail_out;  // number of bytes that can be written to next_out
        -:  677:  mz_ulong total_out;      // total number of bytes produced so far
        -:  678:
        -:  679:  char *msg;                       // error msg (unused)
        -:  680:  struct mz_internal_state *state; // internal state, allocated by zalloc/zfree
        -:  681:
        -:  682:  mz_alloc_func
        -:  683:      zalloc;         // optional heap allocation function (defaults to malloc)
        -:  684:  mz_free_func zfree; // optional heap free function (defaults to free)
        -:  685:  void *opaque;       // heap alloc function user pointer
        -:  686:
        -:  687:  int data_type;     // data_type (unused)
        -:  688:  mz_ulong adler;    // adler32 of the source or uncompressed data
        -:  689:  mz_ulong reserved; // not used
        -:  690:} mz_stream;
        -:  691:
        -:  692:typedef mz_stream *mz_streamp;
        -:  693:
        -:  694:// Returns the version string of miniz.c.
        -:  695:const char *mz_version(void);
        -:  696:
        -:  697:// mz_deflateInit() initializes a compressor with default options:
        -:  698:// Parameters:
        -:  699://  pStream must point to an initialized mz_stream struct.
        -:  700://  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].
        -:  701://  level 1 enables a specially optimized compression function that's been
        -:  702://  optimized purely for performance, not ratio.
        -:  703://  (This special func. is currently only enabled when
        -:  704://  MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)
        -:  705:// Return values:
        -:  706://  MZ_OK on success.
        -:  707://  MZ_STREAM_ERROR if the stream is bogus.
        -:  708://  MZ_PARAM_ERROR if the input parameters are bogus.
        -:  709://  MZ_MEM_ERROR on out of memory.
        -:  710:int mz_deflateInit(mz_streamp pStream, int level);
        -:  711:
        -:  712:// mz_deflateInit2() is like mz_deflate(), except with more control:
        -:  713:// Additional parameters:
        -:  714://   method must be MZ_DEFLATED
        -:  715://   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with
        -:  716://   zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no
        -:  717://   header or footer)
        -:  718://   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)
        -:  719:int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,
        -:  720:                    int mem_level, int strategy);
        -:  721:
        -:  722:// Quickly resets a compressor without having to reallocate anything. Same as
        -:  723:// calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().
        -:  724:int mz_deflateReset(mz_streamp pStream);
        -:  725:
        -:  726:// mz_deflate() compresses the input to output, consuming as much of the input
        -:  727:// and producing as much output as possible.
        -:  728:// Parameters:
        -:  729://   pStream is the stream to read from and write to. You must initialize/update
        -:  730://   the next_in, avail_in, next_out, and avail_out members.
        -:  731://   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or
        -:  732://   MZ_FINISH.
        -:  733:// Return values:
        -:  734://   MZ_OK on success (when flushing, or if more input is needed but not
        -:  735://   available, and/or there's more output to be written but the output buffer
        -:  736://   is full).
        -:  737://   MZ_STREAM_END if all input has been consumed and all output bytes have been
        -:  738://   written. Don't call mz_deflate() on the stream anymore.
        -:  739://   MZ_STREAM_ERROR if the stream is bogus.
        -:  740://   MZ_PARAM_ERROR if one of the parameters is invalid.
        -:  741://   MZ_BUF_ERROR if no forward progress is possible because the input and/or
        -:  742://   output buffers are empty. (Fill up the input buffer or free up some output
        -:  743://   space and try again.)
        -:  744:int mz_deflate(mz_streamp pStream, int flush);
        -:  745:
        -:  746:// mz_deflateEnd() deinitializes a compressor:
        -:  747:// Return values:
        -:  748://  MZ_OK on success.
        -:  749://  MZ_STREAM_ERROR if the stream is bogus.
        -:  750:int mz_deflateEnd(mz_streamp pStream);
        -:  751:
        -:  752:// mz_deflateBound() returns a (very) conservative upper bound on the amount of
        -:  753:// data that could be generated by deflate(), assuming flush is set to only
        -:  754:// MZ_NO_FLUSH or MZ_FINISH.
        -:  755:mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);
        -:  756:
        -:  757:// Single-call compression functions mz_compress() and mz_compress2():
        -:  758:// Returns MZ_OK on success, or one of the error codes from mz_deflate() on
        -:  759:// failure.
        -:  760:int mz_compress(unsigned char *pDest, mz_ulong *pDest_len,
        -:  761:                const unsigned char *pSource, mz_ulong source_len);
        -:  762:int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,
        -:  763:                 const unsigned char *pSource, mz_ulong source_len, int level);
        -:  764:
        -:  765:// mz_compressBound() returns a (very) conservative upper bound on the amount of
        -:  766:// data that could be generated by calling mz_compress().
        -:  767:mz_ulong mz_compressBound(mz_ulong source_len);
        -:  768:
        -:  769:// Initializes a decompressor.
        -:  770:int mz_inflateInit(mz_streamp pStream);
        -:  771:
        -:  772:// mz_inflateInit2() is like mz_inflateInit() with an additional option that
        -:  773:// controls the window size and whether or not the stream has been wrapped with
        -:  774:// a zlib header/footer:
        -:  775:// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or
        -:  776:// -MZ_DEFAULT_WINDOW_BITS (raw deflate).
        -:  777:int mz_inflateInit2(mz_streamp pStream, int window_bits);
        -:  778:
        -:  779:// Decompresses the input stream to the output, consuming only as much of the
        -:  780:// input as needed, and writing as much to the output as possible.
        -:  781:// Parameters:
        -:  782://   pStream is the stream to read from and write to. You must initialize/update
        -:  783://   the next_in, avail_in, next_out, and avail_out members.
        -:  784://   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.
        -:  785://   On the first call, if flush is MZ_FINISH it's assumed the input and output
        -:  786://   buffers are both sized large enough to decompress the entire stream in a
        -:  787://   single call (this is slightly faster).
        -:  788://   MZ_FINISH implies that there are no more source bytes available beside
        -:  789://   what's already in the input buffer, and that the output buffer is large
        -:  790://   enough to hold the rest of the decompressed data.
        -:  791:// Return values:
        -:  792://   MZ_OK on success. Either more input is needed but not available, and/or
        -:  793://   there's more output to be written but the output buffer is full.
        -:  794://   MZ_STREAM_END if all needed input has been consumed and all output bytes
        -:  795://   have been written. For zlib streams, the adler-32 of the decompressed data
        -:  796://   has also been verified.
        -:  797://   MZ_STREAM_ERROR if the stream is bogus.
        -:  798://   MZ_DATA_ERROR if the deflate stream is invalid.
        -:  799://   MZ_PARAM_ERROR if one of the parameters is invalid.
        -:  800://   MZ_BUF_ERROR if no forward progress is possible because the input buffer is
        -:  801://   empty but the inflater needs more input to continue, or if the output
        -:  802://   buffer is not large enough. Call mz_inflate() again
        -:  803://   with more input data, or with more room in the output buffer (except when
        -:  804://   using single call decompression, described above).
        -:  805:int mz_inflate(mz_streamp pStream, int flush);
        -:  806:
        -:  807:// Deinitializes a decompressor.
        -:  808:int mz_inflateEnd(mz_streamp pStream);
        -:  809:
        -:  810:// Single-call decompression.
        -:  811:// Returns MZ_OK on success, or one of the error codes from mz_inflate() on
        -:  812:// failure.
        -:  813:int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,
        -:  814:                  const unsigned char *pSource, mz_ulong source_len);
        -:  815:
        -:  816:// Returns a string description of the specified error code, or NULL if the
        -:  817:// error code is invalid.
        -:  818:const char *mz_error(int err);
        -:  819:
        -:  820:// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used
        -:  821:// as a drop-in replacement for the subset of zlib that miniz.c supports.
        -:  822:// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you
        -:  823:// use zlib in the same project.
        -:  824:#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
        -:  825:typedef unsigned char Byte;
        -:  826:typedef unsigned int uInt;
        -:  827:typedef mz_ulong uLong;
        -:  828:typedef Byte Bytef;
        -:  829:typedef uInt uIntf;
        -:  830:typedef char charf;
        -:  831:typedef int intf;
        -:  832:typedef void *voidpf;
        -:  833:typedef uLong uLongf;
        -:  834:typedef void *voidp;
        -:  835:typedef void *const voidpc;
        -:  836:#define Z_NULL 0
        -:  837:#define Z_NO_FLUSH MZ_NO_FLUSH
        -:  838:#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
        -:  839:#define Z_SYNC_FLUSH MZ_SYNC_FLUSH
        -:  840:#define Z_FULL_FLUSH MZ_FULL_FLUSH
        -:  841:#define Z_FINISH MZ_FINISH
        -:  842:#define Z_BLOCK MZ_BLOCK
        -:  843:#define Z_OK MZ_OK
        -:  844:#define Z_STREAM_END MZ_STREAM_END
        -:  845:#define Z_NEED_DICT MZ_NEED_DICT
        -:  846:#define Z_ERRNO MZ_ERRNO
        -:  847:#define Z_STREAM_ERROR MZ_STREAM_ERROR
        -:  848:#define Z_DATA_ERROR MZ_DATA_ERROR
        -:  849:#define Z_MEM_ERROR MZ_MEM_ERROR
        -:  850:#define Z_BUF_ERROR MZ_BUF_ERROR
        -:  851:#define Z_VERSION_ERROR MZ_VERSION_ERROR
        -:  852:#define Z_PARAM_ERROR MZ_PARAM_ERROR
        -:  853:#define Z_NO_COMPRESSION MZ_NO_COMPRESSION
        -:  854:#define Z_BEST_SPEED MZ_BEST_SPEED
        -:  855:#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
        -:  856:#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
        -:  857:#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
        -:  858:#define Z_FILTERED MZ_FILTERED
        -:  859:#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
        -:  860:#define Z_RLE MZ_RLE
        -:  861:#define Z_FIXED MZ_FIXED
        -:  862:#define Z_DEFLATED MZ_DEFLATED
        -:  863:#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
        -:  864:#define alloc_func mz_alloc_func
        -:  865:#define free_func mz_free_func
        -:  866:#define internal_state mz_internal_state
        -:  867:#define z_stream mz_stream
        -:  868:#define deflateInit mz_deflateInit
        -:  869:#define deflateInit2 mz_deflateInit2
        -:  870:#define deflateReset mz_deflateReset
        -:  871:#define deflate mz_deflate
        -:  872:#define deflateEnd mz_deflateEnd
        -:  873:#define deflateBound mz_deflateBound
        -:  874:#define compress mz_compress
        -:  875:#define compress2 mz_compress2
        -:  876:#define compressBound mz_compressBound
        -:  877:#define inflateInit mz_inflateInit
        -:  878:#define inflateInit2 mz_inflateInit2
        -:  879:#define inflate mz_inflate
        -:  880:#define inflateEnd mz_inflateEnd
        -:  881:#define uncompress mz_uncompress
        -:  882:#define crc32 mz_crc32
        -:  883:#define adler32 mz_adler32
        -:  884:#define MAX_WBITS 15
        -:  885:#define MAX_MEM_LEVEL 9
        -:  886:#define zError mz_error
        -:  887:#define ZLIB_VERSION MZ_VERSION
        -:  888:#define ZLIB_VERNUM MZ_VERNUM
        -:  889:#define ZLIB_VER_MAJOR MZ_VER_MAJOR
        -:  890:#define ZLIB_VER_MINOR MZ_VER_MINOR
        -:  891:#define ZLIB_VER_REVISION MZ_VER_REVISION
        -:  892:#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
        -:  893:#define zlibVersion mz_version
        -:  894:#define zlib_version mz_version()
        -:  895:#endif // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
        -:  896:
        -:  897:#endif // MINIZ_NO_ZLIB_APIS
        -:  898:
        -:  899:// ------------------- Types and macros
        -:  900:
        -:  901:typedef unsigned char mz_uint8;
        -:  902:typedef signed short mz_int16;
        -:  903:typedef unsigned short mz_uint16;
        -:  904:typedef unsigned int mz_uint32;
        -:  905:typedef unsigned int mz_uint;
        -:  906:typedef long long mz_int64;
        -:  907:typedef unsigned long long mz_uint64;
        -:  908:typedef int mz_bool;
        -:  909:
        -:  910:#define MZ_FALSE (0)
        -:  911:#define MZ_TRUE (1)
        -:  912:
        -:  913:// An attempt to work around MSVC's spammy "warning C4127: conditional
        -:  914:// expression is constant" message.
        -:  915:#ifdef _MSC_VER
        -:  916:#define MZ_MACRO_END while (0, 0)
        -:  917:#else
        -:  918:#define MZ_MACRO_END while (0)
        -:  919:#endif
        -:  920:
        -:  921:// ------------------- ZIP archive reading/writing
        -:  922:
        -:  923:#ifndef MINIZ_NO_ARCHIVE_APIS
        -:  924:
        -:  925:enum {
        -:  926:  MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
        -:  927:  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,
        -:  928:  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256
        -:  929:};
        -:  930:
        -:  931:typedef struct {
        -:  932:  mz_uint32 m_file_index;
        -:  933:  mz_uint32 m_central_dir_ofs;
        -:  934:  mz_uint16 m_version_made_by;
        -:  935:  mz_uint16 m_version_needed;
        -:  936:  mz_uint16 m_bit_flag;
        -:  937:  mz_uint16 m_method;
        -:  938:#ifndef MINIZ_NO_TIME
        -:  939:  time_t m_time;
        -:  940:#endif
        -:  941:  mz_uint32 m_crc32;
        -:  942:  mz_uint64 m_comp_size;
        -:  943:  mz_uint64 m_uncomp_size;
        -:  944:  mz_uint16 m_internal_attr;
        -:  945:  mz_uint32 m_external_attr;
        -:  946:  mz_uint64 m_local_header_ofs;
        -:  947:  mz_uint32 m_comment_size;
        -:  948:  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
        -:  949:  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
        -:  950:} mz_zip_archive_file_stat;
        -:  951:
        -:  952:typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs,
        -:  953:                                    void *pBuf, size_t n);
        -:  954:typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs,
        -:  955:                                     const void *pBuf, size_t n);
        -:  956:
        -:  957:struct mz_zip_internal_state_tag;
        -:  958:typedef struct mz_zip_internal_state_tag mz_zip_internal_state;
        -:  959:
        -:  960:typedef enum {
        -:  961:  MZ_ZIP_MODE_INVALID = 0,
        -:  962:  MZ_ZIP_MODE_READING = 1,
        -:  963:  MZ_ZIP_MODE_WRITING = 2,
        -:  964:  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
        -:  965:} mz_zip_mode;
        -:  966:
        -:  967:typedef struct mz_zip_archive_tag {
        -:  968:  mz_uint64 m_archive_size;
        -:  969:  mz_uint64 m_central_directory_file_ofs;
        -:  970:  mz_uint m_total_files;
        -:  971:  mz_zip_mode m_zip_mode;
        -:  972:
        -:  973:  mz_uint m_file_offset_alignment;
        -:  974:
        -:  975:  mz_alloc_func m_pAlloc;
        -:  976:  mz_free_func m_pFree;
        -:  977:  mz_realloc_func m_pRealloc;
        -:  978:  void *m_pAlloc_opaque;
        -:  979:
        -:  980:  mz_file_read_func m_pRead;
        -:  981:  mz_file_write_func m_pWrite;
        -:  982:  void *m_pIO_opaque;
        -:  983:
        -:  984:  mz_zip_internal_state *m_pState;
        -:  985:
        -:  986:} mz_zip_archive;
        -:  987:
        -:  988:typedef enum {
        -:  989:  MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
        -:  990:  MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
        -:  991:  MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
        -:  992:  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800
        -:  993:} mz_zip_flags;
        -:  994:
        -:  995:// ZIP archive reading
        -:  996:
        -:  997:// Inits a ZIP archive reader.
        -:  998:// These functions read and validate the archive's central directory.
        -:  999:inline mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,
        -: 1000:                           mz_uint32 flags);
        -: 1001:inline mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,
        -: 1002:                               size_t size, mz_uint32 flags);
        -: 1003:
        -: 1004:#ifndef MINIZ_NO_STDIO
        -: 1005:inline mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,
        -: 1006:                                mz_uint32 flags);
        -: 1007:#endif
        -: 1008:
        -: 1009:// Returns the total number of files in the archive.
        -: 1010:inline mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);
        -: 1011:
        -: 1012:// Returns detailed information about an archive file entry.
        -: 1013:inline mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,
        -: 1014:                                mz_zip_archive_file_stat *pStat);
        -: 1015:
        -: 1016:// Determines if an archive file entry is a directory entry.
        -: 1017:inline mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,
        -: 1018:                                          mz_uint file_index);
        -: 1019:inline mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,
        -: 1020:                                        mz_uint file_index);
        -: 1021:
        -: 1022:// Retrieves the filename of an archive file entry.
        -: 1023:// Returns the number of bytes written to pFilename, or if filename_buf_size is
        -: 1024:// 0 this function returns the number of bytes needed to fully store the
        -: 1025:// filename.
        -: 1026:inline mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,
        -: 1027:                                   char *pFilename, mz_uint filename_buf_size);
        -: 1028:
        -: 1029:// Attempts to locates a file in the archive's central directory.
        -: 1030:// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH
        -: 1031:// Returns -1 if the file cannot be found.
        -: 1032:inline int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,
        -: 1033:                              const char *pComment, mz_uint flags);
        -: 1034:
        -: 1035:// Extracts a archive file to a memory buffer using no memory allocation.
        -: 1036:inline mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,
        -: 1037:                                              mz_uint file_index, void *pBuf,
        -: 1038:                                              size_t buf_size, mz_uint flags,
        -: 1039:                                              void *pUser_read_buf,
        -: 1040:                                              size_t user_read_buf_size);
        -: 1041:inline mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(
        -: 1042:    mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,
        -: 1043:    mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
        -: 1044:
        -: 1045:// Extracts a archive file to a memory buffer.
        -: 1046:inline mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,
        -: 1047:                                     void *pBuf, size_t buf_size,
        -: 1048:                                     mz_uint flags);
        -: 1049:inline mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,
        -: 1050:                                          const char *pFilename, void *pBuf,
        -: 1051:                                          size_t buf_size, mz_uint flags);
        -: 1052:
        -: 1053:// Extracts a archive file to a dynamically allocated heap buffer.
        -: 1054:inline void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,
        -: 1055:                                    size_t *pSize, mz_uint flags);
        -: 1056:inline void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,
        -: 1057:                                         const char *pFilename, size_t *pSize,
        -: 1058:                                         mz_uint flags);
        -: 1059:
        -: 1060:// Extracts a archive file using a callback function to output the file's data.
        -: 1061:inline mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,
        -: 1062:                                          mz_uint file_index,
        -: 1063:                                          mz_file_write_func pCallback,
        -: 1064:                                          void *pOpaque, mz_uint flags);
        -: 1065:inline mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,
        -: 1066:                                               const char *pFilename,
        -: 1067:                                               mz_file_write_func pCallback,
        -: 1068:                                               void *pOpaque, mz_uint flags);
        -: 1069:
        -: 1070:#ifndef MINIZ_NO_STDIO
        -: 1071:// Extracts a archive file to a disk file and sets its last accessed and
        -: 1072:// modified times.
        -: 1073:// This function only extracts files, not archive directory records.
        -: 1074:inline mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,
        -: 1075:                                      const char *pDst_filename, mz_uint flags);
        -: 1076:inline mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,
        -: 1077:                                           const char *pArchive_filename,
        -: 1078:                                           const char *pDst_filename,
        -: 1079:                                           mz_uint flags);
        -: 1080:#endif
        -: 1081:
        -: 1082:// Ends archive reading, freeing all allocations, and closing the input archive
        -: 1083:// file if mz_zip_reader_init_file() was used.
        -: 1084:inline mz_bool mz_zip_reader_end(mz_zip_archive *pZip);
        -: 1085:
        -: 1086:// ZIP archive writing
        -: 1087:
        -: 1088:#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
        -: 1089:
        -: 1090:// Inits a ZIP archive writer.
        -: 1091:inline mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
        -: 1092:inline mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,
        -: 1093:                                size_t size_to_reserve_at_beginning,
        -: 1094:                                size_t initial_allocation_size);
        -: 1095:
        -: 1096:#ifndef MINIZ_NO_STDIO
        -: 1097:inline mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,
        -: 1098:                                mz_uint64 size_to_reserve_at_beginning);
        -: 1099:#endif
        -: 1100:
        -: 1101:// Converts a ZIP archive reader object into a writer object, to allow efficient
        -: 1102:// in-place file appends to occur on an existing archive.
        -: 1103:// For archives opened using mz_zip_reader_init_file, pFilename must be the
        -: 1104:// archive's filename so it can be reopened for writing. If the file can't be
        -: 1105:// reopened, mz_zip_reader_end() will be called.
        -: 1106:// For archives opened using mz_zip_reader_init_mem, the memory block must be
        -: 1107:// growable using the realloc callback (which defaults to realloc unless you've
        -: 1108:// overridden it).
        -: 1109:// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's
        -: 1110:// user provided m_pWrite function cannot be NULL.
        -: 1111:// Note: In-place archive modification is not recommended unless you know what
        -: 1112:// you're doing, because if execution stops or something goes wrong before
        -: 1113:// the archive is finalized the file's central directory will be hosed.
        -: 1114:inline mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,
        -: 1115:                                       const char *pFilename);
        -: 1116:
        -: 1117:// Adds the contents of a memory buffer to an archive. These functions record
        -: 1118:// the current local time into the archive.
        -: 1119:// To add a directory entry, call this method with an archive name ending in a
        -: 1120:// forwardslash with empty buffer.
        -: 1121:// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,
        -: 1122:// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or
        -: 1123:// just set to MZ_DEFAULT_COMPRESSION.
        -: 1124:inline mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,
        -: 1125:                              const void *pBuf, size_t buf_size,
        -: 1126:                              mz_uint level_and_flags);
        -: 1127:inline mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,
        -: 1128:                                 const char *pArchive_name, const void *pBuf,
        -: 1129:                                 size_t buf_size, const void *pComment,
        -: 1130:                                 mz_uint16 comment_size,
        -: 1131:                                 mz_uint level_and_flags, mz_uint64 uncomp_size,
        -: 1132:                                 mz_uint32 uncomp_crc32);
        -: 1133:
        -: 1134:#ifndef MINIZ_NO_STDIO
        -: 1135:// Adds the contents of a disk file to an archive. This function also records
        -: 1136:// the disk file's modified time into the archive.
        -: 1137:// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,
        -: 1138:// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or
        -: 1139:// just set to MZ_DEFAULT_COMPRESSION.
        -: 1140:inline mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,
        -: 1141:                               const char *pSrc_filename, const void *pComment,
        -: 1142:                               mz_uint16 comment_size, mz_uint level_and_flags);
        -: 1143:#endif
        -: 1144:
        -: 1145:// Adds a file to an archive by fully cloning the data from another archive.
        -: 1146:// This function fully clones the source file's compressed data (no
        -: 1147:// recompression), along with its full filename, extra data, and comment fields.
        -: 1148:inline mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,
        -: 1149:                                          mz_zip_archive *pSource_zip,
        -: 1150:                                          mz_uint file_index);
        -: 1151:
        -: 1152:// Finalizes the archive by writing the central directory records followed by
        -: 1153:// the end of central directory record.
        -: 1154:// After an archive is finalized, the only valid call on the mz_zip_archive
        -: 1155:// struct is mz_zip_writer_end().
        -: 1156:// An archive must be manually finalized by calling this function for it to be
        -: 1157:// valid.
        -: 1158:inline mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);
        -: 1159:inline mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,
        -: 1160:                                            size_t *pSize);
        -: 1161:
        -: 1162:// Ends archive writing, freeing all allocations, and closing the output file if
        -: 1163:// mz_zip_writer_init_file() was used.
        -: 1164:// Note for the archive to be valid, it must have been finalized before ending.
        -: 1165:inline mz_bool mz_zip_writer_end(mz_zip_archive *pZip);
        -: 1166:
        -: 1167:// Misc. high-level helper functions:
        -: 1168:
        -: 1169:// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically)
        -: 1170:// appends a memory blob to a ZIP archive.
        -: 1171:// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,
        -: 1172:// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or
        -: 1173:// just set to MZ_DEFAULT_COMPRESSION.
        -: 1174:inline mz_bool mz_zip_add_mem_to_archive_file_in_place(
        -: 1175:    const char *pZip_filename, const char *pArchive_name, const void *pBuf,
        -: 1176:    size_t buf_size, const void *pComment, mz_uint16 comment_size,
        -: 1177:    mz_uint level_and_flags);
        -: 1178:
        -: 1179:// Reads a single file from an archive into a heap block.
        -: 1180:// Returns NULL on failure.
        -: 1181:inline void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,
        -: 1182:                                          const char *pArchive_name,
        -: 1183:                                          size_t *pSize, mz_uint zip_flags);
        -: 1184:
        -: 1185:#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
        -: 1186:
        -: 1187:#endif // #ifndef MINIZ_NO_ARCHIVE_APIS
        -: 1188:
        -: 1189:// ------------------- Low-level Decompression API Definitions
        -: 1190:
        -: 1191:// Decompression flags used by tinfl_decompress().
        -: 1192:// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and
        -: 1193:// ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the
        -: 1194:// input is a raw deflate stream.
        -: 1195:// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available
        -: 1196:// beyond the end of the supplied input buffer. If clear, the input buffer
        -: 1197:// contains all remaining input.
        -: 1198:// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large
        -: 1199:// enough to hold the entire decompressed stream. If clear, the output buffer is
        -: 1200:// at least the size of the dictionary (typically 32KB).
        -: 1201:// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the
        -: 1202:// decompressed bytes.
        -: 1203:enum {
        -: 1204:  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
        -: 1205:  TINFL_FLAG_HAS_MORE_INPUT = 2,
        -: 1206:  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
        -: 1207:  TINFL_FLAG_COMPUTE_ADLER32 = 8
        -: 1208:};
        -: 1209:
        -: 1210:// High level decompression functions:
        -: 1211:// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block
        -: 1212:// allocated via malloc().
        -: 1213:// On entry:
        -: 1214://  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data
        -: 1215://  to decompress.
        -: 1216:// On return:
        -: 1217://  Function returns a pointer to the decompressed data, or NULL on failure.
        -: 1218://  *pOut_len will be set to the decompressed data's size, which could be larger
        -: 1219://  than src_buf_len on uncompressible data.
        -: 1220://  The caller must call mz_free() on the returned block when it's no longer
        -: 1221://  needed.
        -: 1222:inline void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
        -: 1223:                                   size_t *pOut_len, int flags);
        -: 1224:
        -: 1225:// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block
        -: 1226:// in memory.
        -: 1227:// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes
        -: 1228:// written on success.
        -: 1229:#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
        -: 1230:inline size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
        -: 1231:                                   const void *pSrc_buf, size_t src_buf_len,
        -: 1232:                                   int flags);
        -: 1233:
        -: 1234:// tinfl_decompress_mem_to_callback() decompresses a block in memory to an
        -: 1235:// internal 32KB buffer, and a user provided callback function will be called to
        -: 1236:// flush the buffer.
        -: 1237:// Returns 1 on success or 0 on failure.
        -: 1238:typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
        -: 1239:inline int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,
        -: 1240:                                     tinfl_put_buf_func_ptr pPut_buf_func,
        -: 1241:                                     void *pPut_buf_user, int flags);
        -: 1242:
        -: 1243:struct tinfl_decompressor_tag;
        -: 1244:typedef struct tinfl_decompressor_tag tinfl_decompressor;
        -: 1245:
        -: 1246:// Max size of LZ dictionary.
        -: 1247:#define TINFL_LZ_DICT_SIZE 32768
        -: 1248:
        -: 1249:// Return status.
        -: 1250:typedef enum {
        -: 1251:  TINFL_STATUS_BAD_PARAM = -3,
        -: 1252:  TINFL_STATUS_ADLER32_MISMATCH = -2,
        -: 1253:  TINFL_STATUS_FAILED = -1,
        -: 1254:  TINFL_STATUS_DONE = 0,
        -: 1255:  TINFL_STATUS_NEEDS_MORE_INPUT = 1,
        -: 1256:  TINFL_STATUS_HAS_MORE_OUTPUT = 2
        -: 1257:} tinfl_status;
        -: 1258:
        -: 1259:// Initializes the decompressor to its initial state.
        -: 1260:#define tinfl_init(r)                                                          \
        -: 1261:  do {                                                                         \
        -: 1262:    (r)->m_state = 0;                                                          \
        -: 1263:  }                                                                            \
        -: 1264:  MZ_MACRO_END
        -: 1265:#define tinfl_get_adler32(r) (r)->m_check_adler32
        -: 1266:
        -: 1267:// Main low-level decompressor coroutine function. This is the only function
        -: 1268:// actually needed for decompression. All the other functions are just
        -: 1269:// high-level helpers for improved usability.
        -: 1270:// This is a universal API, i.e. it can be used as a building block to build any
        -: 1271:// desired higher level decompression API. In the limit case, it can be called
        -: 1272:// once per every byte input or output.
        -: 1273:tinfl_status tinfl_decompress(tinfl_decompressor *r,
        -: 1274:                              const mz_uint8 *pIn_buf_next,
        -: 1275:                              size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,
        -: 1276:                              mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
        -: 1277:                              const mz_uint32 decomp_flags);
        -: 1278:
        -: 1279:// Internal/private bits follow.
        -: 1280:enum {
        -: 1281:  TINFL_MAX_HUFF_TABLES = 3,
        -: 1282:  TINFL_MAX_HUFF_SYMBOLS_0 = 288,
        -: 1283:  TINFL_MAX_HUFF_SYMBOLS_1 = 32,
        -: 1284:  TINFL_MAX_HUFF_SYMBOLS_2 = 19,
        -: 1285:  TINFL_FAST_LOOKUP_BITS = 10,
        -: 1286:  TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
        -: 1287:};
        -: 1288:
        -: 1289:typedef struct {
        -: 1290:  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];
        -: 1291:  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE],
        -: 1292:      m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
        -: 1293:} tinfl_huff_table;
        -: 1294:
        -: 1295:#if MINIZ_HAS_64BIT_REGISTERS
        -: 1296:#define TINFL_USE_64BIT_BITBUF 1
        -: 1297:#endif
        -: 1298:
        -: 1299:#if TINFL_USE_64BIT_BITBUF
        -: 1300:typedef mz_uint64 tinfl_bit_buf_t;
        -: 1301:#define TINFL_BITBUF_SIZE (64)
        -: 1302:#else
        -: 1303:typedef mz_uint32 tinfl_bit_buf_t;
        -: 1304:#define TINFL_BITBUF_SIZE (32)
        -: 1305:#endif
        -: 1306:
        -: 1307:struct tinfl_decompressor_tag {
        -: 1308:  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type,
        -: 1309:      m_check_adler32, m_dist, m_counter, m_num_extra,
        -: 1310:      m_table_sizes[TINFL_MAX_HUFF_TABLES];
        -: 1311:  tinfl_bit_buf_t m_bit_buf;
        -: 1312:  size_t m_dist_from_out_buf_start;
        -: 1313:  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];
        -: 1314:  mz_uint8 m_raw_header[4],
        -: 1315:      m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
        -: 1316:};
        -: 1317:
        -: 1318:// ------------------- Low-level Compression API Definitions
        -: 1319:
        -: 1320:// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly
        -: 1321:// slower, and raw/dynamic blocks will be output more frequently).
        -: 1322:#define TDEFL_LESS_MEMORY 0
        -: 1323:
        -: 1324:// tdefl_init() compression flags logically OR'd together (low 12 bits contain
        -: 1325:// the max. number of probes per dictionary search):
        -: 1326:// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes
        -: 1327:// per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap
        -: 1328:// compression), 4095=Huffman+LZ (slowest/best compression).
        -: 1329:enum {
        -: 1330:  TDEFL_HUFFMAN_ONLY = 0,
        -: 1331:  TDEFL_DEFAULT_MAX_PROBES = 128,
        -: 1332:  TDEFL_MAX_PROBES_MASK = 0xFFF
        -: 1333:};
        -: 1334:
        -: 1335:// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before
        -: 1336:// the deflate data, and the Adler-32 of the source data at the end. Otherwise,
        -: 1337:// you'll get raw deflate data.
        -: 1338:// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even
        -: 1339:// when not writing zlib headers).
        -: 1340:// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more
        -: 1341:// efficient lazy parsing.
        -: 1342:// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's
        -: 1343:// initialization time to the minimum, but the output may vary from run to run
        -: 1344:// given the same input (depending on the contents of memory).
        -: 1345:// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)
        -: 1346:// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.
        -: 1347:// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.
        -: 1348:// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.
        -: 1349:// The low 12 bits are reserved to control the max # of hash probes per
        -: 1350:// dictionary lookup (see TDEFL_MAX_PROBES_MASK).
        -: 1351:enum {
        -: 1352:  TDEFL_WRITE_ZLIB_HEADER = 0x01000,
        -: 1353:  TDEFL_COMPUTE_ADLER32 = 0x02000,
        -: 1354:  TDEFL_GREEDY_PARSING_FLAG = 0x04000,
        -: 1355:  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
        -: 1356:  TDEFL_RLE_MATCHES = 0x10000,
        -: 1357:  TDEFL_FILTER_MATCHES = 0x20000,
        -: 1358:  TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
        -: 1359:  TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
        -: 1360:};
        -: 1361:
        -: 1362:// High level compression functions:
        -: 1363:// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block
        -: 1364:// allocated via malloc().
        -: 1365:// On entry:
        -: 1366://  pSrc_buf, src_buf_len: Pointer and size of source block to compress.
        -: 1367://  flags: The max match finder probes (default is 128) logically OR'd against
        -: 1368://  the above flags. Higher probes are slower but improve compression.
        -: 1369:// On return:
        -: 1370://  Function returns a pointer to the compressed data, or NULL on failure.
        -: 1371://  *pOut_len will be set to the compressed data's size, which could be larger
        -: 1372://  than src_buf_len on uncompressible data.
        -: 1373://  The caller must free() the returned block when it's no longer needed.
        -: 1374:void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
        -: 1375:                                 size_t *pOut_len, int flags);
        -: 1376:
        -: 1377:// tdefl_compress_mem_to_mem() compresses a block in memory to another block in
        -: 1378:// memory.
        -: 1379:// Returns 0 on failure.
        -: 1380:size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
        -: 1381:                                 const void *pSrc_buf, size_t src_buf_len,
        -: 1382:                                 int flags);
        -: 1383:
        -: 1384:// Compresses an image to a compressed PNG file in memory.
        -: 1385:// On entry:
        -: 1386://  pImage, w, h, and num_chans describe the image to compress. num_chans may be
        -: 1387://  1, 2, 3, or 4.
        -: 1388://  The image pitch in bytes per scanline will be w*num_chans. The leftmost
        -: 1389://  pixel on the top scanline is stored first in memory.
        -: 1390://  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED,
        -: 1391://  MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL
        -: 1392://  If flip is true, the image will be flipped on the Y axis (useful for OpenGL
        -: 1393://  apps).
        -: 1394:// On return:
        -: 1395://  Function returns a pointer to the compressed data, or NULL on failure.
        -: 1396://  *pLen_out will be set to the size of the PNG image file.
        -: 1397://  The caller must mz_free() the returned heap block (which will typically be
        -: 1398://  larger than *pLen_out) when it's no longer needed.
        -: 1399:void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,
        -: 1400:                                                 int h, int num_chans,
        -: 1401:                                                 size_t *pLen_out,
        -: 1402:                                                 mz_uint level, mz_bool flip);
        -: 1403:void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,
        -: 1404:                                              int num_chans, size_t *pLen_out);
        -: 1405:
        -: 1406:// Output stream interface. The compressor uses this interface to write
        -: 1407:// compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.
        -: 1408:typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len,
        -: 1409:                                          void *pUser);
        -: 1410:
        -: 1411:// tdefl_compress_mem_to_output() compresses a block to an output stream. The
        -: 1412:// above helpers use this function internally.
        -: 1413:mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,
        -: 1414:                                     tdefl_put_buf_func_ptr pPut_buf_func,
        -: 1415:                                     void *pPut_buf_user, int flags);
        -: 1416:
        -: 1417:enum {
        -: 1418:  TDEFL_MAX_HUFF_TABLES = 3,
        -: 1419:  TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
        -: 1420:  TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
        -: 1421:  TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
        -: 1422:  TDEFL_LZ_DICT_SIZE = 32768,
        -: 1423:  TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
        -: 1424:  TDEFL_MIN_MATCH_LEN = 3,
        -: 1425:  TDEFL_MAX_MATCH_LEN = 258
        -: 1426:};
        -: 1427:
        -: 1428:// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed
        -: 1429:// output block (using static/fixed Huffman codes).
        -: 1430:#if TDEFL_LESS_MEMORY
        -: 1431:enum {
        -: 1432:  TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
        -: 1433:  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
        -: 1434:  TDEFL_MAX_HUFF_SYMBOLS = 288,
        -: 1435:  TDEFL_LZ_HASH_BITS = 12,
        -: 1436:  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
        -: 1437:  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
        -: 1438:  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
        -: 1439:};
        -: 1440:#else
        -: 1441:enum {
        -: 1442:  TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
        -: 1443:  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
        -: 1444:  TDEFL_MAX_HUFF_SYMBOLS = 288,
        -: 1445:  TDEFL_LZ_HASH_BITS = 15,
        -: 1446:  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
        -: 1447:  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
        -: 1448:  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
        -: 1449:};
        -: 1450:#endif
        -: 1451:
        -: 1452:// The low-level tdefl functions below may be used directly if the above helper
        -: 1453:// functions aren't flexible enough. The low-level functions don't make any heap
        -: 1454:// allocations, unlike the above helper functions.
        -: 1455:typedef enum {
        -: 1456:  TDEFL_STATUS_BAD_PARAM = -2,
        -: 1457:  TDEFL_STATUS_PUT_BUF_FAILED = -1,
        -: 1458:  TDEFL_STATUS_OKAY = 0,
        -: 1459:  TDEFL_STATUS_DONE = 1,
        -: 1460:} tdefl_status;
        -: 1461:
        -: 1462:// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums
        -: 1463:typedef enum {
        -: 1464:  TDEFL_NO_FLUSH = 0,
        -: 1465:  TDEFL_SYNC_FLUSH = 2,
        -: 1466:  TDEFL_FULL_FLUSH = 3,
        -: 1467:  TDEFL_FINISH = 4
        -: 1468:} tdefl_flush;
        -: 1469:
        -: 1470:// tdefl's compression state structure.
        -: 1471:typedef struct {
        -: 1472:  tdefl_put_buf_func_ptr m_pPut_buf_func;
        -: 1473:  void *m_pPut_buf_user;
        -: 1474:  mz_uint m_flags, m_max_probes[2];
        -: 1475:  int m_greedy_parsing;
        -: 1476:  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
        -: 1477:  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
        -: 1478:  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in,
        -: 1479:      m_bit_buffer;
        -: 1480:  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit,
        -: 1481:      m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index,
        -: 1482:      m_wants_to_finish;
        -: 1483:  tdefl_status m_prev_return_status;
        -: 1484:  const void *m_pIn_buf;
        -: 1485:  void *m_pOut_buf;
        -: 1486:  size_t *m_pIn_buf_size, *m_pOut_buf_size;
        -: 1487:  tdefl_flush m_flush;
        -: 1488:  const mz_uint8 *m_pSrc;
        -: 1489:  size_t m_src_buf_left, m_out_buf_ofs;
        -: 1490:  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
        -: 1491:  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
        -: 1492:  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
        -: 1493:  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
        -: 1494:  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
        -: 1495:  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
        -: 1496:  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
        -: 1497:  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
        -: 1498:} tdefl_compressor;
        -: 1499:
        -: 1500:// Initializes the compressor.
        -: 1501:// There is no corresponding deinit() function because the tdefl API's do not
        -: 1502:// dynamically allocate memory.
        -: 1503:// pBut_buf_func: If NULL, output data will be supplied to the specified
        -: 1504:// callback. In this case, the user should call the tdefl_compress_buffer() API
        -: 1505:// for compression.
        -: 1506:// If pBut_buf_func is NULL the user should always call the tdefl_compress()
        -: 1507:// API.
        -: 1508:// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER,
        -: 1509:// etc.)
        -: 1510:inline tdefl_status tdefl_init(tdefl_compressor *d,
        -: 1511:                        tdefl_put_buf_func_ptr pPut_buf_func,
        -: 1512:                        void *pPut_buf_user, int flags);
        -: 1513:
        -: 1514:// Compresses a block of data, consuming as much of the specified input buffer
        -: 1515:// as possible, and writing as much compressed data to the specified output
        -: 1516:// buffer as possible.
        -: 1517:inline tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,
        -: 1518:                            size_t *pIn_buf_size, void *pOut_buf,
        -: 1519:                            size_t *pOut_buf_size, tdefl_flush flush);
        -: 1520:
        -: 1521:// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a
        -: 1522:// non-NULL tdefl_put_buf_func_ptr.
        -: 1523:// tdefl_compress_buffer() always consumes the entire input buffer.
        -: 1524:inline tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,
        -: 1525:                                   size_t in_buf_size, tdefl_flush flush);
        -: 1526:
        -: 1527:inline tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
        -: 1528:inline mz_uint32 tdefl_get_adler32(tdefl_compressor *d);
        -: 1529:
        -: 1530:// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't
        -: 1531:// defined, because it uses some of its macros.
        -: 1532:#ifndef MINIZ_NO_ZLIB_APIS
        -: 1533:// Create tdefl_compress() flags given zlib-style compression parameters.
        -: 1534:// level may range from [0,10] (where 10 is absolute max compression, but may be
        -: 1535:// much slower on some files)
        -: 1536:// window_bits may be -15 (raw deflate) or 15 (zlib)
        -: 1537:// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY,
        -: 1538:// MZ_RLE, or MZ_FIXED
        -: 1539:mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,
        -: 1540:                                                int strategy);
        -: 1541:#endif // #ifndef MINIZ_NO_ZLIB_APIS
        -: 1542:
        -: 1543:#ifdef __cplusplus
        -: 1544:}
        -: 1545:#endif
        -: 1546:
        -: 1547:#endif // MINIZ_HEADER_INCLUDED
        -: 1548:
        -: 1549:// ------------------- End of Header: Implementation follows. (If you only want
        -: 1550:// the header, define MINIZ_HEADER_FILE_ONLY.)
        -: 1551:
        -: 1552:#ifndef MINIZ_HEADER_FILE_ONLY
        -: 1553:
        -: 1554:typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
        -: 1555:typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
        -: 1556:typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];
        -: 1557:
        -: 1558:#include <string.h>
        -: 1559:#include <assert.h>
        -: 1560:
        -: 1561:#define MZ_ASSERT(x) assert(x)
        -: 1562:
        -: 1563:#ifdef MINIZ_NO_MALLOC
        -: 1564:#define MZ_MALLOC(x) NULL
        -: 1565:#define MZ_FREE(x) (void) x, ((void)0)
        -: 1566:#define MZ_REALLOC(p, x) NULL
        -: 1567:#else
        -: 1568:#define MZ_MALLOC(x) malloc(x)
        -: 1569:#define MZ_FREE(x) free(x)
        -: 1570:#define MZ_REALLOC(p, x) realloc(p, x)
        -: 1571:#endif
        -: 1572:
        -: 1573:#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
        -: 1574:#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
        -: 1575:#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
        -: 1576:
        -: 1577:#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
        -: 1578:#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
        -: 1579:#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
        -: 1580:#else
        -: 1581:#define MZ_READ_LE16(p)                                                        \
        -: 1582:  ((mz_uint32)(((const mz_uint8 *)(p))[0]) |                                   \
        -: 1583:   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
        -: 1584:#define MZ_READ_LE32(p)                                                        \
        -: 1585:  ((mz_uint32)(((const mz_uint8 *)(p))[0]) |                                   \
        -: 1586:   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) |                           \
        -: 1587:   ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) |                          \
        -: 1588:   ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
        -: 1589:#endif
        -: 1590:
        -: 1591:#ifdef _MSC_VER
        -: 1592:#define MZ_FORCEINLINE __forceinline
        -: 1593:#elif defined(__GNUC__)
        -: 1594:#define MZ_FORCEINLINE inline __attribute__((__always_inline__))
        -: 1595:#else
        -: 1596:#define MZ_FORCEINLINE inline
        -: 1597:#endif
        -: 1598:
        -: 1599:#ifdef __cplusplus
        -: 1600:extern "C" {
        -: 1601:#endif
        -: 1602:
        -: 1603:// ------------------- zlib-style API's
        -: 1604:
    #####: 1605:mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len) {
    #####: 1606:  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
    #####: 1607:  size_t block_len = buf_len % 5552;
    #####: 1608:  if (!ptr)
    %%%%%: 1608-block  0
        -: 1609:    return MZ_ADLER32_INIT;
    #####: 1610:  while (buf_len) {
    %%%%%: 1610-block  0
    #####: 1611:    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
    %%%%%: 1611-block  0
    #####: 1612:      s1 += ptr[0], s2 += s1;
    #####: 1613:      s1 += ptr[1], s2 += s1;
    #####: 1614:      s1 += ptr[2], s2 += s1;
    #####: 1615:      s1 += ptr[3], s2 += s1;
    #####: 1616:      s1 += ptr[4], s2 += s1;
    #####: 1617:      s1 += ptr[5], s2 += s1;
    #####: 1618:      s1 += ptr[6], s2 += s1;
    #####: 1619:      s1 += ptr[7], s2 += s1;
    %%%%%: 1619-block  0
        -: 1620:    }
    #####: 1621:    for (; i < block_len; ++i)
    %%%%%: 1621-block  0
    #####: 1622:      s1 += *ptr++, s2 += s1;
    %%%%%: 1622-block  0
    #####: 1623:    s1 %= 65521U, s2 %= 65521U;
    #####: 1624:    buf_len -= block_len;
    #####: 1625:    block_len = 5552;
    %%%%%: 1625-block  0
        -: 1626:  }
    #####: 1627:  return (s2 << 16) + s1;
    %%%%%: 1627-block  0
        -: 1628:}
        -: 1629:
        -: 1630:// Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C
        -: 1631:// implementation that balances processor cache usage against speed":
        -: 1632:// http://www.geocities.com/malbrain/
        -: 1633:mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len) {
        -: 1634:  static const mz_uint32 s_crc32[16] = {
        -: 1635:      0,          0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4,
        -: 1636:      0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
        -: 1637:      0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c};
        -: 1638:  mz_uint32 crcu32 = (mz_uint32)crc;
        -: 1639:  if (!ptr)
        -: 1640:    return MZ_CRC32_INIT;
        -: 1641:  crcu32 = ~crcu32;
        -: 1642:  while (buf_len--) {
        -: 1643:    mz_uint8 b = *ptr++;
        -: 1644:    crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
        -: 1645:    crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
        -: 1646:  }
        -: 1647:  return ~crcu32;
        -: 1648:}
        -: 1649:
        -: 1650:void mz_free(void *p) { MZ_FREE(p); }
        -: 1651:
        -: 1652:#ifndef MINIZ_NO_ZLIB_APIS
        -: 1653:
    #####: 1654:static void *def_alloc_func(void *opaque, size_t items, size_t size) {
    #####: 1655:  (void)opaque, (void)items, (void)size;
    #####: 1656:  return MZ_MALLOC(items * size);
        -: 1657:}
    #####: 1658:static void def_free_func(void *opaque, void *address) {
    #####: 1659:  (void)opaque, (void)address;
    #####: 1660:  MZ_FREE(address);
    #####: 1661:}
        -: 1662:static void *def_realloc_func(void *opaque, void *address, size_t items,
        -: 1663:                              size_t size) {
        -: 1664:  (void)opaque, (void)address, (void)items, (void)size;
        -: 1665:  return MZ_REALLOC(address, items * size);
        -: 1666:}
        -: 1667:
        -: 1668:inline const char *mz_version(void) { return MZ_VERSION; }
        -: 1669:
    #####: 1670:inline int mz_deflateInit(mz_streamp pStream, int level) {
    #####: 1671:  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9,
        -: 1672:                         MZ_DEFAULT_STRATEGY);
        -: 1673:}
        -: 1674:
    #####: 1675:inline int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,
        -: 1676:                    int mem_level, int strategy) {
    #####: 1677:  tdefl_compressor *pComp;
    #####: 1678:  mz_uint comp_flags =
        -: 1679:      TDEFL_COMPUTE_ADLER32 |
    #####: 1680:      tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);
        -: 1681:
    #####: 1682:  if (!pStream)
    %%%%%: 1682-block  0
        -: 1683:    return MZ_STREAM_ERROR;
    #####: 1684:  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) ||
    %%%%%: 1684-block  0
    %%%%%: 1684-block  1
    #####: 1685:      ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&
    #####: 1686:       (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
    %%%%%: 1686-block  0
        -: 1687:    return MZ_PARAM_ERROR;
        -: 1688:
    #####: 1689:  pStream->data_type = 0;
    #####: 1690:  pStream->adler = MZ_ADLER32_INIT;
    #####: 1691:  pStream->msg = NULL;
    #####: 1692:  pStream->reserved = 0;
    #####: 1693:  pStream->total_in = 0;
    #####: 1694:  pStream->total_out = 0;
    #####: 1695:  if (!pStream->zalloc)
    %%%%%: 1695-block  0
    #####: 1696:    pStream->zalloc = def_alloc_func;
    %%%%%: 1696-block  0
    #####: 1697:  if (!pStream->zfree)
    %%%%%: 1697-block  0
    #####: 1698:    pStream->zfree = def_free_func;
    %%%%%: 1698-block  0
        -: 1699:
    #####: 1700:  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1,
    %%%%%: 1700-block  0
        -: 1701:                                              sizeof(tdefl_compressor));
    #####: 1702:  if (!pComp)
        -: 1703:    return MZ_MEM_ERROR;
        -: 1704:
    #####: 1705:  pStream->state = (struct mz_internal_state *)pComp;
        -: 1706:
    #####: 1707:  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY) {
    %%%%%: 1707-block  0
    #####: 1708:    mz_deflateEnd(pStream);
    #####: 1709:    return MZ_PARAM_ERROR;
    %%%%%: 1709-block  0
        -: 1710:  }
        -: 1711:
        -: 1712:  return MZ_OK;
        -: 1713:}
        -: 1714:
        -: 1715:inline int mz_deflateReset(mz_streamp pStream) {
        -: 1716:  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) ||
        -: 1717:      (!pStream->zfree))
        -: 1718:    return MZ_STREAM_ERROR;
        -: 1719:  pStream->total_in = pStream->total_out = 0;
        -: 1720:  tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL,
        -: 1721:             ((tdefl_compressor *)pStream->state)->m_flags);
        -: 1722:  return MZ_OK;
        -: 1723:}
        -: 1724:
    #####: 1725:inline int mz_deflate(mz_streamp pStream, int flush) {
    #####: 1726:  size_t in_bytes, out_bytes;
    #####: 1727:  mz_ulong orig_total_in, orig_total_out;
    #####: 1728:  int mz_status = MZ_OK;
        -: 1729:
    #####: 1730:  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) ||
    %%%%%: 1730-block  0
    %%%%%: 1730-block  1
    %%%%%: 1730-block  2
    #####: 1731:      (!pStream->next_out))
    %%%%%: 1731-block  0
        -: 1732:    return MZ_STREAM_ERROR;
    #####: 1733:  if (!pStream->avail_out)
    %%%%%: 1733-block  0
        -: 1734:    return MZ_BUF_ERROR;
        -: 1735:
    #####: 1736:  if (flush == MZ_PARTIAL_FLUSH)
    %%%%%: 1736-block  0
    #####: 1737:    flush = MZ_SYNC_FLUSH;
    %%%%%: 1737-block  0
        -: 1738:
    #####: 1739:  if (((tdefl_compressor *)pStream->state)->m_prev_return_status ==
    %%%%%: 1739-block  0
        -: 1740:      TDEFL_STATUS_DONE)
    #####: 1741:    return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;
    %%%%%: 1741-block  0
    %%%%%: 1741-block  1
        -: 1742:
    #####: 1743:  orig_total_in = pStream->total_in;
    #####: 1744:  orig_total_out = pStream->total_out;
    %%%%%: 1744-block  0
    #####: 1745:  for (;;) {
    #####: 1746:    tdefl_status defl_status;
    #####: 1747:    in_bytes = pStream->avail_in;
    #####: 1748:    out_bytes = pStream->avail_out;
        -: 1749:
    #####: 1750:    defl_status = tdefl_compress((tdefl_compressor *)pStream->state,
    #####: 1751:                                 pStream->next_in, &in_bytes, pStream->next_out,
    %%%%%: 1751-block  0
        -: 1752:                                 &out_bytes, (tdefl_flush)flush);
    #####: 1753:    pStream->next_in += (mz_uint)in_bytes;
    #####: 1754:    pStream->avail_in -= (mz_uint)in_bytes;
    #####: 1755:    pStream->total_in += (mz_uint)in_bytes;
    #####: 1756:    pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);
        -: 1757:
    #####: 1758:    pStream->next_out += (mz_uint)out_bytes;
    #####: 1759:    pStream->avail_out -= (mz_uint)out_bytes;
    #####: 1760:    pStream->total_out += (mz_uint)out_bytes;
        -: 1761:
    #####: 1762:    if (defl_status < 0) {
        -: 1763:      mz_status = MZ_STREAM_ERROR;
        -: 1764:      break;
    #####: 1765:    } else if (defl_status == TDEFL_STATUS_DONE) {
    %%%%%: 1765-block  0
        -: 1766:      mz_status = MZ_STREAM_END;
        -: 1767:      break;
    #####: 1768:    } else if (!pStream->avail_out)
    %%%%%: 1768-block  0
        -: 1769:      break;
    #####: 1770:    else if ((!pStream->avail_in) && (flush != MZ_FINISH)) {
    %%%%%: 1770-block  0
    %%%%%: 1770-block  1
    #####: 1771:      if ((flush) || (pStream->total_in != orig_total_in) ||
    %%%%%: 1771-block  0
    %%%%%: 1771-block  1
    %%%%%: 1771-block  2
        -: 1772:          (pStream->total_out != orig_total_out))
        -: 1773:        break;
    #####: 1774:      return MZ_BUF_ERROR; // Can't make forward progress without some input.
    %%%%%: 1774-block  0
        -: 1775:    }
        -: 1776:  }
        -: 1777:  return mz_status;
        -: 1778:}
        -: 1779:
    #####: 1780:inline int mz_deflateEnd(mz_streamp pStream) {
    #####: 1781:  if (!pStream)
        -: 1782:    return MZ_STREAM_ERROR;
    #####: 1783:  if (pStream->state) {
    %%%%%: 1783-block  0
    #####: 1784:    pStream->zfree(pStream->opaque, pStream->state);
    %%%%%: 1784-block  0
    %%%%%: 1784-block  1
    %%%%%: 1784-block  2
    #####: 1785:    pStream->state = NULL;
        -: 1786:  }
        -: 1787:  return MZ_OK;
        -: 1788:}
        -: 1789:
    #####: 1790:inline mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len) {
    #####: 1791:  (void)pStream;
        -: 1792:  // This is really over conservative. (And lame, but it's actually pretty
        -: 1793:  // tricky to compute a true upper bound given the way tdefl's blocking works.)
    #####: 1794:  return MZ_MAX(128 + (source_len * 110) / 100,
        -: 1795:                128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
        -: 1796:}
        -: 1797:
    #####: 1798:inline int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,
        -: 1799:                 const unsigned char *pSource, mz_ulong source_len, int level) {
    #####: 1800:  int status;
    #####: 1801:  mz_stream stream;
    #####: 1802:  memset(&stream, 0, sizeof(stream));
    %%%%%: 1802-block  0
        -: 1803:
        -: 1804:  // In case mz_ulong is 64-bits (argh I hate longs).
    #####: 1805:  if ((source_len | *pDest_len) > 0xFFFFFFFFU)
    %%%%%: 1805-block  0
        -: 1806:    return MZ_PARAM_ERROR;
        -: 1807:
    #####: 1808:  stream.next_in = pSource;
    #####: 1809:  stream.avail_in = (mz_uint32)source_len;
    #####: 1810:  stream.next_out = pDest;
    #####: 1811:  stream.avail_out = (mz_uint32)*pDest_len;
        -: 1812:
    #####: 1813:  status = mz_deflateInit(&stream, level);
    %%%%%: 1813-block  0
    #####: 1814:  if (status != MZ_OK)
        -: 1815:    return status;
        -: 1816:
    #####: 1817:  status = mz_deflate(&stream, MZ_FINISH);
    %%%%%: 1817-block  0
    #####: 1818:  if (status != MZ_STREAM_END) {
    #####: 1819:    mz_deflateEnd(&stream);
    %%%%%: 1819-block  0
    #####: 1820:    return (status == MZ_OK) ? MZ_BUF_ERROR : status;
    %%%%%: 1820-block  0
    %%%%%: 1820-block  1
        -: 1821:  }
        -: 1822:
    #####: 1823:  *pDest_len = stream.total_out;
    #####: 1824:  return mz_deflateEnd(&stream);
    %%%%%: 1824-block  0
        -: 1825:}
        -: 1826:
    #####: 1827:inline int mz_compress(unsigned char *pDest, mz_ulong *pDest_len,
        -: 1828:                const unsigned char *pSource, mz_ulong source_len) {
    #####: 1829:  return mz_compress2(pDest, pDest_len, pSource, source_len,
        -: 1830:                      MZ_DEFAULT_COMPRESSION);
        -: 1831:}
        -: 1832:
    #####: 1833:inline mz_ulong mz_compressBound(mz_ulong source_len) {
    #####: 1834:  return mz_deflateBound(NULL, source_len);
        -: 1835:}
        -: 1836:
        -: 1837:typedef struct {
        -: 1838:  tinfl_decompressor m_decomp;
        -: 1839:  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
        -: 1840:  int m_window_bits;
        -: 1841:  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
        -: 1842:  tinfl_status m_last_status;
        -: 1843:} inflate_state;
        -: 1844:
    #####: 1845:inline int mz_inflateInit2(mz_streamp pStream, int window_bits) {
    #####: 1846:  inflate_state *pDecomp;
    #####: 1847:  if (!pStream)
    %%%%%: 1847-block  0
        -: 1848:    return MZ_STREAM_ERROR;
    #####: 1849:  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&
    #####: 1850:      (-window_bits != MZ_DEFAULT_WINDOW_BITS))
    %%%%%: 1850-block  0
        -: 1851:    return MZ_PARAM_ERROR;
        -: 1852:
    #####: 1853:  pStream->data_type = 0;
    #####: 1854:  pStream->adler = 0;
    #####: 1855:  pStream->msg = NULL;
    #####: 1856:  pStream->total_in = 0;
    #####: 1857:  pStream->total_out = 0;
    #####: 1858:  pStream->reserved = 0;
    #####: 1859:  if (!pStream->zalloc)
    %%%%%: 1859-block  0
    #####: 1860:    pStream->zalloc = def_alloc_func;
    %%%%%: 1860-block  0
    #####: 1861:  if (!pStream->zfree)
    %%%%%: 1861-block  0
    #####: 1862:    pStream->zfree = def_free_func;
    %%%%%: 1862-block  0
        -: 1863:
    #####: 1864:  pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1,
    %%%%%: 1864-block  0
        -: 1865:                                             sizeof(inflate_state));
    #####: 1866:  if (!pDecomp)
        -: 1867:    return MZ_MEM_ERROR;
        -: 1868:
    #####: 1869:  pStream->state = (struct mz_internal_state *)pDecomp;
        -: 1870:
    #####: 1871:  tinfl_init(&pDecomp->m_decomp);
    #####: 1872:  pDecomp->m_dict_ofs = 0;
    #####: 1873:  pDecomp->m_dict_avail = 0;
    #####: 1874:  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
    #####: 1875:  pDecomp->m_first_call = 1;
    #####: 1876:  pDecomp->m_has_flushed = 0;
    #####: 1877:  pDecomp->m_window_bits = window_bits;
        -: 1878:
    #####: 1879:  return MZ_OK;
    %%%%%: 1879-block  0
        -: 1880:}
        -: 1881:
    #####: 1882:inline int mz_inflateInit(mz_streamp pStream) {
    #####: 1883:  return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
        -: 1884:}
        -: 1885:
    #####: 1886:inline int mz_inflate(mz_streamp pStream, int flush) {
    #####: 1887:  inflate_state *pState;
    #####: 1888:  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    #####: 1889:  size_t in_bytes, out_bytes, orig_avail_in;
    #####: 1890:  tinfl_status status;
        -: 1891:
    #####: 1892:  if ((!pStream) || (!pStream->state))
    %%%%%: 1892-block  0
    %%%%%: 1892-block  1
        -: 1893:    return MZ_STREAM_ERROR;
    #####: 1894:  if (flush == MZ_PARTIAL_FLUSH)
    %%%%%: 1894-block  0
    #####: 1895:    flush = MZ_SYNC_FLUSH;
    %%%%%: 1895-block  0
    #####: 1896:  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
    %%%%%: 1896-block  0
    %%%%%: 1896-block  1
        -: 1897:    return MZ_STREAM_ERROR;
        -: 1898:
    #####: 1899:  pState = (inflate_state *)pStream->state;
    #####: 1900:  if (pState->m_window_bits > 0)
    %%%%%: 1900-block  0
    #####: 1901:    decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
    %%%%%: 1901-block  0
    #####: 1902:  orig_avail_in = pStream->avail_in;
        -: 1903:
    #####: 1904:  first_call = pState->m_first_call;
    #####: 1905:  pState->m_first_call = 0;
    #####: 1906:  if (pState->m_last_status < 0)
    %%%%%: 1906-block  0
        -: 1907:    return MZ_DATA_ERROR;
        -: 1908:
    #####: 1909:  if (pState->m_has_flushed && (flush != MZ_FINISH))
    %%%%%: 1909-block  0
    %%%%%: 1909-block  1
        -: 1910:    return MZ_STREAM_ERROR;
    #####: 1911:  pState->m_has_flushed |= (flush == MZ_FINISH);
        -: 1912:
    #####: 1913:  if ((flush == MZ_FINISH) && (first_call)) {
    %%%%%: 1913-block  0
        -: 1914:    // MZ_FINISH on the first call implies that the input and output buffers are
        -: 1915:    // large enough to hold the entire compressed/decompressed file.
    #####: 1916:    decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
    #####: 1917:    in_bytes = pStream->avail_in;
    #####: 1918:    out_bytes = pStream->avail_out;
    #####: 1919:    status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes,
    %%%%%: 1919-block  0
        -: 1920:                              pStream->next_out, pStream->next_out, &out_bytes,
        -: 1921:                              decomp_flags);
    #####: 1922:    pState->m_last_status = status;
    #####: 1923:    pStream->next_in += (mz_uint)in_bytes;
    #####: 1924:    pStream->avail_in -= (mz_uint)in_bytes;
    #####: 1925:    pStream->total_in += (mz_uint)in_bytes;
    #####: 1926:    pStream->adler = tinfl_get_adler32(&pState->m_decomp);
    #####: 1927:    pStream->next_out += (mz_uint)out_bytes;
    #####: 1928:    pStream->avail_out -= (mz_uint)out_bytes;
    #####: 1929:    pStream->total_out += (mz_uint)out_bytes;
        -: 1930:
    #####: 1931:    if (status < 0)
        -: 1932:      return MZ_DATA_ERROR;
    #####: 1933:    else if (status != TINFL_STATUS_DONE) {
    %%%%%: 1933-block  0
    #####: 1934:      pState->m_last_status = TINFL_STATUS_FAILED;
    #####: 1935:      return MZ_BUF_ERROR;
    %%%%%: 1935-block  0
        -: 1936:    }
        -: 1937:    return MZ_STREAM_END;
        -: 1938:  }
        -: 1939:  // flush != MZ_FINISH then we must assume there's more input.
    #####: 1940:  if (flush != MZ_FINISH)
    %%%%%: 1940-block  0
    #####: 1941:    decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;
    %%%%%: 1941-block  0
        -: 1942:
    #####: 1943:  if (pState->m_dict_avail) {
    %%%%%: 1943-block  0
    #####: 1944:    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
    #####: 1945:    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
    %%%%%: 1945-block  0
    #####: 1946:    pStream->next_out += n;
    #####: 1947:    pStream->avail_out -= n;
    #####: 1948:    pStream->total_out += n;
    #####: 1949:    pState->m_dict_avail -= n;
    #####: 1950:    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
    #####: 1951:    return ((pState->m_last_status == TINFL_STATUS_DONE) &&
    %%%%%: 1951-block  0
        -: 1952:            (!pState->m_dict_avail))
    #####: 1953:               ? MZ_STREAM_END
    %%%%%: 1953-block  0
    #####: 1954:               : MZ_OK;
    %%%%%: 1954-block  0
        -: 1955:  }
        -: 1956:
    #####: 1957:  for (;;) {
    #####: 1958:    in_bytes = pStream->avail_in;
    #####: 1959:    out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;
        -: 1960:
    #####: 1961:    status = tinfl_decompress(
        -: 1962:        &pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict,
    #####: 1963:        pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
    %%%%%: 1963-block  0
    #####: 1964:    pState->m_last_status = status;
        -: 1965:
    #####: 1966:    pStream->next_in += (mz_uint)in_bytes;
    #####: 1967:    pStream->avail_in -= (mz_uint)in_bytes;
    #####: 1968:    pStream->total_in += (mz_uint)in_bytes;
    #####: 1969:    pStream->adler = tinfl_get_adler32(&pState->m_decomp);
        -: 1970:
    #####: 1971:    pState->m_dict_avail = (mz_uint)out_bytes;
        -: 1972:
    #####: 1973:    n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
    #####: 1974:    memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
    #####: 1975:    pStream->next_out += n;
    #####: 1976:    pStream->avail_out -= n;
    #####: 1977:    pStream->total_out += n;
    #####: 1978:    pState->m_dict_avail -= n;
    #####: 1979:    pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
        -: 1980:
    #####: 1981:    if (status < 0)
        -: 1982:      return MZ_DATA_ERROR; // Stream is corrupted (there could be some
        -: 1983:                            // uncompressed data left in the output dictionary -
        -: 1984:                            // oh well).
    #####: 1985:    else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
    %%%%%: 1985-block  0
        -: 1986:      return MZ_BUF_ERROR; // Signal caller that we can't make forward progress
        -: 1987:                           // without supplying more input or by setting flush
        -: 1988:                           // to MZ_FINISH.
    #####: 1989:    else if (flush == MZ_FINISH) {
    %%%%%: 1989-block  0
        -: 1990:      // The output buffer MUST be large to hold the remaining uncompressed data
        -: 1991:      // when flush==MZ_FINISH.
    #####: 1992:      if (status == TINFL_STATUS_DONE)
    %%%%%: 1992-block  0
    #####: 1993:        return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
    %%%%%: 1993-block  0
    %%%%%: 1993-block  1
        -: 1994:      // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's
        -: 1995:      // at least 1 more byte on the way. If there's no more room left in the
        -: 1996:      // output buffer then something is wrong.
    #####: 1997:      else if (!pStream->avail_out)
    %%%%%: 1997-block  0
        -: 1998:        return MZ_BUF_ERROR;
    #####: 1999:    } else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) ||
    %%%%%: 1999-block  0
    %%%%%: 1999-block  1
    #####: 2000:               (!pStream->avail_out) || (pState->m_dict_avail))
    %%%%%: 2000-block  0
    %%%%%: 2000-block  1
        -: 2001:      break;
        -: 2002:  }
        -: 2003:
    #####: 2004:  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail))
    %%%%%: 2004-block  0
    #####: 2005:             ? MZ_STREAM_END
    %%%%%: 2005-block  0
        -: 2006:             : MZ_OK;
        -: 2007:}
        -: 2008:
    #####: 2009:inline int mz_inflateEnd(mz_streamp pStream) {
    #####: 2010:  if (!pStream)
        -: 2011:    return MZ_STREAM_ERROR;
    #####: 2012:  if (pStream->state) {
    #####: 2013:    pStream->zfree(pStream->opaque, pStream->state);
    %%%%%: 2013-block  0
    %%%%%: 2013-block  1
        -: 2014:    pStream->state = NULL;
        -: 2015:  }
        -: 2016:  return MZ_OK;
        -: 2017:}
        -: 2018:
    #####: 2019:inline int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,
        -: 2020:                  const unsigned char *pSource, mz_ulong source_len) {
    #####: 2021:  mz_stream stream;
    #####: 2022:  int status;
    #####: 2023:  memset(&stream, 0, sizeof(stream));
    %%%%%: 2023-block  0
        -: 2024:
        -: 2025:  // In case mz_ulong is 64-bits (argh I hate longs).
    #####: 2026:  if ((source_len | *pDest_len) > 0xFFFFFFFFU)
    %%%%%: 2026-block  0
        -: 2027:    return MZ_PARAM_ERROR;
        -: 2028:
    #####: 2029:  stream.next_in = pSource;
    #####: 2030:  stream.avail_in = (mz_uint32)source_len;
    #####: 2031:  stream.next_out = pDest;
    #####: 2032:  stream.avail_out = (mz_uint32)*pDest_len;
        -: 2033:
    #####: 2034:  status = mz_inflateInit(&stream);
    %%%%%: 2034-block  0
    #####: 2035:  if (status != MZ_OK)
        -: 2036:    return status;
        -: 2037:
    #####: 2038:  status = mz_inflate(&stream, MZ_FINISH);
    %%%%%: 2038-block  0
    #####: 2039:  if (status != MZ_STREAM_END) {
    #####: 2040:    mz_inflateEnd(&stream);
    %%%%%: 2040-block  0
    #####: 2041:    return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR
    %%%%%: 2041-block  0
    %%%%%: 2041-block  1
    #####: 2042:                                                            : status;
    %%%%%: 2042-block  0
        -: 2043:  }
    #####: 2044:  *pDest_len = stream.total_out;
        -: 2045:
    #####: 2046:  return mz_inflateEnd(&stream);
    %%%%%: 2046-block  0
        -: 2047:}
        -: 2048:
        -: 2049:inline const char *mz_error(int err) {
        -: 2050:  static struct {
        -: 2051:    int m_err;
        -: 2052:    const char *m_pDesc;
        -: 2053:  } s_error_descs[] = {{MZ_OK, ""},
        -: 2054:                       {MZ_STREAM_END, "stream end"},
        -: 2055:                       {MZ_NEED_DICT, "need dictionary"},
        -: 2056:                       {MZ_ERRNO, "file error"},
        -: 2057:                       {MZ_STREAM_ERROR, "stream error"},
        -: 2058:                       {MZ_DATA_ERROR, "data error"},
        -: 2059:                       {MZ_MEM_ERROR, "out of memory"},
        -: 2060:                       {MZ_BUF_ERROR, "buf error"},
        -: 2061:                       {MZ_VERSION_ERROR, "version error"},
        -: 2062:                       {MZ_PARAM_ERROR, "parameter error"}};
        -: 2063:  mz_uint i;
        -: 2064:  for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
        -: 2065:    if (s_error_descs[i].m_err == err)
        -: 2066:      return s_error_descs[i].m_pDesc;
        -: 2067:  return NULL;
        -: 2068:}
        -: 2069:
        -: 2070:#endif // MINIZ_NO_ZLIB_APIS
        -: 2071:
        -: 2072:// ------------------- Low-level Decompression (completely independent from all
        -: 2073:// compression API's)
        -: 2074:
        -: 2075:#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
        -: 2076:#define TINFL_MEMSET(p, c, l) memset(p, c, l)
        -: 2077:
        -: 2078:#define TINFL_CR_BEGIN                                                         \
        -: 2079:  switch (r->m_state) {                                                        \
        -: 2080:  case 0:
        -: 2081:#define TINFL_CR_RETURN(state_index, result)                                   \
        -: 2082:  do {                                                                         \
        -: 2083:    status = result;                                                           \
        -: 2084:    r->m_state = state_index;                                                  \
        -: 2085:    goto common_exit;                                                          \
        -: 2086:  case state_index:                                                            \
        -: 2087:    ;                                                                          \
        -: 2088:  }                                                                            \
        -: 2089:  MZ_MACRO_END
        -: 2090:#define TINFL_CR_RETURN_FOREVER(state_index, result)                           \
        -: 2091:  do {                                                                         \
        -: 2092:    for (;;) {                                                                 \
        -: 2093:      TINFL_CR_RETURN(state_index, result);                                    \
        -: 2094:    }                                                                          \
        -: 2095:  }                                                                            \
        -: 2096:  MZ_MACRO_END
        -: 2097:#define TINFL_CR_FINISH }
        -: 2098:
        -: 2099:// TODO: If the caller has indicated that there's no more input, and we attempt
        -: 2100:// to read beyond the input buf, then something is wrong with the input because
        -: 2101:// the inflator never
        -: 2102:// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of
        -: 2103:// the stream with 0's in this scenario.
        -: 2104:#define TINFL_GET_BYTE(state_index, c)                                         \
        -: 2105:  do {                                                                         \
        -: 2106:    if (pIn_buf_cur >= pIn_buf_end) {                                          \
        -: 2107:      for (;;) {                                                               \
        -: 2108:        if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {                        \
        -: 2109:          TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT);         \
        -: 2110:          if (pIn_buf_cur < pIn_buf_end) {                                     \
        -: 2111:            c = *pIn_buf_cur++;                                                \
        -: 2112:            break;                                                             \
        -: 2113:          }                                                                    \
        -: 2114:        } else {                                                               \
        -: 2115:          c = 0;                                                               \
        -: 2116:          break;                                                               \
        -: 2117:        }                                                                      \
        -: 2118:      }                                                                        \
        -: 2119:    } else                                                                     \
        -: 2120:      c = *pIn_buf_cur++;                                                      \
        -: 2121:  }                                                                            \
        -: 2122:  MZ_MACRO_END
        -: 2123:
        -: 2124:#define TINFL_NEED_BITS(state_index, n)                                        \
        -: 2125:  do {                                                                         \
        -: 2126:    mz_uint c;                                                                 \
        -: 2127:    TINFL_GET_BYTE(state_index, c);                                            \
        -: 2128:    bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                             \
        -: 2129:    num_bits += 8;                                                             \
        -: 2130:  } while (num_bits < (mz_uint)(n))
        -: 2131:#define TINFL_SKIP_BITS(state_index, n)                                        \
        -: 2132:  do {                                                                         \
        -: 2133:    if (num_bits < (mz_uint)(n)) {                                             \
        -: 2134:      TINFL_NEED_BITS(state_index, n);                                         \
        -: 2135:    }                                                                          \
        -: 2136:    bit_buf >>= (n);                                                           \
        -: 2137:    num_bits -= (n);                                                           \
        -: 2138:  }                                                                            \
        -: 2139:  MZ_MACRO_END
        -: 2140:#define TINFL_GET_BITS(state_index, b, n)                                      \
        -: 2141:  do {                                                                         \
        -: 2142:    if (num_bits < (mz_uint)(n)) {                                             \
        -: 2143:      TINFL_NEED_BITS(state_index, n);                                         \
        -: 2144:    }                                                                          \
        -: 2145:    b = bit_buf & ((1 << (n)) - 1);                                            \
        -: 2146:    bit_buf >>= (n);                                                           \
        -: 2147:    num_bits -= (n);                                                           \
        -: 2148:  }                                                                            \
        -: 2149:  MZ_MACRO_END
        -: 2150:
        -: 2151:// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes
        -: 2152:// remaining in the input buffer falls below 2.
        -: 2153:// It reads just enough bytes from the input stream that are needed to decode
        -: 2154:// the next Huffman code (and absolutely no more). It works by trying to fully
        -: 2155:// decode a
        -: 2156:// Huffman code by using whatever bits are currently present in the bit buffer.
        -: 2157:// If this fails, it reads another byte, and tries again until it succeeds or
        -: 2158:// until the
        -: 2159:// bit buffer contains >=15 bits (deflate's max. Huffman code size).
        -: 2160:#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff)                             \
        -: 2161:  do {                                                                         \
        -: 2162:    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];         \
        -: 2163:    if (temp >= 0) {                                                           \
        -: 2164:      code_len = temp >> 9;                                                    \
        -: 2165:      if ((code_len) && (num_bits >= code_len))                                \
        -: 2166:        break;                                                                 \
        -: 2167:    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) {                            \
        -: 2168:      code_len = TINFL_FAST_LOOKUP_BITS;                                       \
        -: 2169:      do {                                                                     \
        -: 2170:        temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];         \
        -: 2171:      } while ((temp < 0) && (num_bits >= (code_len + 1)));                    \
        -: 2172:      if (temp >= 0)                                                           \
        -: 2173:        break;                                                                 \
        -: 2174:    }                                                                          \
        -: 2175:    TINFL_GET_BYTE(state_index, c);                                            \
        -: 2176:    bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                             \
        -: 2177:    num_bits += 8;                                                             \
        -: 2178:  } while (num_bits < 15);
        -: 2179:
        -: 2180:// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex
        -: 2181:// than you would initially expect because the zlib API expects the decompressor
        -: 2182:// to never read
        -: 2183:// beyond the final byte of the deflate stream. (In other words, when this macro
        -: 2184:// wants to read another byte from the input, it REALLY needs another byte in
        -: 2185:// order to fully
        -: 2186:// decode the next Huffman code.) Handling this properly is particularly
        -: 2187:// important on raw deflate (non-zlib) streams, which aren't followed by a byte
        -: 2188:// aligned adler-32.
        -: 2189:// The slow path is only executed at the very end of the input buffer.
        -: 2190:#define TINFL_HUFF_DECODE(state_index, sym, pHuff)                             \
        -: 2191:  do {                                                                         \
        -: 2192:    int temp;                                                                  \
        -: 2193:    mz_uint code_len, c;                                                       \
        -: 2194:    if (num_bits < 15) {                                                       \
        -: 2195:      if ((pIn_buf_end - pIn_buf_cur) < 2) {                                   \
        -: 2196:        TINFL_HUFF_BITBUF_FILL(state_index, pHuff);                            \
        -: 2197:      } else {                                                                 \
        -: 2198:        bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) |           \
        -: 2199:                   (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8));      \
        -: 2200:        pIn_buf_cur += 2;                                                      \
        -: 2201:        num_bits += 16;                                                        \
        -: 2202:      }                                                                        \
        -: 2203:    }                                                                          \
        -: 2204:    if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= \
        -: 2205:        0)                                                                     \
        -: 2206:      code_len = temp >> 9, temp &= 511;                                       \
        -: 2207:    else {                                                                     \
        -: 2208:      code_len = TINFL_FAST_LOOKUP_BITS;                                       \
        -: 2209:      do {                                                                     \
        -: 2210:        temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];         \
        -: 2211:      } while (temp < 0);                                                      \
        -: 2212:    }                                                                          \
        -: 2213:    sym = temp;                                                                \
        -: 2214:    bit_buf >>= code_len;                                                      \
        -: 2215:    num_bits -= code_len;                                                      \
        -: 2216:  }                                                                            \
        -: 2217:  MZ_MACRO_END
        -: 2218:
    #####: 2219:inline tinfl_status tinfl_decompress(tinfl_decompressor *r,
        -: 2220:                              const mz_uint8 *pIn_buf_next,
        -: 2221:                              size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,
        -: 2222:                              mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
        -: 2223:                              const mz_uint32 decomp_flags) {
    #####: 2224:  static const int s_length_base[31] = {
        -: 2225:      3,  4,  5,  6,  7,  8,  9,  10,  11,  13,  15,  17,  19,  23, 27, 31,
        -: 2226:      35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0,  0};
    #####: 2227:  static const int s_length_extra[31] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
        -: 2228:                                         1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,
        -: 2229:                                         4, 4, 5, 5, 5, 5, 0, 0, 0};
    #####: 2230:  static const int s_dist_base[32] = {
        -: 2231:      1,    2,    3,    4,    5,    7,     9,     13,    17,  25,   33,
        -: 2232:      49,   65,   97,   129,  193,  257,   385,   513,   769, 1025, 1537,
        -: 2233:      2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0,   0};
    #####: 2234:  static const int s_dist_extra[32] = {0, 0, 0,  0,  1,  1,  2,  2,  3,  3,
        -: 2235:                                       4, 4, 5,  5,  6,  6,  7,  7,  8,  8,
        -: 2236:                                       9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
    #####: 2237:  static const mz_uint8 s_length_dezigzag[19] = {
        -: 2238:      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
    #####: 2239:  static const int s_min_table_sizes[3] = {257, 1, 4};
        -: 2240:
    #####: 2241:  tinfl_status status = TINFL_STATUS_FAILED;
    #####: 2242:  mz_uint32 num_bits, dist, counter, num_extra;
    #####: 2243:  tinfl_bit_buf_t bit_buf;
    #####: 2244:  const mz_uint8 *pIn_buf_cur = pIn_buf_next,
    #####: 2245:                 *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
    #####: 2246:  mz_uint8 *pOut_buf_cur = pOut_buf_next,
    #####: 2247:           *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
    #####: 2248:  size_t out_buf_size_mask =
    #####: 2249:             (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)
    #####: 2250:                 ? (size_t)-1
    %%%%%: 2250-block  0
    #####: 2251:                 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1,
    %%%%%: 2251-block  0
        -: 2252:         dist_from_out_buf_start;
        -: 2253:
        -: 2254:  // Ensure the output buffer's size is a power of 2, unless the output buffer
        -: 2255:  // is large enough to hold the entire output file (in which case it doesn't
        -: 2256:  // matter).
    #####: 2257:  if (((out_buf_size_mask + 1) & out_buf_size_mask) ||
    %%%%%: 2257-block  0
    %%%%%: 2257-block  1
        -: 2258:      (pOut_buf_next < pOut_buf_start)) {
    #####: 2259:    *pIn_buf_size = *pOut_buf_size = 0;
    #####: 2260:    return TINFL_STATUS_BAD_PARAM;
    %%%%%: 2260-block  0
        -: 2261:  }
        -: 2262:
    #####: 2263:  num_bits = r->m_num_bits;
    #####: 2264:  bit_buf = r->m_bit_buf;
    #####: 2265:  dist = r->m_dist;
    #####: 2266:  counter = r->m_counter;
    #####: 2267:  num_extra = r->m_num_extra;
    #####: 2268:  dist_from_out_buf_start = r->m_dist_from_out_buf_start;
    #####: 2269:  TINFL_CR_BEGIN
    %%%%%: 2269-block  0
        -: 2270:
    #####: 2271:  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
    #####: 2272:  r->m_z_adler32 = r->m_check_adler32 = 1;
    #####: 2273:  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
    %%%%%: 2273-block  0
    #####: 2274:    TINFL_GET_BYTE(1, r->m_zhdr0);
    %%%%%: 2274-block  0
    %%%%%: 2274-block  1
    %%%%%: 2274-block  2
    %%%%%: 2274-block  3
    %%%%%: 2274-block  4
    %%%%%: 2274-block  5
    %%%%%: 2274-block  6
    #####: 2275:    TINFL_GET_BYTE(2, r->m_zhdr1);
    %%%%%: 2275-block  0
    %%%%%: 2275-block  1
    %%%%%: 2275-block  2
    %%%%%: 2275-block  3
    %%%%%: 2275-block  4
    %%%%%: 2275-block  5
    %%%%%: 2275-block  6
    #####: 2276:    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) ||
    #####: 2277:               (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
    %%%%%: 2277-block  0
    %%%%%: 2277-block  1
    #####: 2278:    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
    %%%%%: 2278-block  0
    #####: 2279:      counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) ||
    %%%%%: 2279-block  0
    %%%%%: 2279-block  1
    #####: 2280:                  ((out_buf_size_mask + 1) <
    %%%%%: 2280-block  0
        -: 2281:                   (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
    #####: 2282:    if (counter) {
    %%%%%: 2282-block  0
    #####: 2283:      TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
    %%%%%: 2283-block  0
        -: 2284:    }
        -: 2285:  }
        -: 2286:
    #####: 2287:  do {
    #####: 2288:    TINFL_GET_BITS(3, r->m_final, 3);
    %%%%%: 2288-block  0
    %%%%%: 2288-block  1
    %%%%%: 2288-block  2
    %%%%%: 2288-block  3
    %%%%%: 2288-block  4
    %%%%%: 2288-block  5
    %%%%%: 2288-block  6
    %%%%%: 2288-block  7
    #####: 2289:    r->m_type = r->m_final >> 1;
    #####: 2290:    if (r->m_type == 0) {
    %%%%%: 2290-block  0
    #####: 2291:      TINFL_SKIP_BITS(5, num_bits & 7);
    %%%%%: 2291-block  0
    %%%%%: 2291-block  1
    %%%%%: 2291-block  2
    %%%%%: 2291-block  3
    %%%%%: 2291-block  4
    %%%%%: 2291-block  5
    %%%%%: 2291-block  6
    %%%%%: 2291-block  7
    #####: 2292:      for (counter = 0; counter < 4; ++counter) {
    %%%%%: 2292-block  0
    %%%%%: 2292-block  1
    %%%%%: 2292-block  2
    #####: 2293:        if (num_bits)
    %%%%%: 2293-block  0
    #####: 2294:          TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
    %%%%%: 2294-block  0
    %%%%%: 2294-block  1
    %%%%%: 2294-block  2
    %%%%%: 2294-block  3
    %%%%%: 2294-block  4
    %%%%%: 2294-block  5
    %%%%%: 2294-block  6
    %%%%%: 2294-block  7
    %%%%%: 2294-block  8
        -: 2295:        else
    #####: 2296:          TINFL_GET_BYTE(7, r->m_raw_header[counter]);
    %%%%%: 2296-block  0
    %%%%%: 2296-block  1
    %%%%%: 2296-block  2
    %%%%%: 2296-block  3
    %%%%%: 2296-block  4
    %%%%%: 2296-block  5
    %%%%%: 2296-block  6
        -: 2297:      }
    #####: 2298:      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) !=
    #####: 2299:          (mz_uint)(0xFFFF ^
    #####: 2300:                    (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) {
    %%%%%: 2300-block  0
    #####: 2301:        TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
    %%%%%: 2301-block  0
        -: 2302:      }
    #####: 2303:      while ((counter) && (num_bits)) {
    %%%%%: 2303-block  0
    #####: 2304:        TINFL_GET_BITS(51, dist, 8);
    %%%%%: 2304-block  0
    %%%%%: 2304-block  1
    %%%%%: 2304-block  2
    %%%%%: 2304-block  3
    %%%%%: 2304-block  4
    %%%%%: 2304-block  5
    %%%%%: 2304-block  6
    %%%%%: 2304-block  7
    %%%%%: 2304-block  8
    #####: 2305:        while (pOut_buf_cur >= pOut_buf_end) {
    %%%%%: 2305-block  0
    #####: 2306:          TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
    %%%%%: 2306-block  0
        -: 2307:        }
    #####: 2308:        *pOut_buf_cur++ = (mz_uint8)dist;
    #####: 2309:        counter--;
    %%%%%: 2309-block  0
        -: 2310:      }
    #####: 2311:      while (counter) {
    %%%%%: 2311-block  0
    #####: 2312:        size_t n;
    #####: 2313:        while (pOut_buf_cur >= pOut_buf_end) {
    %%%%%: 2313-block  0
    #####: 2314:          TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
    %%%%%: 2314-block  0
        -: 2315:        }
    #####: 2316:        while (pIn_buf_cur >= pIn_buf_end) {
    %%%%%: 2316-block  0
    #####: 2317:          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {
    %%%%%: 2317-block  0
    #####: 2318:            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);
    %%%%%: 2318-block  0
        -: 2319:          } else {
    #####: 2320:            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);
    %%%%%: 2320-block  0
        -: 2321:          }
        -: 2322:        }
    #####: 2323:        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur),
        -: 2324:                          (size_t)(pIn_buf_end - pIn_buf_cur)),
        -: 2325:                   counter);
    #####: 2326:        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
    %%%%%: 2326-block  0
    #####: 2327:        pIn_buf_cur += n;
    #####: 2328:        pOut_buf_cur += n;
    #####: 2329:        counter -= (mz_uint)n;
    %%%%%: 2329-block  0
        -: 2330:      }
    #####: 2331:    } else if (r->m_type == 3) {
    %%%%%: 2331-block  0
    #####: 2332:      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
    %%%%%: 2332-block  0
        -: 2333:    } else {
    #####: 2334:      if (r->m_type == 1) {
    %%%%%: 2334-block  0
    #####: 2335:        mz_uint8 *p = r->m_tables[0].m_code_size;
    #####: 2336:        mz_uint i;
    #####: 2337:        r->m_table_sizes[0] = 288;
    #####: 2338:        r->m_table_sizes[1] = 32;
    #####: 2339:        TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);
    %%%%%: 2339-block  0
    #####: 2340:        for (i = 0; i <= 143; ++i)
    %%%%%: 2340-block  0
    %%%%%: 2340-block  1
    #####: 2341:          *p++ = 8;
    %%%%%: 2341-block  0
    #####: 2342:        for (; i <= 255; ++i)
    %%%%%: 2342-block  0
    #####: 2343:          *p++ = 9;
    %%%%%: 2343-block  0
    #####: 2344:        for (; i <= 279; ++i)
    %%%%%: 2344-block  0
    #####: 2345:          *p++ = 7;
    %%%%%: 2345-block  0
    #####: 2346:        for (; i <= 287; ++i)
    %%%%%: 2346-block  0
    #####: 2347:          *p++ = 8;
    %%%%%: 2347-block  0
        -: 2348:      } else {
    #####: 2349:        for (counter = 0; counter < 3; counter++) {
    %%%%%: 2349-block  0
    #####: 2350:          TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
    %%%%%: 2350-block  0
    %%%%%: 2350-block  1
    %%%%%: 2350-block  2
    %%%%%: 2350-block  3
    %%%%%: 2350-block  4
    %%%%%: 2350-block  5
    %%%%%: 2350-block  6
    %%%%%: 2350-block  7
    #####: 2351:          r->m_table_sizes[counter] += s_min_table_sizes[counter];
    %%%%%: 2351-block  0
        -: 2352:        }
    #####: 2353:        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size);
    %%%%%: 2353-block  0
    #####: 2354:        for (counter = 0; counter < r->m_table_sizes[2]; counter++) {
    %%%%%: 2354-block  0
    %%%%%: 2354-block  1
    #####: 2355:          mz_uint s;
    #####: 2356:          TINFL_GET_BITS(14, s, 3);
    %%%%%: 2356-block  0
    %%%%%: 2356-block  1
    %%%%%: 2356-block  2
    %%%%%: 2356-block  3
    %%%%%: 2356-block  4
    %%%%%: 2356-block  5
    %%%%%: 2356-block  6
    %%%%%: 2356-block  7
    #####: 2357:          r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s;
    %%%%%: 2357-block  0
        -: 2358:        }
    #####: 2359:        r->m_table_sizes[2] = 19;
    %%%%%: 2359-block  0
        -: 2360:      }
    #####: 2361:      for (; (int)r->m_type >= 0; r->m_type--) {
    %%%%%: 2361-block  0
    #####: 2362:        int tree_next, tree_cur;
    #####: 2363:        tinfl_huff_table *pTable;
    #####: 2364:        mz_uint i, j, used_syms, total, sym_index, next_code[17],
        -: 2365:            total_syms[16];
    #####: 2366:        pTable = &r->m_tables[r->m_type];
    #####: 2367:        MZ_CLEAR_OBJ(total_syms);
    %%%%%: 2367-block  0
    #####: 2368:        MZ_CLEAR_OBJ(pTable->m_look_up);
    #####: 2369:        MZ_CLEAR_OBJ(pTable->m_tree);
    #####: 2370:        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
    %%%%%: 2370-block  0
    %%%%%: 2370-block  1
    #####: 2371:          total_syms[pTable->m_code_size[i]]++;
    %%%%%: 2371-block  0
    #####: 2372:        used_syms = 0, total = 0;
    #####: 2373:        next_code[0] = next_code[1] = 0;
    #####: 2374:        for (i = 1; i <= 15; ++i) {
    %%%%%: 2374-block  0
    %%%%%: 2374-block  1
    #####: 2375:          used_syms += total_syms[i];
    #####: 2376:          next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
    %%%%%: 2376-block  0
        -: 2377:        }
    #####: 2378:        if ((65536 != total) && (used_syms > 1)) {
    %%%%%: 2378-block  0
    #####: 2379:          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
    %%%%%: 2379-block  0
    %%%%%: 2379-block  1
        -: 2380:        }
    #####: 2381:        for (tree_next = -1, sym_index = 0;
    %%%%%: 2381-block  0
    #####: 2382:             sym_index < r->m_table_sizes[r->m_type]; ++sym_index) {
    %%%%%: 2382-block  0
    #####: 2383:          mz_uint rev_code = 0, l, cur_code,
    #####: 2384:                  code_size = pTable->m_code_size[sym_index];
    #####: 2385:          if (!code_size)
    %%%%%: 2385-block  0
    #####: 2386:            continue;
    %%%%%: 2386-block  0
    #####: 2387:          cur_code = next_code[code_size]++;
    #####: 2388:          for (l = code_size; l > 0; l--, cur_code >>= 1)
    %%%%%: 2388-block  0
    %%%%%: 2388-block  1
    #####: 2389:            rev_code = (rev_code << 1) | (cur_code & 1);
    %%%%%: 2389-block  0
    #####: 2390:          if (code_size <= TINFL_FAST_LOOKUP_BITS) {
    %%%%%: 2390-block  0
    #####: 2391:            mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
    %%%%%: 2391-block  0
    #####: 2392:            while (rev_code < TINFL_FAST_LOOKUP_SIZE) {
    %%%%%: 2392-block  0
    #####: 2393:              pTable->m_look_up[rev_code] = k;
    #####: 2394:              rev_code += (1 << code_size);
    %%%%%: 2394-block  0
        -: 2395:            }
    #####: 2396:            continue;
    %%%%%: 2396-block  0
        -: 2397:          }
    #####: 2398:          if (0 ==
    #####: 2399:              (tree_cur = pTable->m_look_up[rev_code &
    #####: 2400:                                            (TINFL_FAST_LOOKUP_SIZE - 1)])) {
    %%%%%: 2400-block  0
    #####: 2401:            pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] =
        -: 2402:                (mz_int16)tree_next;
    #####: 2403:            tree_cur = tree_next;
    #####: 2404:            tree_next -= 2;
    %%%%%: 2404-block  0
        -: 2405:          }
    #####: 2406:          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
    #####: 2407:          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--) {
    %%%%%: 2407-block  0
    %%%%%: 2407-block  1
    %%%%%: 2407-block  2
    #####: 2408:            tree_cur -= ((rev_code >>= 1) & 1);
    #####: 2409:            if (!pTable->m_tree[-tree_cur - 1]) {
    %%%%%: 2409-block  0
    #####: 2410:              pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next;
    #####: 2411:              tree_cur = tree_next;
    #####: 2412:              tree_next -= 2;
    %%%%%: 2412-block  0
        -: 2413:            } else
    #####: 2414:              tree_cur = pTable->m_tree[-tree_cur - 1];
    %%%%%: 2414-block  0
        -: 2415:          }
    #####: 2416:          tree_cur -= ((rev_code >>= 1) & 1);
    #####: 2417:          pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;
    %%%%%: 2417-block  0
        -: 2418:        }
    #####: 2419:        if (r->m_type == 2) {
    %%%%%: 2419-block  0
        -: 2420:          for (counter = 0;
    #####: 2421:               counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);) {
    %%%%%: 2421-block  0
    #####: 2422:            mz_uint s;
    #####: 2423:            TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]);
    %%%%%: 2423-block  0
    %%%%%: 2423-block  1
    %%%%%: 2423-block  2
    %%%%%: 2423-block  3
    %%%%%: 2423-block  4
    %%%%%: 2423-block  5
    %%%%%: 2423-block  6
    %%%%%: 2423-block  7
    %%%%%: 2423-block  8
    %%%%%: 2423-block  9
    %%%%%: 2423-block 10
    %%%%%: 2423-block 11
    %%%%%: 2423-block 12
    %%%%%: 2423-block 13
    %%%%%: 2423-block 14
    %%%%%: 2423-block 15
    %%%%%: 2423-block 16
    %%%%%: 2423-block 17
    %%%%%: 2423-block 18
    #####: 2424:            if (dist < 16) {
    %%%%%: 2424-block  0
    #####: 2425:              r->m_len_codes[counter++] = (mz_uint8)dist;
    #####: 2426:              continue;
    %%%%%: 2426-block  0
        -: 2427:            }
    #####: 2428:            if ((dist == 16) && (!counter)) {
    %%%%%: 2428-block  0
    #####: 2429:              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
    %%%%%: 2429-block  0
        -: 2430:            }
    #####: 2431:            num_extra = "\02\03\07"[dist - 16];
    #####: 2432:            TINFL_GET_BITS(18, s, num_extra);
    %%%%%: 2432-block  0
    %%%%%: 2432-block  1
    %%%%%: 2432-block  2
    %%%%%: 2432-block  3
    %%%%%: 2432-block  4
    %%%%%: 2432-block  5
    %%%%%: 2432-block  6
    %%%%%: 2432-block  7
    #####: 2433:            s += "\03\03\013"[dist - 16];
    #####: 2434:            TINFL_MEMSET(r->m_len_codes + counter,
    %%%%%: 2434-block  0
    %%%%%: 2434-block  1
    %%%%%: 2434-block  2
        -: 2435:                         (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
    #####: 2436:            counter += s;
    %%%%%: 2436-block  0
        -: 2437:          }
    #####: 2438:          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter) {
    %%%%%: 2438-block  0
    #####: 2439:            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
    %%%%%: 2439-block  0
        -: 2440:          }
    #####: 2441:          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes,
    %%%%%: 2441-block  0
        -: 2442:                       r->m_table_sizes[0]);
    #####: 2443:          TINFL_MEMCPY(r->m_tables[1].m_code_size,
    %%%%%: 2443-block  0
    %%%%%: 2443-block  1
        -: 2444:                       r->m_len_codes + r->m_table_sizes[0],
        -: 2445:                       r->m_table_sizes[1]);
        -: 2446:        }
        -: 2447:      }
    #####: 2448:      for (;;) {
    #####: 2449:        mz_uint8 *pSrc;
    #####: 2450:        for (;;) {
    #####: 2451:          if (((pIn_buf_end - pIn_buf_cur) < 4) ||
    %%%%%: 2451-block  0
    #####: 2452:              ((pOut_buf_end - pOut_buf_cur) < 2)) {
    %%%%%: 2452-block  0
    #####: 2453:            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);
    %%%%%: 2453-block  0
    %%%%%: 2453-block  1
    %%%%%: 2453-block  2
    %%%%%: 2453-block  3
    %%%%%: 2453-block  4
    %%%%%: 2453-block  5
    %%%%%: 2453-block  6
    %%%%%: 2453-block  7
    %%%%%: 2453-block  8
    %%%%%: 2453-block  9
    %%%%%: 2453-block 10
    %%%%%: 2453-block 11
    %%%%%: 2453-block 12
    %%%%%: 2453-block 13
    %%%%%: 2453-block 14
    %%%%%: 2453-block 15
    %%%%%: 2453-block 16
    %%%%%: 2453-block 17
    %%%%%: 2453-block 18
    #####: 2454:            if (counter >= 256)
    %%%%%: 2454-block  0
        -: 2455:              break;
    #####: 2456:            while (pOut_buf_cur >= pOut_buf_end) {
    %%%%%: 2456-block  0
    #####: 2457:              TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
    %%%%%: 2457-block  0
        -: 2458:            }
    #####: 2459:            *pOut_buf_cur++ = (mz_uint8)counter;
    %%%%%: 2459-block  0
        -: 2460:          } else {
    #####: 2461:            int sym2;
    #####: 2462:            mz_uint code_len;
        -: 2463:#if TINFL_USE_64BIT_BITBUF
    #####: 2464:            if (num_bits < 30) {
    %%%%%: 2464-block  0
    #####: 2465:              bit_buf |=
    #####: 2466:                  (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
    #####: 2467:              pIn_buf_cur += 4;
    #####: 2468:              num_bits += 32;
    %%%%%: 2468-block  0
        -: 2469:            }
        -: 2470:#else
        -: 2471:            if (num_bits < 15) {
        -: 2472:              bit_buf |=
        -: 2473:                  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
        -: 2474:              pIn_buf_cur += 2;
        -: 2475:              num_bits += 16;
        -: 2476:            }
        -: 2477:#endif
    #####: 2478:            if ((sym2 =
        -: 2479:                     r->m_tables[0]
    #####: 2480:                         .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=
    %%%%%: 2480-block  0
        -: 2481:                0)
    #####: 2482:              code_len = sym2 >> 9;
    %%%%%: 2482-block  0
        -: 2483:            else {
        -: 2484:              code_len = TINFL_FAST_LOOKUP_BITS;
    #####: 2485:              do {
    #####: 2486:                sym2 = r->m_tables[0]
    #####: 2487:                           .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
    #####: 2488:              } while (sym2 < 0);
    %%%%%: 2488-block  0
        -: 2489:            }
    #####: 2490:            counter = sym2;
    #####: 2491:            bit_buf >>= code_len;
    #####: 2492:            num_bits -= code_len;
    #####: 2493:            if (counter & 256)
    %%%%%: 2493-block  0
        -: 2494:              break;
        -: 2495:
        -: 2496:#if !TINFL_USE_64BIT_BITBUF
        -: 2497:            if (num_bits < 15) {
        -: 2498:              bit_buf |=
        -: 2499:                  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
        -: 2500:              pIn_buf_cur += 2;
        -: 2501:              num_bits += 16;
        -: 2502:            }
        -: 2503:#endif
    #####: 2504:            if ((sym2 =
        -: 2505:                     r->m_tables[0]
    #####: 2506:                         .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=
    %%%%%: 2506-block  0
        -: 2507:                0)
    #####: 2508:              code_len = sym2 >> 9;
    %%%%%: 2508-block  0
        -: 2509:            else {
        -: 2510:              code_len = TINFL_FAST_LOOKUP_BITS;
    #####: 2511:              do {
    #####: 2512:                sym2 = r->m_tables[0]
    #####: 2513:                           .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
    #####: 2514:              } while (sym2 < 0);
    %%%%%: 2514-block  0
        -: 2515:            }
    #####: 2516:            bit_buf >>= code_len;
    #####: 2517:            num_bits -= code_len;
        -: 2518:
    #####: 2519:            pOut_buf_cur[0] = (mz_uint8)counter;
    #####: 2520:            if (sym2 & 256) {
    %%%%%: 2520-block  0
    #####: 2521:              pOut_buf_cur++;
    #####: 2522:              counter = sym2;
    #####: 2523:              break;
    %%%%%: 2523-block  0
        -: 2524:            }
    #####: 2525:            pOut_buf_cur[1] = (mz_uint8)sym2;
    #####: 2526:            pOut_buf_cur += 2;
    %%%%%: 2526-block  0
        -: 2527:          }
        -: 2528:        }
    #####: 2529:        if ((counter &= 511) == 256)
    %%%%%: 2529-block  0
        -: 2530:          break;
        -: 2531:
    #####: 2532:        num_extra = s_length_extra[counter - 257];
    #####: 2533:        counter = s_length_base[counter - 257];
    #####: 2534:        if (num_extra) {
    %%%%%: 2534-block  0
    #####: 2535:          mz_uint extra_bits;
    #####: 2536:          TINFL_GET_BITS(25, extra_bits, num_extra);
    %%%%%: 2536-block  0
    %%%%%: 2536-block  1
    %%%%%: 2536-block  2
    %%%%%: 2536-block  3
    %%%%%: 2536-block  4
    %%%%%: 2536-block  5
    %%%%%: 2536-block  6
    %%%%%: 2536-block  7
    #####: 2537:          counter += extra_bits;
    %%%%%: 2537-block  0
        -: 2538:        }
        -: 2539:
    #####: 2540:        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);
    %%%%%: 2540-block  0
    %%%%%: 2540-block  1
    %%%%%: 2540-block  2
    %%%%%: 2540-block  3
    %%%%%: 2540-block  4
    %%%%%: 2540-block  5
    %%%%%: 2540-block  6
    %%%%%: 2540-block  7
    %%%%%: 2540-block  8
    %%%%%: 2540-block  9
    %%%%%: 2540-block 10
    %%%%%: 2540-block 11
    %%%%%: 2540-block 12
    %%%%%: 2540-block 13
    %%%%%: 2540-block 14
    %%%%%: 2540-block 15
    %%%%%: 2540-block 16
    %%%%%: 2540-block 17
    %%%%%: 2540-block 18
    #####: 2541:        num_extra = s_dist_extra[dist];
    #####: 2542:        dist = s_dist_base[dist];
    #####: 2543:        if (num_extra) {
    %%%%%: 2543-block  0
    #####: 2544:          mz_uint extra_bits;
    #####: 2545:          TINFL_GET_BITS(27, extra_bits, num_extra);
    %%%%%: 2545-block  0
    %%%%%: 2545-block  1
    %%%%%: 2545-block  2
    %%%%%: 2545-block  3
    %%%%%: 2545-block  4
    %%%%%: 2545-block  5
    %%%%%: 2545-block  6
    %%%%%: 2545-block  7
    #####: 2546:          dist += extra_bits;
    %%%%%: 2546-block  0
        -: 2547:        }
        -: 2548:
    #####: 2549:        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
    #####: 2550:        if ((dist > dist_from_out_buf_start) &&
    %%%%%: 2550-block  0
    %%%%%: 2550-block  1
        -: 2551:            (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {
    #####: 2552:          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
    %%%%%: 2552-block  0
        -: 2553:        }
        -: 2554:
    #####: 2555:        pSrc = pOut_buf_start +
    #####: 2556:               ((dist_from_out_buf_start - dist) & out_buf_size_mask);
        -: 2557:
    #####: 2558:        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end) {
    %%%%%: 2558-block  0
    #####: 2559:          while (counter--) {
    %%%%%: 2559-block  0
    #####: 2560:            while (pOut_buf_cur >= pOut_buf_end) {
    %%%%%: 2560-block  0
    #####: 2561:              TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
    %%%%%: 2561-block  0
        -: 2562:            }
    #####: 2563:            *pOut_buf_cur++ =
    #####: 2564:                pOut_buf_start[(dist_from_out_buf_start++ - dist) &
    #####: 2565:                               out_buf_size_mask];
    %%%%%: 2565-block  0
        -: 2566:          }
    #####: 2567:          continue;
    %%%%%: 2567-block  0
        -: 2568:        }
        -: 2569:#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
        -: 2570:        else if ((counter >= 9) && (counter <= dist)) {
        -: 2571:          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
        -: 2572:          do {
        -: 2573:            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
        -: 2574:            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
        -: 2575:            pOut_buf_cur += 8;
        -: 2576:          } while ((pSrc += 8) < pSrc_end);
        -: 2577:          if ((counter &= 7) < 3) {
        -: 2578:            if (counter) {
        -: 2579:              pOut_buf_cur[0] = pSrc[0];
        -: 2580:              if (counter > 1)
        -: 2581:                pOut_buf_cur[1] = pSrc[1];
        -: 2582:              pOut_buf_cur += counter;
        -: 2583:            }
        -: 2584:            continue;
        -: 2585:          }
        -: 2586:        }
        -: 2587:#endif
    #####: 2588:        do {
    #####: 2589:          pOut_buf_cur[0] = pSrc[0];
    #####: 2590:          pOut_buf_cur[1] = pSrc[1];
    #####: 2591:          pOut_buf_cur[2] = pSrc[2];
    #####: 2592:          pOut_buf_cur += 3;
    #####: 2593:          pSrc += 3;
    #####: 2594:        } while ((int)(counter -= 3) > 2);
    %%%%%: 2594-block  0
    #####: 2595:        if ((int)counter > 0) {
    %%%%%: 2595-block  0
    #####: 2596:          pOut_buf_cur[0] = pSrc[0];
    #####: 2597:          if ((int)counter > 1)
    %%%%%: 2597-block  0
    #####: 2598:            pOut_buf_cur[1] = pSrc[1];
    %%%%%: 2598-block  0
    #####: 2599:          pOut_buf_cur += counter;
    %%%%%: 2599-block  0
        -: 2600:        }
        -: 2601:      }
        -: 2602:    }
    #####: 2603:  } while (!(r->m_final & 1));
    %%%%%: 2603-block  0
    #####: 2604:  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
    %%%%%: 2604-block  0
    #####: 2605:    TINFL_SKIP_BITS(32, num_bits & 7);
    %%%%%: 2605-block  0
    %%%%%: 2605-block  1
    %%%%%: 2605-block  2
    %%%%%: 2605-block  3
    %%%%%: 2605-block  4
    %%%%%: 2605-block  5
    %%%%%: 2605-block  6
    %%%%%: 2605-block  7
    #####: 2606:    for (counter = 0; counter < 4; ++counter) {
    %%%%%: 2606-block  0
    %%%%%: 2606-block  1
    #####: 2607:      mz_uint s;
    #####: 2608:      if (num_bits)
    %%%%%: 2608-block  0
    #####: 2609:        TINFL_GET_BITS(41, s, 8);
    %%%%%: 2609-block  0
    %%%%%: 2609-block  1
    %%%%%: 2609-block  2
    %%%%%: 2609-block  3
    %%%%%: 2609-block  4
    %%%%%: 2609-block  5
    %%%%%: 2609-block  6
    %%%%%: 2609-block  7
    %%%%%: 2609-block  8
        -: 2610:      else
    #####: 2611:        TINFL_GET_BYTE(42, s);
    %%%%%: 2611-block  0
    %%%%%: 2611-block  1
    %%%%%: 2611-block  2
    %%%%%: 2611-block  3
    %%%%%: 2611-block  4
    %%%%%: 2611-block  5
    #####: 2612:      r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
    %%%%%: 2612-block  0
        -: 2613:    }
        -: 2614:  }
    #####: 2615:  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);
    %%%%%: 2615-block  0
        -: 2616:  TINFL_CR_FINISH
        -: 2617:
    #####: 2618:common_exit:
    #####: 2619:  r->m_num_bits = num_bits;
    #####: 2620:  r->m_bit_buf = bit_buf;
    #####: 2621:  r->m_dist = dist;
    #####: 2622:  r->m_counter = counter;
    #####: 2623:  r->m_num_extra = num_extra;
    #####: 2624:  r->m_dist_from_out_buf_start = dist_from_out_buf_start;
    #####: 2625:  *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
    #####: 2626:  *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
    #####: 2627:  if ((decomp_flags &
    %%%%%: 2627-block  0
    #####: 2628:       (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) &&
    %%%%%: 2628-block  0
        -: 2629:      (status >= 0)) {
    #####: 2630:    const mz_uint8 *ptr = pOut_buf_next;
    #####: 2631:    size_t buf_len = *pOut_buf_size;
    #####: 2632:    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff,
    #####: 2633:                 s2 = r->m_check_adler32 >> 16;
    #####: 2634:    size_t block_len = buf_len % 5552;
    %%%%%: 2634-block  0
    #####: 2635:    while (buf_len) {
    %%%%%: 2635-block  0
    #####: 2636:      for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
    %%%%%: 2636-block  0
    #####: 2637:        s1 += ptr[0], s2 += s1;
    #####: 2638:        s1 += ptr[1], s2 += s1;
    #####: 2639:        s1 += ptr[2], s2 += s1;
    #####: 2640:        s1 += ptr[3], s2 += s1;
    #####: 2641:        s1 += ptr[4], s2 += s1;
    #####: 2642:        s1 += ptr[5], s2 += s1;
    #####: 2643:        s1 += ptr[6], s2 += s1;
    #####: 2644:        s1 += ptr[7], s2 += s1;
    %%%%%: 2644-block  0
        -: 2645:      }
    #####: 2646:      for (; i < block_len; ++i)
    %%%%%: 2646-block  0
    #####: 2647:        s1 += *ptr++, s2 += s1;
    %%%%%: 2647-block  0
    #####: 2648:      s1 %= 65521U, s2 %= 65521U;
    #####: 2649:      buf_len -= block_len;
    #####: 2650:      block_len = 5552;
    %%%%%: 2650-block  0
        -: 2651:    }
    #####: 2652:    r->m_check_adler32 = (s2 << 16) + s1;
    #####: 2653:    if ((status == TINFL_STATUS_DONE) &&
    %%%%%: 2653-block  0
    #####: 2654:        (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) &&
    %%%%%: 2654-block  0
    #####: 2655:        (r->m_check_adler32 != r->m_z_adler32))
    %%%%%: 2655-block  0
    #####: 2656:      status = TINFL_STATUS_ADLER32_MISMATCH;
    %%%%%: 2656-block  0
        -: 2657:  }
        -: 2658:  return status;
        -: 2659:}
        -: 2660:
        -: 2661:// Higher level helper functions.
        -: 2662:inline void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
        -: 2663:                                   size_t *pOut_len, int flags) {
        -: 2664:  tinfl_decompressor decomp;
        -: 2665:  void *pBuf = NULL, *pNew_buf;
        -: 2666:  size_t src_buf_ofs = 0, out_buf_capacity = 0;
        -: 2667:  *pOut_len = 0;
        -: 2668:  tinfl_init(&decomp);
        -: 2669:  for (;;) {
        -: 2670:    size_t src_buf_size = src_buf_len - src_buf_ofs,
        -: 2671:           dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
        -: 2672:    tinfl_status status = tinfl_decompress(
        -: 2673:        &decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size,
        -: 2674:        (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL,
        -: 2675:        &dst_buf_size, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |
        -: 2676:                           TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
        -: 2677:    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT)) {
        -: 2678:      MZ_FREE(pBuf);
        -: 2679:      *pOut_len = 0;
        -: 2680:      return NULL;
        -: 2681:    }
        -: 2682:    src_buf_ofs += src_buf_size;
        -: 2683:    *pOut_len += dst_buf_size;
        -: 2684:    if (status == TINFL_STATUS_DONE)
        -: 2685:      break;
        -: 2686:    new_out_buf_capacity = out_buf_capacity * 2;
        -: 2687:    if (new_out_buf_capacity < 128)
        -: 2688:      new_out_buf_capacity = 128;
        -: 2689:    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
        -: 2690:    if (!pNew_buf) {
        -: 2691:      MZ_FREE(pBuf);
        -: 2692:      *pOut_len = 0;
        -: 2693:      return NULL;
        -: 2694:    }
        -: 2695:    pBuf = pNew_buf;
        -: 2696:    out_buf_capacity = new_out_buf_capacity;
        -: 2697:  }
        -: 2698:  return pBuf;
        -: 2699:}
        -: 2700:
        -: 2701:inline size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
        -: 2702:                                   const void *pSrc_buf, size_t src_buf_len,
        -: 2703:                                   int flags) {
        -: 2704:  tinfl_decompressor decomp;
        -: 2705:  tinfl_status status;
        -: 2706:  tinfl_init(&decomp);
        -: 2707:  status =
        -: 2708:      tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len,
        -: 2709:                       (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len,
        -: 2710:                       (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |
        -: 2711:                           TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
        -: 2712:  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED
        -: 2713:                                       : out_buf_len;
        -: 2714:}
        -: 2715:
        -: 2716:inline int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,
        -: 2717:                                     tinfl_put_buf_func_ptr pPut_buf_func,
        -: 2718:                                     void *pPut_buf_user, int flags) {
        -: 2719:  int result = 0;
        -: 2720:  tinfl_decompressor decomp;
        -: 2721:  mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
        -: 2722:  size_t in_buf_ofs = 0, dict_ofs = 0;
        -: 2723:  if (!pDict)
        -: 2724:    return TINFL_STATUS_FAILED;
        -: 2725:  tinfl_init(&decomp);
        -: 2726:  for (;;) {
        -: 2727:    size_t in_buf_size = *pIn_buf_size - in_buf_ofs,
        -: 2728:           dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
        -: 2729:    tinfl_status status =
        -: 2730:        tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs,
        -: 2731:                         &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
        -: 2732:                         (flags &
        -: 2733:                          ~(TINFL_FLAG_HAS_MORE_INPUT |
        -: 2734:                            TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
        -: 2735:    in_buf_ofs += in_buf_size;
        -: 2736:    if ((dst_buf_size) &&
        -: 2737:        (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
        -: 2738:      break;
        -: 2739:    if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {
        -: 2740:      result = (status == TINFL_STATUS_DONE);
        -: 2741:      break;
        -: 2742:    }
        -: 2743:    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
        -: 2744:  }
        -: 2745:  MZ_FREE(pDict);
        -: 2746:  *pIn_buf_size = in_buf_ofs;
        -: 2747:  return result;
        -: 2748:}
        -: 2749:
        -: 2750:// ------------------- Low-level Compression (independent from all decompression
        -: 2751:// API's)
        -: 2752:
        -: 2753:// Purposely making these tables static for faster init and thread safety.
        -: 2754:static const mz_uint16 s_tdefl_len_sym[256] = {
        -: 2755:    257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268,
        -: 2756:    268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272,
        -: 2757:    272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274,
        -: 2758:    274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276,
        -: 2759:    276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,
        -: 2760:    277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
        -: 2761:    278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279,
        -: 2762:    279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280,
        -: 2763:    280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281,
        -: 2764:    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
        -: 2765:    281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282,
        -: 2766:    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
        -: 2767:    282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283,
        -: 2768:    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
        -: 2769:    283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284,
        -: 2770:    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,
        -: 2771:    284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,
        -: 2772:    285};
        -: 2773:
        -: 2774:static const mz_uint8 s_tdefl_len_extra[256] = {
        -: 2775:    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
        -: 2776:    2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        -: 2777:    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
        -: 2778:    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        -: 2779:    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        -: 2780:    4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2781:    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2782:    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2783:    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2784:    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2785:    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0};
        -: 2786:
        -: 2787:static const mz_uint8 s_tdefl_small_dist_sym[512] = {
        -: 2788:    0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,
        -: 2789:    8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10,
        -: 2790:    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,
        -: 2791:    11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
        -: 2792:    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
        -: 2793:    12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
        -: 2794:    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14,
        -: 2795:    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
        -: 2796:    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
        -: 2797:    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
        -: 2798:    14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        -: 2799:    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        -: 2800:    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        -: 2801:    15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        -: 2802:    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        -: 2803:    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        -: 2804:    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        -: 2805:    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        -: 2806:    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        -: 2807:    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
        -: 2808:    16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        -: 2809:    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        -: 2810:    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        -: 2811:    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        -: 2812:    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        -: 2813:    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
        -: 2814:    17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17};
        -: 2815:
        -: 2816:static const mz_uint8 s_tdefl_small_dist_extra[512] = {
        -: 2817:    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        -: 2818:    3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        -: 2819:    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2820:    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2821:    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        -: 2822:    5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        -: 2823:    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        -: 2824:    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        -: 2825:    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        -: 2826:    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        -: 2827:    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2828:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2829:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2830:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2831:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2832:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2833:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2834:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2835:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2836:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        -: 2837:    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};
        -: 2838:
        -: 2839:static const mz_uint8 s_tdefl_large_dist_sym[128] = {
        -: 2840:    0,  0,  18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24,
        -: 2841:    24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
        -: 2842:    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27,
        -: 2843:    27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
        -: 2844:    28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
        -: 2845:    28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
        -: 2846:    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29};
        -: 2847:
        -: 2848:static const mz_uint8 s_tdefl_large_dist_extra[128] = {
        -: 2849:    0,  0,  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
        -: 2850:    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
        -: 2851:    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
        -: 2852:    12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
        -: 2853:    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
        -: 2854:    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
        -: 2855:    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};
        -: 2856:
        -: 2857:// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted
        -: 2858:// values.
        -: 2859:typedef struct { mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;
    #####: 2860:static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms,
        -: 2861:                                             tdefl_sym_freq *pSyms0,
        -: 2862:                                             tdefl_sym_freq *pSyms1) {
    #####: 2863:  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
    #####: 2864:  tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
    #####: 2865:  MZ_CLEAR_OBJ(hist);
    %%%%%: 2865-block  0
    #####: 2866:  for (i = 0; i < num_syms; i++) {
    %%%%%: 2866-block  0
    %%%%%: 2866-block  1
    #####: 2867:    mz_uint freq = pSyms0[i].m_key;
    #####: 2868:    hist[freq & 0xFF]++;
    #####: 2869:    hist[256 + ((freq >> 8) & 0xFF)]++;
    %%%%%: 2869-block  0
        -: 2870:  }
    #####: 2871:  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
    %%%%%: 2871-block  0
    %%%%%: 2871-block  1
        -: 2872:    total_passes--;
    #####: 2873:  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8) {
    %%%%%: 2873-block  0
    #####: 2874:    const mz_uint32 *pHist = &hist[pass << 8];
    #####: 2875:    mz_uint offsets[256], cur_ofs = 0;
    #####: 2876:    for (i = 0; i < 256; i++) {
    %%%%%: 2876-block  0
    %%%%%: 2876-block  1
    #####: 2877:      offsets[i] = cur_ofs;
    #####: 2878:      cur_ofs += pHist[i];
    %%%%%: 2878-block  0
        -: 2879:    }
    #####: 2880:    for (i = 0; i < num_syms; i++)
    %%%%%: 2880-block  0
    #####: 2881:      pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] =
    #####: 2882:          pCur_syms[i];
    %%%%%: 2882-block  0
    #####: 2883:    {
    #####: 2884:      tdefl_sym_freq *t = pCur_syms;
    #####: 2885:      pCur_syms = pNew_syms;
    #####: 2886:      pNew_syms = t;
    %%%%%: 2886-block  0
        -: 2887:    }
        -: 2888:  }
    #####: 2889:  return pCur_syms;
        -: 2890:}
        -: 2891:
        -: 2892:// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat,
        -: 2893:// alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
    #####: 2894:static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n) {
    #####: 2895:  int root, leaf, next, avbl, used, dpth;
    #####: 2896:  if (n == 0)
    %%%%%: 2896-block  0
        -: 2897:    return;
    #####: 2898:  else if (n == 1) {
    %%%%%: 2898-block  0
    #####: 2899:    A[0].m_key = 1;
    #####: 2900:    return;
    %%%%%: 2900-block  0
        -: 2901:  }
    #####: 2902:  A[0].m_key += A[1].m_key;
    #####: 2903:  root = 0;
    #####: 2904:  leaf = 2;
    #####: 2905:  for (next = 1; next < n - 1; next++) {
    %%%%%: 2905-block  0
    %%%%%: 2905-block  1
    %%%%%: 2905-block  2
    #####: 2906:    if (leaf >= n || A[root].m_key < A[leaf].m_key) {
    %%%%%: 2906-block  0
    %%%%%: 2906-block  1
    #####: 2907:      A[next].m_key = A[root].m_key;
    #####: 2908:      A[root++].m_key = (mz_uint16)next;
    %%%%%: 2908-block  0
        -: 2909:    } else
    #####: 2910:      A[next].m_key = A[leaf++].m_key;
    %%%%%: 2910-block  0
    #####: 2911:    if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key)) {
    %%%%%: 2911-block  0
    %%%%%: 2911-block  1
    %%%%%: 2911-block  2
    #####: 2912:      A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
    #####: 2913:      A[root++].m_key = (mz_uint16)next;
    %%%%%: 2913-block  0
        -: 2914:    } else
    #####: 2915:      A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
    %%%%%: 2915-block  0
        -: 2916:  }
    #####: 2917:  A[n - 2].m_key = 0;
    #####: 2918:  for (next = n - 3; next >= 0; next--)
    %%%%%: 2918-block  0
    %%%%%: 2918-block  1
    #####: 2919:    A[next].m_key = A[A[next].m_key].m_key + 1;
    %%%%%: 2919-block  0
    #####: 2920:  avbl = 1;
    #####: 2921:  used = dpth = 0;
    #####: 2922:  root = n - 2;
    #####: 2923:  next = n - 1;
    %%%%%: 2923-block  0
    #####: 2924:  while (avbl > 0) {
    %%%%%: 2924-block  0
    #####: 2925:    while (root >= 0 && (int)A[root].m_key == dpth) {
    %%%%%: 2925-block  0
    %%%%%: 2925-block  1
    #####: 2926:      used++;
    #####: 2927:      root--;
    %%%%%: 2927-block  0
        -: 2928:    }
    #####: 2929:    while (avbl > used) {
    %%%%%: 2929-block  0
    #####: 2930:      A[next--].m_key = (mz_uint16)(dpth);
    #####: 2931:      avbl--;
    %%%%%: 2931-block  0
        -: 2932:    }
    #####: 2933:    avbl = 2 * used;
    #####: 2934:    dpth++;
    #####: 2935:    used = 0;
    %%%%%: 2935-block  0
        -: 2936:  }
        -: 2937:}
        -: 2938:
        -: 2939:// Limits canonical Huffman code table's max code size.
        -: 2940:enum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };
    #####: 2941:static void tdefl_huffman_enforce_max_code_size(int *pNum_codes,
        -: 2942:                                                int code_list_len,
        -: 2943:                                                int max_code_size) {
    #####: 2944:  int i;
    #####: 2945:  mz_uint32 total = 0;
    #####: 2946:  if (code_list_len <= 1)
    %%%%%: 2946-block  0
        -: 2947:    return;
    #####: 2948:  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
    %%%%%: 2948-block  0
    %%%%%: 2948-block  1
    #####: 2949:    pNum_codes[max_code_size] += pNum_codes[i];
    %%%%%: 2949-block  0
    #####: 2950:  for (i = max_code_size; i > 0; i--)
    %%%%%: 2950-block  0
    #####: 2951:    total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
    %%%%%: 2951-block  0
    #####: 2952:  while (total != (1UL << max_code_size)) {
    %%%%%: 2952-block  0
    #####: 2953:    pNum_codes[max_code_size]--;
    #####: 2954:    for (i = max_code_size - 1; i > 0; i--)
    %%%%%: 2954-block  0
    %%%%%: 2954-block  1
    %%%%%: 2954-block  2
    #####: 2955:      if (pNum_codes[i]) {
    %%%%%: 2955-block  0
    #####: 2956:        pNum_codes[i]--;
    #####: 2957:        pNum_codes[i + 1] += 2;
    #####: 2958:        break;
    %%%%%: 2958-block  0
        -: 2959:      }
    #####: 2960:    total--;
    %%%%%: 2960-block  0
        -: 2961:  }
        -: 2962:}
        -: 2963:
    #####: 2964:static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num,
        -: 2965:                                         int table_len, int code_size_limit,
        -: 2966:                                         int static_table) {
    #####: 2967:  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
    #####: 2968:  mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
    #####: 2969:  MZ_CLEAR_OBJ(num_codes);
    %%%%%: 2969-block  0
    #####: 2970:  if (static_table) {
    %%%%%: 2970-block  0
    #####: 2971:    for (i = 0; i < table_len; i++)
    %%%%%: 2971-block  0
    #####: 2972:      num_codes[d->m_huff_code_sizes[table_num][i]]++;
    %%%%%: 2972-block  0
        -: 2973:  } else {
    #####: 2974:    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS],
        -: 2975:        *pSyms;
    #####: 2976:    int num_used_syms = 0;
    #####: 2977:    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
    #####: 2978:    for (i = 0; i < table_len; i++)
    %%%%%: 2978-block  0
    %%%%%: 2978-block  1
    %%%%%: 2978-block  2
    #####: 2979:      if (pSym_count[i]) {
    %%%%%: 2979-block  0
    #####: 2980:        syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
    #####: 2981:        syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
    %%%%%: 2981-block  0
        -: 2982:      }
        -: 2983:
    #####: 2984:    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
    %%%%%: 2984-block  0
    #####: 2985:    tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);
        -: 2986:
    #####: 2987:    for (i = 0; i < num_used_syms; i++)
    %%%%%: 2987-block  0
    #####: 2988:      num_codes[pSyms[i].m_key]++;
    %%%%%: 2988-block  0
        -: 2989:
    #####: 2990:    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms,
    %%%%%: 2990-block  0
        -: 2991:                                        code_size_limit);
        -: 2992:
    #####: 2993:    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]);
    #####: 2994:    MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);
    #####: 2995:    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
    %%%%%: 2995-block  0
    %%%%%: 2995-block  1
    #####: 2996:      for (l = num_codes[i]; l > 0; l--)
    %%%%%: 2996-block  0
    %%%%%: 2996-block  1
    #####: 2997:        d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
    %%%%%: 2997-block  0
        -: 2998:  }
        -: 2999:
    #####: 3000:  next_code[1] = 0;
    #####: 3001:  for (j = 0, i = 2; i <= code_size_limit; i++)
    %%%%%: 3001-block  0
    %%%%%: 3001-block  1
    #####: 3002:    next_code[i] = j = ((j + num_codes[i - 1]) << 1);
    %%%%%: 3002-block  0
        -: 3003:
    #####: 3004:  for (i = 0; i < table_len; i++) {
    %%%%%: 3004-block  0
    %%%%%: 3004-block  1
    #####: 3005:    mz_uint rev_code = 0, code, code_size;
    #####: 3006:    if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0)
    %%%%%: 3006-block  0
    #####: 3007:      continue;
    %%%%%: 3007-block  0
    #####: 3008:    code = next_code[code_size]++;
    #####: 3009:    for (l = code_size; l > 0; l--, code >>= 1)
    %%%%%: 3009-block  0
    %%%%%: 3009-block  1
    #####: 3010:      rev_code = (rev_code << 1) | (code & 1);
    %%%%%: 3010-block  0
    #####: 3011:    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
    %%%%%: 3011-block  0
        -: 3012:  }
    #####: 3013:}
        -: 3014:
        -: 3015:#define TDEFL_PUT_BITS(b, l)                                                   \
        -: 3016:  do {                                                                         \
        -: 3017:    mz_uint bits = b;                                                          \
        -: 3018:    mz_uint len = l;                                                           \
        -: 3019:    MZ_ASSERT(bits <= ((1U << len) - 1U));                                     \
        -: 3020:    d->m_bit_buffer |= (bits << d->m_bits_in);                                 \
        -: 3021:    d->m_bits_in += len;                                                       \
        -: 3022:    while (d->m_bits_in >= 8) {                                                \
        -: 3023:      if (d->m_pOutput_buf < d->m_pOutput_buf_end)                             \
        -: 3024:        *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer);                     \
        -: 3025:      d->m_bit_buffer >>= 8;                                                   \
        -: 3026:      d->m_bits_in -= 8;                                                       \
        -: 3027:    }                                                                          \
        -: 3028:  }                                                                            \
        -: 3029:  MZ_MACRO_END
        -: 3030:
        -: 3031:#define TDEFL_RLE_PREV_CODE_SIZE()                                             \
        -: 3032:  {                                                                            \
        -: 3033:    if (rle_repeat_count) {                                                    \
        -: 3034:      if (rle_repeat_count < 3) {                                              \
        -: 3035:        d->m_huff_count[2][prev_code_size] = (mz_uint16)(                      \
        -: 3036:            d->m_huff_count[2][prev_code_size] + rle_repeat_count);            \
        -: 3037:        while (rle_repeat_count--)                                             \
        -: 3038:          packed_code_sizes[num_packed_code_sizes++] = prev_code_size;         \
        -: 3039:      } else {                                                                 \
        -: 3040:        d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);      \
        -: 3041:        packed_code_sizes[num_packed_code_sizes++] = 16;                       \
        -: 3042:        packed_code_sizes[num_packed_code_sizes++] =                           \
        -: 3043:            (mz_uint8)(rle_repeat_count - 3);                                  \
        -: 3044:      }                                                                        \
        -: 3045:      rle_repeat_count = 0;                                                    \
        -: 3046:    }                                                                          \
        -: 3047:  }
        -: 3048:
        -: 3049:#define TDEFL_RLE_ZERO_CODE_SIZE()                                             \
        -: 3050:  {                                                                            \
        -: 3051:    if (rle_z_count) {                                                         \
        -: 3052:      if (rle_z_count < 3) {                                                   \
        -: 3053:        d->m_huff_count[2][0] =                                                \
        -: 3054:            (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);                  \
        -: 3055:        while (rle_z_count--)                                                  \
        -: 3056:          packed_code_sizes[num_packed_code_sizes++] = 0;                      \
        -: 3057:      } else if (rle_z_count <= 10) {                                          \
        -: 3058:        d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);      \
        -: 3059:        packed_code_sizes[num_packed_code_sizes++] = 17;                       \
        -: 3060:        packed_code_sizes[num_packed_code_sizes++] =                           \
        -: 3061:            (mz_uint8)(rle_z_count - 3);                                       \
        -: 3062:      } else {                                                                 \
        -: 3063:        d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);      \
        -: 3064:        packed_code_sizes[num_packed_code_sizes++] = 18;                       \
        -: 3065:        packed_code_sizes[num_packed_code_sizes++] =                           \
        -: 3066:            (mz_uint8)(rle_z_count - 11);                                      \
        -: 3067:      }                                                                        \
        -: 3068:      rle_z_count = 0;                                                         \
        -: 3069:    }                                                                          \
        -: 3070:  }
        -: 3071:
        -: 3072:static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = {
        -: 3073:    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
        -: 3074:
    #####: 3075:static void tdefl_start_dynamic_block(tdefl_compressor *d) {
    #####: 3076:  int num_lit_codes, num_dist_codes, num_bit_lengths;
    #####: 3077:  mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count,
        -: 3078:      rle_repeat_count, packed_code_sizes_index;
    #####: 3079:  mz_uint8
        -: 3080:      code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],
        -: 3081:      packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],
    #####: 3082:      prev_code_size = 0xFF;
        -: 3083:
    #####: 3084:  d->m_huff_count[0][256] = 1;
        -: 3085:
    #####: 3086:  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
    %%%%%: 3086-block  0
    #####: 3087:  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);
        -: 3088:
    #####: 3089:  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
    %%%%%: 3089-block  0
    #####: 3090:    if (d->m_huff_code_sizes[0][num_lit_codes - 1])
    %%%%%: 3090-block  0
        -: 3091:      break;
    #####: 3092:  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
    %%%%%: 3092-block  0
    #####: 3093:    if (d->m_huff_code_sizes[1][num_dist_codes - 1])
    %%%%%: 3093-block  0
        -: 3094:      break;
        -: 3095:
    #####: 3096:  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
    %%%%%: 3096-block  0
    #####: 3097:  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0],
        -: 3098:         num_dist_codes);
    #####: 3099:  total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
    #####: 3100:  num_packed_code_sizes = 0;
    #####: 3101:  rle_z_count = 0;
    #####: 3102:  rle_repeat_count = 0;
        -: 3103:
    #####: 3104:  memset(&d->m_huff_count[2][0], 0,
    %%%%%: 3104-block  0
        -: 3105:         sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
    #####: 3106:  for (i = 0; i < total_code_sizes_to_pack; i++) {
    %%%%%: 3106-block  0
    %%%%%: 3106-block  1
    #####: 3107:    mz_uint8 code_size = code_sizes_to_pack[i];
    #####: 3108:    if (!code_size) {
    %%%%%: 3108-block  0
    #####: 3109:      TDEFL_RLE_PREV_CODE_SIZE();
    %%%%%: 3109-block  0
    %%%%%: 3109-block  1
    %%%%%: 3109-block  2
    %%%%%: 3109-block  3
    %%%%%: 3109-block  4
    %%%%%: 3109-block  5
    #####: 3110:      if (++rle_z_count == 138) {
    %%%%%: 3110-block  0
    #####: 3111:        TDEFL_RLE_ZERO_CODE_SIZE();
    %%%%%: 3111-block  0
        -: 3112:      }
        -: 3113:    } else {
    #####: 3114:      TDEFL_RLE_ZERO_CODE_SIZE();
    %%%%%: 3114-block  0
    %%%%%: 3114-block  1
    %%%%%: 3114-block  2
    %%%%%: 3114-block  3
    %%%%%: 3114-block  4
    %%%%%: 3114-block  5
    %%%%%: 3114-block  6
    %%%%%: 3114-block  7
    #####: 3115:      if (code_size != prev_code_size) {
    %%%%%: 3115-block  0
    #####: 3116:        TDEFL_RLE_PREV_CODE_SIZE();
    %%%%%: 3116-block  0
    %%%%%: 3116-block  1
    %%%%%: 3116-block  2
    %%%%%: 3116-block  3
    %%%%%: 3116-block  4
    %%%%%: 3116-block  5
    #####: 3117:        d->m_huff_count[2][code_size] =
    #####: 3118:            (mz_uint16)(d->m_huff_count[2][code_size] + 1);
    #####: 3119:        packed_code_sizes[num_packed_code_sizes++] = code_size;
    %%%%%: 3119-block  0
    #####: 3120:      } else if (++rle_repeat_count == 6) {
    %%%%%: 3120-block  0
    #####: 3121:        TDEFL_RLE_PREV_CODE_SIZE();
    %%%%%: 3121-block  0
        -: 3122:      }
        -: 3123:    }
    #####: 3124:    prev_code_size = code_size;
    %%%%%: 3124-block  0
        -: 3125:  }
    #####: 3126:  if (rle_repeat_count) {
    %%%%%: 3126-block  0
    #####: 3127:    TDEFL_RLE_PREV_CODE_SIZE();
    %%%%%: 3127-block  0
    %%%%%: 3127-block  1
    %%%%%: 3127-block  2
    %%%%%: 3127-block  3
    %%%%%: 3127-block  4
        -: 3128:  } else {
    #####: 3129:    TDEFL_RLE_ZERO_CODE_SIZE();
    %%%%%: 3129-block  0
    %%%%%: 3129-block  1
    %%%%%: 3129-block  2
    %%%%%: 3129-block  3
    %%%%%: 3129-block  4
    %%%%%: 3129-block  5
    %%%%%: 3129-block  6
    %%%%%: 3129-block  7
        -: 3130:  }
        -: 3131:
    #####: 3132:  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);
    %%%%%: 3132-block  0
        -: 3133:
    #####: 3134:  TDEFL_PUT_BITS(2, 2);
    %%%%%: 3134-block  0
    %%%%%: 3134-block  1
    %%%%%: 3134-block  2
    %%%%%: 3134-block  3
        -: 3135:
    #####: 3136:  TDEFL_PUT_BITS(num_lit_codes - 257, 5);
    %%%%%: 3136-block  0
    %%%%%: 3136-block  1
    %%%%%: 3136-block  2
    %%%%%: 3136-block  3
    %%%%%: 3136-block  4
    #####: 3137:  TDEFL_PUT_BITS(num_dist_codes - 1, 5);
    %%%%%: 3137-block  0
    %%%%%: 3137-block  1
    %%%%%: 3137-block  2
    %%%%%: 3137-block  3
    %%%%%: 3137-block  4
        -: 3138:
    #####: 3139:  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
    %%%%%: 3139-block  0
    %%%%%: 3139-block  1
    #####: 3140:    if (d->m_huff_code_sizes
    #####: 3141:            [2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])
    %%%%%: 3141-block  0
        -: 3142:      break;
    #####: 3143:  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
    #####: 3144:  TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
    %%%%%: 3144-block  0
    %%%%%: 3144-block  1
    %%%%%: 3144-block  2
    %%%%%: 3144-block  3
    %%%%%: 3144-block  4
    #####: 3145:  for (i = 0; (int)i < num_bit_lengths; i++)
    %%%%%: 3145-block  0
    %%%%%: 3145-block  1
    #####: 3146:    TDEFL_PUT_BITS(
    %%%%%: 3146-block  0
    %%%%%: 3146-block  1
    %%%%%: 3146-block  2
    %%%%%: 3146-block  3
    %%%%%: 3146-block  4
    %%%%%: 3146-block  5
    %%%%%: 3146-block  6
        -: 3147:        d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);
        -: 3148:
        -: 3149:  for (packed_code_sizes_index = 0;
    #####: 3150:       packed_code_sizes_index < num_packed_code_sizes;) {
    %%%%%: 3150-block  0
    #####: 3151:    mz_uint code = packed_code_sizes[packed_code_sizes_index++];
    #####: 3152:    MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
    %%%%%: 3152-block  0
    %%%%%: 3152-block  1
    #####: 3153:    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
    %%%%%: 3153-block  0
    %%%%%: 3153-block  1
    %%%%%: 3153-block  2
    %%%%%: 3153-block  3
    %%%%%: 3153-block  4
    %%%%%: 3153-block  5
    %%%%%: 3153-block  6
    #####: 3154:    if (code >= 16)
    %%%%%: 3154-block  0
    #####: 3155:      TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++],
    %%%%%: 3155-block  0
    %%%%%: 3155-block  1
    %%%%%: 3155-block  2
    %%%%%: 3155-block  3
    %%%%%: 3155-block  4
    %%%%%: 3155-block  5
    %%%%%: 3155-block  6
        -: 3156:                     "\02\03\07"[code - 16]);
        -: 3157:  }
    #####: 3158:}
        -: 3159:
    #####: 3160:static void tdefl_start_static_block(tdefl_compressor *d) {
    #####: 3161:  mz_uint i;
    #####: 3162:  mz_uint8 *p = &d->m_huff_code_sizes[0][0];
        -: 3163:
    #####: 3164:  for (i = 0; i <= 143; ++i)
    %%%%%: 3164-block  0
    %%%%%: 3164-block  1
    #####: 3165:    *p++ = 8;
    %%%%%: 3165-block  0
    #####: 3166:  for (; i <= 255; ++i)
    %%%%%: 3166-block  0
    #####: 3167:    *p++ = 9;
    %%%%%: 3167-block  0
    #####: 3168:  for (; i <= 279; ++i)
    %%%%%: 3168-block  0
    #####: 3169:    *p++ = 7;
    %%%%%: 3169-block  0
    #####: 3170:  for (; i <= 287; ++i)
    %%%%%: 3170-block  0
    #####: 3171:    *p++ = 8;
    %%%%%: 3171-block  0
        -: 3172:
    #####: 3173:  memset(d->m_huff_code_sizes[1], 5, 32);
    %%%%%: 3173-block  0
        -: 3174:
    #####: 3175:  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
    %%%%%: 3175-block  0
    #####: 3176:  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);
        -: 3177:
    #####: 3178:  TDEFL_PUT_BITS(1, 2);
    %%%%%: 3178-block  0
    %%%%%: 3178-block  1
    %%%%%: 3178-block  2
    %%%%%: 3178-block  3
    #####: 3179:}
        -: 3180:
        -: 3181:static const mz_uint mz_bitmasks[17] = {
        -: 3182:    0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
        -: 3183:    0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF};
        -: 3184:
        -: 3185:#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN &&             \
        -: 3186:    MINIZ_HAS_64BIT_REGISTERS
        -: 3187:static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {
        -: 3188:  mz_uint flags;
        -: 3189:  mz_uint8 *pLZ_codes;
        -: 3190:  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
        -: 3191:  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
        -: 3192:  mz_uint64 bit_buffer = d->m_bit_buffer;
        -: 3193:  mz_uint bits_in = d->m_bits_in;
        -: 3194:
        -: 3195:#define TDEFL_PUT_BITS_FAST(b, l)                                              \
        -: 3196:  {                                                                            \
        -: 3197:    bit_buffer |= (((mz_uint64)(b)) << bits_in);                               \
        -: 3198:    bits_in += (l);                                                            \
        -: 3199:  }
        -: 3200:
        -: 3201:  flags = 1;
        -: 3202:  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end;
        -: 3203:       flags >>= 1) {
        -: 3204:    if (flags == 1)
        -: 3205:      flags = *pLZ_codes++ | 0x100;
        -: 3206:
        -: 3207:    if (flags & 1) {
        -: 3208:      mz_uint s0, s1, n0, n1, sym, num_extra_bits;
        -: 3209:      mz_uint match_len = pLZ_codes[0],
        -: 3210:              match_dist = *(const mz_uint16 *)(pLZ_codes + 1);
        -: 3211:      pLZ_codes += 3;
        -: 3212:
        -: 3213:      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
        -: 3214:      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],
        -: 3215:                          d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
        -: 3216:      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],
        -: 3217:                          s_tdefl_len_extra[match_len]);
        -: 3218:
        -: 3219:      // This sequence coaxes MSVC into using cmov's vs. jmp's.
        -: 3220:      s0 = s_tdefl_small_dist_sym[match_dist & 511];
        -: 3221:      n0 = s_tdefl_small_dist_extra[match_dist & 511];
        -: 3222:      s1 = s_tdefl_large_dist_sym[match_dist >> 8];
        -: 3223:      n1 = s_tdefl_large_dist_extra[match_dist >> 8];
        -: 3224:      sym = (match_dist < 512) ? s0 : s1;
        -: 3225:      num_extra_bits = (match_dist < 512) ? n0 : n1;
        -: 3226:
        -: 3227:      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
        -: 3228:      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym],
        -: 3229:                          d->m_huff_code_sizes[1][sym]);
        -: 3230:      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits],
        -: 3231:                          num_extra_bits);
        -: 3232:    } else {
        -: 3233:      mz_uint lit = *pLZ_codes++;
        -: 3234:      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
        -: 3235:      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],
        -: 3236:                          d->m_huff_code_sizes[0][lit]);
        -: 3237:
        -: 3238:      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
        -: 3239:        flags >>= 1;
        -: 3240:        lit = *pLZ_codes++;
        -: 3241:        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
        -: 3242:        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],
        -: 3243:                            d->m_huff_code_sizes[0][lit]);
        -: 3244:
        -: 3245:        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
        -: 3246:          flags >>= 1;
        -: 3247:          lit = *pLZ_codes++;
        -: 3248:          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
        -: 3249:          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],
        -: 3250:                              d->m_huff_code_sizes[0][lit]);
        -: 3251:        }
        -: 3252:      }
        -: 3253:    }
        -: 3254:
        -: 3255:    if (pOutput_buf >= d->m_pOutput_buf_end)
        -: 3256:      return MZ_FALSE;
        -: 3257:
        -: 3258:    *(mz_uint64 *)pOutput_buf = bit_buffer;
        -: 3259:    pOutput_buf += (bits_in >> 3);
        -: 3260:    bit_buffer >>= (bits_in & ~7);
        -: 3261:    bits_in &= 7;
        -: 3262:  }
        -: 3263:
        -: 3264:#undef TDEFL_PUT_BITS_FAST
        -: 3265:
        -: 3266:  d->m_pOutput_buf = pOutput_buf;
        -: 3267:  d->m_bits_in = 0;
        -: 3268:  d->m_bit_buffer = 0;
        -: 3269:
        -: 3270:  while (bits_in) {
        -: 3271:    mz_uint32 n = MZ_MIN(bits_in, 16);
        -: 3272:    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
        -: 3273:    bit_buffer >>= n;
        -: 3274:    bits_in -= n;
        -: 3275:  }
        -: 3276:
        -: 3277:  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
        -: 3278:
        -: 3279:  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
        -: 3280:}
        -: 3281:#else
    #####: 3282:static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {
    #####: 3283:  mz_uint flags;
    #####: 3284:  mz_uint8 *pLZ_codes;
        -: 3285:
    #####: 3286:  flags = 1;
    #####: 3287:  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf;
    %%%%%: 3287-block  0
    %%%%%: 3287-block  1
    #####: 3288:       flags >>= 1) {
    %%%%%: 3288-block  0
    #####: 3289:    if (flags == 1)
    %%%%%: 3289-block  0
    #####: 3290:      flags = *pLZ_codes++ | 0x100;
    %%%%%: 3290-block  0
    #####: 3291:    if (flags & 1) {
    %%%%%: 3291-block  0
    #####: 3292:      mz_uint sym, num_extra_bits;
    #####: 3293:      mz_uint match_len = pLZ_codes[0],
    #####: 3294:              match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
    #####: 3295:      pLZ_codes += 3;
        -: 3296:
    #####: 3297:      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
    %%%%%: 3297-block  0
    %%%%%: 3297-block  1
    #####: 3298:      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],
    %%%%%: 3298-block  0
    %%%%%: 3298-block  1
    %%%%%: 3298-block  2
    %%%%%: 3298-block  3
    %%%%%: 3298-block  4
    %%%%%: 3298-block  5
    %%%%%: 3298-block  6
        -: 3299:                     d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
    #####: 3300:      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],
    %%%%%: 3300-block  0
    %%%%%: 3300-block  1
    %%%%%: 3300-block  2
    %%%%%: 3300-block  3
    %%%%%: 3300-block  4
    %%%%%: 3300-block  5
    %%%%%: 3300-block  6
        -: 3301:                     s_tdefl_len_extra[match_len]);
        -: 3302:
    #####: 3303:      if (match_dist < 512) {
    %%%%%: 3303-block  0
    #####: 3304:        sym = s_tdefl_small_dist_sym[match_dist];
    #####: 3305:        num_extra_bits = s_tdefl_small_dist_extra[match_dist];
    %%%%%: 3305-block  0
        -: 3306:      } else {
    #####: 3307:        sym = s_tdefl_large_dist_sym[match_dist >> 8];
    #####: 3308:        num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
    %%%%%: 3308-block  0
        -: 3309:      }
    #####: 3310:      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
    %%%%%: 3310-block  0
    %%%%%: 3310-block  1
    #####: 3311:      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
    %%%%%: 3311-block  0
    %%%%%: 3311-block  1
    %%%%%: 3311-block  2
    %%%%%: 3311-block  3
    %%%%%: 3311-block  4
    %%%%%: 3311-block  5
    %%%%%: 3311-block  6
    #####: 3312:      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
    %%%%%: 3312-block  0
    %%%%%: 3312-block  1
    %%%%%: 3312-block  2
    %%%%%: 3312-block  3
    %%%%%: 3312-block  4
    %%%%%: 3312-block  5
    %%%%%: 3312-block  6
        -: 3313:    } else {
    #####: 3314:      mz_uint lit = *pLZ_codes++;
    #####: 3315:      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
    %%%%%: 3315-block  0
    %%%%%: 3315-block  1
    #####: 3316:      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
    %%%%%: 3316-block  0
    %%%%%: 3316-block  1
    %%%%%: 3316-block  2
    %%%%%: 3316-block  3
    %%%%%: 3316-block  4
    %%%%%: 3316-block  5
    %%%%%: 3316-block  6
        -: 3317:    }
        -: 3318:  }
        -: 3319:
    #####: 3320:  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);
    %%%%%: 3320-block  0
    %%%%%: 3320-block  1
    %%%%%: 3320-block  2
    %%%%%: 3320-block  3
    %%%%%: 3320-block  4
    %%%%%: 3320-block  5
    %%%%%: 3320-block  6
        -: 3321:
    #####: 3322:  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
        -: 3323:}
        -: 3324:#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN &&
        -: 3325:       // MINIZ_HAS_64BIT_REGISTERS
        -: 3326:
    #####: 3327:static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block) {
    #####: 3328:  if (static_block)
    %%%%%: 3328-block  0
    #####: 3329:    tdefl_start_static_block(d);
    %%%%%: 3329-block  0
        -: 3330:  else
    #####: 3331:    tdefl_start_dynamic_block(d);
    %%%%%: 3331-block  0
    #####: 3332:  return tdefl_compress_lz_codes(d);
    %%%%%: 3332-block  0
        -: 3333:}
        -: 3334:
    #####: 3335:static int tdefl_flush_block(tdefl_compressor *d, int flush) {
    #####: 3336:  mz_uint saved_bit_buf, saved_bits_in;
    #####: 3337:  mz_uint8 *pSaved_output_buf;
    #####: 3338:  mz_bool comp_block_succeeded = MZ_FALSE;
    #####: 3339:  int n, use_raw_block =
    #####: 3340:             ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) &&
    %%%%%: 3340-block  0
    #####: 3341:             (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
    %%%%%: 3341-block  0
    #####: 3342:  mz_uint8 *pOutput_buf_start =
    #####: 3343:      ((d->m_pPut_buf_func == NULL) &&
    #####: 3344:       ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE))
    %%%%%: 3344-block  0
    #####: 3345:          ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs)
    %%%%%: 3345-block  0
    %%%%%: 3345-block  1
    %%%%%: 3345-block  2
        -: 3346:          : d->m_output_buf;
        -: 3347:
    #####: 3348:  d->m_pOutput_buf = pOutput_buf_start;
    #####: 3349:  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;
        -: 3350:
    #####: 3351:  MZ_ASSERT(!d->m_output_flush_remaining);
    %%%%%: 3351-block  0
    %%%%%: 3351-block  1
    #####: 3352:  d->m_output_flush_ofs = 0;
    #####: 3353:  d->m_output_flush_remaining = 0;
        -: 3354:
    #####: 3355:  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
    #####: 3356:  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);
        -: 3357:
    #####: 3358:  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index)) {
    %%%%%: 3358-block  0
    %%%%%: 3358-block  1
    #####: 3359:    TDEFL_PUT_BITS(0x78, 8);
    %%%%%: 3359-block  0
    %%%%%: 3359-block  1
    %%%%%: 3359-block  2
    %%%%%: 3359-block  3
    %%%%%: 3359-block  4
    #####: 3360:    TDEFL_PUT_BITS(0x01, 8);
    %%%%%: 3360-block  0
    %%%%%: 3360-block  1
    %%%%%: 3360-block  2
    %%%%%: 3360-block  3
    %%%%%: 3360-block  4
        -: 3361:  }
        -: 3362:
    #####: 3363:  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);
    %%%%%: 3363-block  0
    %%%%%: 3363-block  1
    %%%%%: 3363-block  2
    %%%%%: 3363-block  3
    %%%%%: 3363-block  4
        -: 3364:
    #####: 3365:  pSaved_output_buf = d->m_pOutput_buf;
    #####: 3366:  saved_bit_buf = d->m_bit_buffer;
    #####: 3367:  saved_bits_in = d->m_bits_in;
        -: 3368:
    #####: 3369:  if (!use_raw_block)
    %%%%%: 3369-block  0
    #####: 3370:    comp_block_succeeded =
    #####: 3371:        tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) ||
    %%%%%: 3371-block  0
    %%%%%: 3371-block  1
    #####: 3372:                                    (d->m_total_lz_bytes < 48));
    %%%%%: 3372-block  0
        -: 3373:
        -: 3374:  // If the block gets expanded, forget the current contents of the output
        -: 3375:  // buffer and send a raw block instead.
    #####: 3376:  if (((use_raw_block) ||
    %%%%%: 3376-block  0
    #####: 3377:       ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >=
    %%%%%: 3377-block  0
    #####: 3378:                                  d->m_total_lz_bytes))) &&
    %%%%%: 3378-block  0
    #####: 3379:      ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size)) {
    %%%%%: 3379-block  0
    #####: 3380:    mz_uint i;
    #####: 3381:    d->m_pOutput_buf = pSaved_output_buf;
    #####: 3382:    d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
    #####: 3383:    TDEFL_PUT_BITS(0, 2);
    %%%%%: 3383-block  0
    %%%%%: 3383-block  1
    %%%%%: 3383-block  2
    %%%%%: 3383-block  3
    %%%%%: 3383-block  4
    #####: 3384:    if (d->m_bits_in) {
    %%%%%: 3384-block  0
    #####: 3385:      TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
    %%%%%: 3385-block  0
    %%%%%: 3385-block  1
    %%%%%: 3385-block  2
    %%%%%: 3385-block  3
    %%%%%: 3385-block  4
        -: 3386:    }
    #####: 3387:    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF) {
    %%%%%: 3387-block  0
    %%%%%: 3387-block  1
    #####: 3388:      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
    %%%%%: 3388-block  0
    %%%%%: 3388-block  1
    %%%%%: 3388-block  2
    %%%%%: 3388-block  3
    %%%%%: 3388-block  4
        -: 3389:    }
    #####: 3390:    for (i = 0; i < d->m_total_lz_bytes; ++i) {
    %%%%%: 3390-block  0
    %%%%%: 3390-block  1
    #####: 3391:      TDEFL_PUT_BITS(
    %%%%%: 3391-block  0
    %%%%%: 3391-block  1
    %%%%%: 3391-block  2
    %%%%%: 3391-block  3
    %%%%%: 3391-block  4
        -: 3392:          d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK],
        -: 3393:          8);
        -: 3394:    }
        -: 3395:  }
        -: 3396:  // Check for the extremely unlikely (if not impossible) case of the compressed
        -: 3397:  // block not fitting into the output buffer when using dynamic codes.
    #####: 3398:  else if (!comp_block_succeeded) {
    %%%%%: 3398-block  0
    #####: 3399:    d->m_pOutput_buf = pSaved_output_buf;
    #####: 3400:    d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
    #####: 3401:    tdefl_compress_block(d, MZ_TRUE);
    %%%%%: 3401-block  0
        -: 3402:  }
        -: 3403:
    #####: 3404:  if (flush) {
    %%%%%: 3404-block  0
    #####: 3405:    if (flush == TDEFL_FINISH) {
    %%%%%: 3405-block  0
    #####: 3406:      if (d->m_bits_in) {
    %%%%%: 3406-block  0
    #####: 3407:        TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
    %%%%%: 3407-block  0
    %%%%%: 3407-block  1
    %%%%%: 3407-block  2
    %%%%%: 3407-block  3
    %%%%%: 3407-block  4
        -: 3408:      }
    #####: 3409:      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) {
    %%%%%: 3409-block  0
    #####: 3410:        mz_uint i, a = d->m_adler32;
    #####: 3411:        for (i = 0; i < 4; i++) {
    %%%%%: 3411-block  0
    %%%%%: 3411-block  1
    #####: 3412:          TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
    %%%%%: 3412-block  0
    %%%%%: 3412-block  1
    %%%%%: 3412-block  2
    %%%%%: 3412-block  3
    %%%%%: 3412-block  4
    #####: 3413:          a <<= 8;
    %%%%%: 3413-block  0
        -: 3414:        }
        -: 3415:      }
        -: 3416:    } else {
    #####: 3417:      mz_uint i, z = 0;
    #####: 3418:      TDEFL_PUT_BITS(0, 3);
    %%%%%: 3418-block  0
    %%%%%: 3418-block  1
    %%%%%: 3418-block  2
    %%%%%: 3418-block  3
    %%%%%: 3418-block  4
    #####: 3419:      if (d->m_bits_in) {
    %%%%%: 3419-block  0
    #####: 3420:        TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
    %%%%%: 3420-block  0
    %%%%%: 3420-block  1
    %%%%%: 3420-block  2
    %%%%%: 3420-block  3
    %%%%%: 3420-block  4
        -: 3421:      }
    #####: 3422:      for (i = 2; i; --i, z ^= 0xFFFF) {
    %%%%%: 3422-block  0
    %%%%%: 3422-block  1
    #####: 3423:        TDEFL_PUT_BITS(z & 0xFFFF, 16);
    %%%%%: 3423-block  0
    %%%%%: 3423-block  1
    %%%%%: 3423-block  2
    %%%%%: 3423-block  3
    %%%%%: 3423-block  4
    %%%%%: 3423-block  5
    %%%%%: 3423-block  6
        -: 3424:      }
        -: 3425:    }
        -: 3426:  }
        -: 3427:
    #####: 3428:  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);
    %%%%%: 3428-block  0
    %%%%%: 3428-block  1
        -: 3429:
    #####: 3430:  memset(&d->m_huff_count[0][0], 0,
    %%%%%: 3430-block  0
        -: 3431:         sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    #####: 3432:  memset(&d->m_huff_count[1][0], 0,
        -: 3433:         sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
        -: 3434:
    #####: 3435:  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    #####: 3436:  d->m_pLZ_flags = d->m_lz_code_buf;
    #####: 3437:  d->m_num_flags_left = 8;
    #####: 3438:  d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
    #####: 3439:  d->m_total_lz_bytes = 0;
    #####: 3440:  d->m_block_index++;
        -: 3441:
    #####: 3442:  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0) {
    %%%%%: 3442-block  0
    #####: 3443:    if (d->m_pPut_buf_func) {
    %%%%%: 3443-block  0
    #####: 3444:      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
    #####: 3445:      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
    %%%%%: 3445-block  0
    #####: 3446:        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
    %%%%%: 3446-block  0
    #####: 3447:    } else if (pOutput_buf_start == d->m_output_buf) {
    %%%%%: 3447-block  0
    #####: 3448:      int bytes_to_copy = (int)MZ_MIN(
        -: 3449:          (size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
    #####: 3450:      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf,
    %%%%%: 3450-block  0
        -: 3451:             bytes_to_copy);
    #####: 3452:      d->m_out_buf_ofs += bytes_to_copy;
    #####: 3453:      if ((n -= bytes_to_copy) != 0) {
    %%%%%: 3453-block  0
    #####: 3454:        d->m_output_flush_ofs = bytes_to_copy;
    #####: 3455:        d->m_output_flush_remaining = n;
    %%%%%: 3455-block  0
        -: 3456:      }
        -: 3457:    } else {
    #####: 3458:      d->m_out_buf_ofs += n;
    %%%%%: 3458-block  0
        -: 3459:    }
        -: 3460:  }
        -: 3461:
    #####: 3462:  return d->m_output_flush_remaining;
    %%%%%: 3462-block  0
        -: 3463:}
        -: 3464:
        -: 3465:#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
        -: 3466:#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)
        -: 3467:static MZ_FORCEINLINE void
        -: 3468:tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,
        -: 3469:                 mz_uint max_match_len, mz_uint *pMatch_dist,
        -: 3470:                 mz_uint *pMatch_len) {
        -: 3471:  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,
        -: 3472:                match_len = *pMatch_len, probe_pos = pos, next_probe_pos,
        -: 3473:                probe_len;
        -: 3474:  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
        -: 3475:  const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;
        -: 3476:  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]),
        -: 3477:            s01 = TDEFL_READ_UNALIGNED_WORD(s);
        -: 3478:  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
        -: 3479:  if (max_match_len <= match_len)
        -: 3480:    return;
        -: 3481:  for (;;) {
        -: 3482:    for (;;) {
        -: 3483:      if (--num_probes_left == 0)
        -: 3484:        return;
        -: 3485:#define TDEFL_PROBE                                                            \
        -: 3486:  next_probe_pos = d->m_next[probe_pos];                                       \
        -: 3487:  if ((!next_probe_pos) ||                                                     \
        -: 3488:      ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))       \
        -: 3489:    return;                                                                    \
        -: 3490:  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                        \
        -: 3491:  if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) \
        -: 3492:    break;
        -: 3493:      TDEFL_PROBE;
        -: 3494:      TDEFL_PROBE;
        -: 3495:      TDEFL_PROBE;
        -: 3496:    }
        -: 3497:    if (!dist)
        -: 3498:      break;
        -: 3499:    q = (const mz_uint16 *)(d->m_dict + probe_pos);
        -: 3500:    if (TDEFL_READ_UNALIGNED_WORD(q) != s01)
        -: 3501:      continue;
        -: 3502:    p = s;
        -: 3503:    probe_len = 32;
        -: 3504:    do {
        -: 3505:    } while (
        -: 3506:        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3507:        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3508:        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3509:        (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3510:        (--probe_len > 0));
        -: 3511:    if (!probe_len) {
        -: 3512:      *pMatch_dist = dist;
        -: 3513:      *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN);
        -: 3514:      break;
        -: 3515:    } else if ((probe_len = ((mz_uint)(p - s) * 2) +
        -: 3516:                            (mz_uint)(*(const mz_uint8 *)p ==
        -: 3517:                                      *(const mz_uint8 *)q)) > match_len) {
        -: 3518:      *pMatch_dist = dist;
        -: 3519:      if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) ==
        -: 3520:          max_match_len)
        -: 3521:        break;
        -: 3522:      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
        -: 3523:    }
        -: 3524:  }
        -: 3525:}
        -: 3526:#else
        -: 3527:static MZ_FORCEINLINE void
    #####: 3528:tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,
        -: 3529:                 mz_uint max_match_len, mz_uint *pMatch_dist,
        -: 3530:                 mz_uint *pMatch_len) {
    #####: 3531:  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,
    #####: 3532:                match_len = *pMatch_len, probe_pos = pos, next_probe_pos,
        -: 3533:                probe_len;
    #####: 3534:  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    #####: 3535:  const mz_uint8 *s = d->m_dict + pos, *p, *q;
    #####: 3536:  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
    #####: 3537:  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    %%%%%: 3537-block  0
    #####: 3538:  if (max_match_len <= match_len)
    %%%%%: 3538-block  0
        -: 3539:    return;
    #####: 3540:  for (;;) {
    #####: 3541:    for (;;) {
    #####: 3542:      if (--num_probes_left == 0)
    %%%%%: 3542-block  0
        -: 3543:        return;
        -: 3544:#define TDEFL_PROBE                                                            \
        -: 3545:  next_probe_pos = d->m_next[probe_pos];                                       \
        -: 3546:  if ((!next_probe_pos) ||                                                     \
        -: 3547:      ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))       \
        -: 3548:    return;                                                                    \
        -: 3549:  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                        \
        -: 3550:  if ((d->m_dict[probe_pos + match_len] == c0) &&                              \
        -: 3551:      (d->m_dict[probe_pos + match_len - 1] == c1))                            \
        -: 3552:    break;
    #####: 3553:      TDEFL_PROBE;
    %%%%%: 3553-block  0
    %%%%%: 3553-block  1
    %%%%%: 3553-block  2
    %%%%%: 3553-block  3
    #####: 3554:      TDEFL_PROBE;
    %%%%%: 3554-block  0
    %%%%%: 3554-block  1
    %%%%%: 3554-block  2
    %%%%%: 3554-block  3
    #####: 3555:      TDEFL_PROBE;
    %%%%%: 3555-block  0
    %%%%%: 3555-block  1
    %%%%%: 3555-block  2
    %%%%%: 3555-block  3
        -: 3556:    }
    #####: 3557:    if (!dist)
    %%%%%: 3557-block  0
        -: 3558:      break;
    #####: 3559:    p = s;
    #####: 3560:    q = d->m_dict + probe_pos;
    #####: 3561:    for (probe_len = 0; probe_len < max_match_len; probe_len++)
    %%%%%: 3561-block  0
    %%%%%: 3561-block  1
    %%%%%: 3561-block  2
    #####: 3562:      if (*p++ != *q++)
    %%%%%: 3562-block  0
        -: 3563:        break;
    #####: 3564:    if (probe_len > match_len) {
    %%%%%: 3564-block  0
    #####: 3565:      *pMatch_dist = dist;
    #####: 3566:      if ((*pMatch_len = match_len = probe_len) == max_match_len)
    %%%%%: 3566-block  0
        -: 3567:        return;
    #####: 3568:      c0 = d->m_dict[pos + match_len];
    #####: 3569:      c1 = d->m_dict[pos + match_len - 1];
    %%%%%: 3569-block  0
        -: 3570:    }
        -: 3571:  }
        -: 3572:}
        -: 3573:#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
        -: 3574:
        -: 3575:#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
        -: 3576:static mz_bool tdefl_compress_fast(tdefl_compressor *d) {
        -: 3577:  // Faster, minimally featured LZRW1-style match+parse loop with better
        -: 3578:  // register utilization. Intended for applications where raw throughput is
        -: 3579:  // valued more highly than ratio.
        -: 3580:  mz_uint lookahead_pos = d->m_lookahead_pos,
        -: 3581:          lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size,
        -: 3582:          total_lz_bytes = d->m_total_lz_bytes,
        -: 3583:          num_flags_left = d->m_num_flags_left;
        -: 3584:  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
        -: 3585:  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
        -: 3586:
        -: 3587:  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size))) {
        -: 3588:    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
        -: 3589:    mz_uint dst_pos =
        -: 3590:        (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
        -: 3591:    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(
        -: 3592:        d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
        -: 3593:    d->m_src_buf_left -= num_bytes_to_process;
        -: 3594:    lookahead_size += num_bytes_to_process;
        -: 3595:
        -: 3596:    while (num_bytes_to_process) {
        -: 3597:      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
        -: 3598:      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
        -: 3599:      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
        -: 3600:        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc,
        -: 3601:               MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
        -: 3602:      d->m_pSrc += n;
        -: 3603:      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
        -: 3604:      num_bytes_to_process -= n;
        -: 3605:    }
        -: 3606:
        -: 3607:    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
        -: 3608:    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
        -: 3609:      break;
        -: 3610:
        -: 3611:    while (lookahead_size >= 4) {
        -: 3612:      mz_uint cur_match_dist, cur_match_len = 1;
        -: 3613:      mz_uint8 *pCur_dict = d->m_dict + cur_pos;
        -: 3614:      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;
        -: 3615:      mz_uint hash =
        -: 3616:          (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) &
        -: 3617:          TDEFL_LEVEL1_HASH_SIZE_MASK;
        -: 3618:      mz_uint probe_pos = d->m_hash[hash];
        -: 3619:      d->m_hash[hash] = (mz_uint16)lookahead_pos;
        -: 3620:
        -: 3621:      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <=
        -: 3622:           dict_size) &&
        -: 3623:          ((*(const mz_uint32 *)(d->m_dict +
        -: 3624:                                 (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) &
        -: 3625:            0xFFFFFF) == first_trigram)) {
        -: 3626:        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
        -: 3627:        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
        -: 3628:        mz_uint32 probe_len = 32;
        -: 3629:        do {
        -: 3630:        } while ((TDEFL_READ_UNALIGNED_WORD(++p) ==
        -: 3631:                  TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3632:                 (TDEFL_READ_UNALIGNED_WORD(++p) ==
        -: 3633:                  TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3634:                 (TDEFL_READ_UNALIGNED_WORD(++p) ==
        -: 3635:                  TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3636:                 (TDEFL_READ_UNALIGNED_WORD(++p) ==
        -: 3637:                  TDEFL_READ_UNALIGNED_WORD(++q)) &&
        -: 3638:                 (--probe_len > 0));
        -: 3639:        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) +
        -: 3640:                        (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
        -: 3641:        if (!probe_len)
        -: 3642:          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;
        -: 3643:
        -: 3644:        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) ||
        -: 3645:            ((cur_match_len == TDEFL_MIN_MATCH_LEN) &&
        -: 3646:             (cur_match_dist >= 8U * 1024U))) {
        -: 3647:          cur_match_len = 1;
        -: 3648:          *pLZ_code_buf++ = (mz_uint8)first_trigram;
        -: 3649:          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
        -: 3650:          d->m_huff_count[0][(mz_uint8)first_trigram]++;
        -: 3651:        } else {
        -: 3652:          mz_uint32 s0, s1;
        -: 3653:          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);
        -: 3654:
        -: 3655:          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) &&
        -: 3656:                    (cur_match_dist >= 1) &&
        -: 3657:                    (cur_match_dist <= TDEFL_LZ_DICT_SIZE));
        -: 3658:
        -: 3659:          cur_match_dist--;
        -: 3660:
        -: 3661:          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
        -: 3662:          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
        -: 3663:          pLZ_code_buf += 3;
        -: 3664:          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);
        -: 3665:
        -: 3666:          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
        -: 3667:          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
        -: 3668:          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;
        -: 3669:
        -: 3670:          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len -
        -: 3671:                                             TDEFL_MIN_MATCH_LEN]]++;
        -: 3672:        }
        -: 3673:      } else {
        -: 3674:        *pLZ_code_buf++ = (mz_uint8)first_trigram;
        -: 3675:        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
        -: 3676:        d->m_huff_count[0][(mz_uint8)first_trigram]++;
        -: 3677:      }
        -: 3678:
        -: 3679:      if (--num_flags_left == 0) {
        -: 3680:        num_flags_left = 8;
        -: 3681:        pLZ_flags = pLZ_code_buf++;
        -: 3682:      }
        -: 3683:
        -: 3684:      total_lz_bytes += cur_match_len;
        -: 3685:      lookahead_pos += cur_match_len;
        -: 3686:      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);
        -: 3687:      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
        -: 3688:      MZ_ASSERT(lookahead_size >= cur_match_len);
        -: 3689:      lookahead_size -= cur_match_len;
        -: 3690:
        -: 3691:      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
        -: 3692:        int n;
        -: 3693:        d->m_lookahead_pos = lookahead_pos;
        -: 3694:        d->m_lookahead_size = lookahead_size;
        -: 3695:        d->m_dict_size = dict_size;
        -: 3696:        d->m_total_lz_bytes = total_lz_bytes;
        -: 3697:        d->m_pLZ_code_buf = pLZ_code_buf;
        -: 3698:        d->m_pLZ_flags = pLZ_flags;
        -: 3699:        d->m_num_flags_left = num_flags_left;
        -: 3700:        if ((n = tdefl_flush_block(d, 0)) != 0)
        -: 3701:          return (n < 0) ? MZ_FALSE : MZ_TRUE;
        -: 3702:        total_lz_bytes = d->m_total_lz_bytes;
        -: 3703:        pLZ_code_buf = d->m_pLZ_code_buf;
        -: 3704:        pLZ_flags = d->m_pLZ_flags;
        -: 3705:        num_flags_left = d->m_num_flags_left;
        -: 3706:      }
        -: 3707:    }
        -: 3708:
        -: 3709:    while (lookahead_size) {
        -: 3710:      mz_uint8 lit = d->m_dict[cur_pos];
        -: 3711:
        -: 3712:      total_lz_bytes++;
        -: 3713:      *pLZ_code_buf++ = lit;
        -: 3714:      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
        -: 3715:      if (--num_flags_left == 0) {
        -: 3716:        num_flags_left = 8;
        -: 3717:        pLZ_flags = pLZ_code_buf++;
        -: 3718:      }
        -: 3719:
        -: 3720:      d->m_huff_count[0][lit]++;
        -: 3721:
        -: 3722:      lookahead_pos++;
        -: 3723:      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);
        -: 3724:      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
        -: 3725:      lookahead_size--;
        -: 3726:
        -: 3727:      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
        -: 3728:        int n;
        -: 3729:        d->m_lookahead_pos = lookahead_pos;
        -: 3730:        d->m_lookahead_size = lookahead_size;
        -: 3731:        d->m_dict_size = dict_size;
        -: 3732:        d->m_total_lz_bytes = total_lz_bytes;
        -: 3733:        d->m_pLZ_code_buf = pLZ_code_buf;
        -: 3734:        d->m_pLZ_flags = pLZ_flags;
        -: 3735:        d->m_num_flags_left = num_flags_left;
        -: 3736:        if ((n = tdefl_flush_block(d, 0)) != 0)
        -: 3737:          return (n < 0) ? MZ_FALSE : MZ_TRUE;
        -: 3738:        total_lz_bytes = d->m_total_lz_bytes;
        -: 3739:        pLZ_code_buf = d->m_pLZ_code_buf;
        -: 3740:        pLZ_flags = d->m_pLZ_flags;
        -: 3741:        num_flags_left = d->m_num_flags_left;
        -: 3742:      }
        -: 3743:    }
        -: 3744:  }
        -: 3745:
        -: 3746:  d->m_lookahead_pos = lookahead_pos;
        -: 3747:  d->m_lookahead_size = lookahead_size;
        -: 3748:  d->m_dict_size = dict_size;
        -: 3749:  d->m_total_lz_bytes = total_lz_bytes;
        -: 3750:  d->m_pLZ_code_buf = pLZ_code_buf;
        -: 3751:  d->m_pLZ_flags = pLZ_flags;
        -: 3752:  d->m_num_flags_left = num_flags_left;
        -: 3753:  return MZ_TRUE;
        -: 3754:}
        -: 3755:#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
        -: 3756:
    #####: 3757:static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d,
        -: 3758:                                                mz_uint8 lit) {
    #####: 3759:  d->m_total_lz_bytes++;
    #####: 3760:  *d->m_pLZ_code_buf++ = lit;
    #####: 3761:  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
    #####: 3762:  if (--d->m_num_flags_left == 0) {
    #####: 3763:    d->m_num_flags_left = 8;
    #####: 3764:    d->m_pLZ_flags = d->m_pLZ_code_buf++;
    %%%%%: 3764-block  0
    %%%%%: 3764-block  1
        -: 3765:  }
    #####: 3766:  d->m_huff_count[0][lit]++;
    #####: 3767:}
    %%%%%: 3767-block  0
        -: 3768:
        -: 3769:static MZ_FORCEINLINE void
    #####: 3770:tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist) {
    #####: 3771:  mz_uint32 s0, s1;
        -: 3772:
    #####: 3773:  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) &&
    %%%%%: 3773-block  0
    %%%%%: 3773-block  1
    %%%%%: 3773-block  2
    %%%%%: 3773-block  3
    %%%%%: 3773-block  4
    %%%%%: 3773-block  5
        -: 3774:            (match_dist <= TDEFL_LZ_DICT_SIZE));
        -: 3775:
    #####: 3776:  d->m_total_lz_bytes += match_len;
        -: 3777:
    #####: 3778:  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);
        -: 3779:
    #####: 3780:  match_dist -= 1;
    #####: 3781:  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
    #####: 3782:  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
    #####: 3783:  d->m_pLZ_code_buf += 3;
        -: 3784:
    #####: 3785:  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
    #####: 3786:  if (--d->m_num_flags_left == 0) {
    %%%%%: 3786-block  0
    %%%%%: 3786-block  1
    %%%%%: 3786-block  2
    #####: 3787:    d->m_num_flags_left = 8;
    #####: 3788:    d->m_pLZ_flags = d->m_pLZ_code_buf++;
    %%%%%: 3788-block  0
    %%%%%: 3788-block  1
    %%%%%: 3788-block  2
        -: 3789:  }
        -: 3790:
    #####: 3791:  s0 = s_tdefl_small_dist_sym[match_dist & 511];
    #####: 3792:  s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
    #####: 3793:  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
    %%%%%: 3793-block  0
    %%%%%: 3793-block  1
    %%%%%: 3793-block  2
        -: 3794:
    #####: 3795:  if (match_len >= TDEFL_MIN_MATCH_LEN)
    #####: 3796:    d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
        -: 3797:}
        -: 3798:
    #####: 3799:static mz_bool tdefl_compress_normal(tdefl_compressor *d) {
    #####: 3800:  const mz_uint8 *pSrc = d->m_pSrc;
    #####: 3801:  size_t src_buf_left = d->m_src_buf_left;
    #####: 3802:  tdefl_flush flush = d->m_flush;
    %%%%%: 3802-block  0
        -: 3803:
    #####: 3804:  while ((src_buf_left) || ((flush) && (d->m_lookahead_size))) {
    %%%%%: 3804-block  0
    %%%%%: 3804-block  1
    %%%%%: 3804-block  2
    #####: 3805:    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
        -: 3806:    // Update dictionary and hash chains. Keeps the lookahead size equal to
        -: 3807:    // TDEFL_MAX_MATCH_LEN.
    #####: 3808:    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1)) {
    %%%%%: 3808-block  0
    #####: 3809:      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &
        -: 3810:                        TDEFL_LZ_DICT_SIZE_MASK,
    #####: 3811:              ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
    #####: 3812:      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]
    #####: 3813:                      << TDEFL_LZ_HASH_SHIFT) ^
    #####: 3814:                     d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
    #####: 3815:      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(
        -: 3816:          src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
    #####: 3817:      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;
    #####: 3818:      src_buf_left -= num_bytes_to_process;
    #####: 3819:      d->m_lookahead_size += num_bytes_to_process;
    %%%%%: 3819-block  0
    #####: 3820:      while (pSrc != pSrc_end) {
    %%%%%: 3820-block  0
    #####: 3821:        mz_uint8 c = *pSrc++;
    #####: 3822:        d->m_dict[dst_pos] = c;
    #####: 3823:        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
    %%%%%: 3823-block  0
    #####: 3824:          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
    %%%%%: 3824-block  0
    #####: 3825:        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
    #####: 3826:        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
    #####: 3827:        d->m_hash[hash] = (mz_uint16)(ins_pos);
    #####: 3828:        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
    #####: 3829:        ins_pos++;
    %%%%%: 3829-block  0
        -: 3830:      }
        -: 3831:    } else {
    #####: 3832:      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) {
    %%%%%: 3832-block  0
    %%%%%: 3832-block  1
    #####: 3833:        mz_uint8 c = *pSrc++;
    #####: 3834:        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &
        -: 3835:                          TDEFL_LZ_DICT_SIZE_MASK;
    #####: 3836:        src_buf_left--;
    #####: 3837:        d->m_dict[dst_pos] = c;
    #####: 3838:        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
    %%%%%: 3838-block  0
    #####: 3839:          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
    %%%%%: 3839-block  0
    #####: 3840:        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN) {
    %%%%%: 3840-block  0
    #####: 3841:          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
    #####: 3842:          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]
    #####: 3843:                           << (TDEFL_LZ_HASH_SHIFT * 2)) ^
    #####: 3844:                          (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK]
    #####: 3845:                           << TDEFL_LZ_HASH_SHIFT) ^
    #####: 3846:                          c) &
        -: 3847:                         (TDEFL_LZ_HASH_SIZE - 1);
    #####: 3848:          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
    #####: 3849:          d->m_hash[hash] = (mz_uint16)(ins_pos);
    %%%%%: 3849-block  0
        -: 3850:        }
        -: 3851:      }
        -: 3852:    }
    #####: 3853:    d->m_dict_size =
    #####: 3854:        MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
    #####: 3855:    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
    %%%%%: 3855-block  0
    %%%%%: 3855-block  1
        -: 3856:      break;
        -: 3857:
        -: 3858:    // Simple lazy/greedy parsing state machine.
    #####: 3859:    len_to_move = 1;
    #####: 3860:    cur_match_dist = 0;
    #####: 3861:    cur_match_len =
    #####: 3862:        d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
    %%%%%: 3862-block  0
    #####: 3863:    cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
    #####: 3864:    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {
    %%%%%: 3864-block  0
    #####: 3865:      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) {
    %%%%%: 3865-block  0
    %%%%%: 3865-block  1
    #####: 3866:        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
    #####: 3867:        cur_match_len = 0;
    %%%%%: 3867-block  0
    #####: 3868:        while (cur_match_len < d->m_lookahead_size) {
    %%%%%: 3868-block  0
    #####: 3869:          if (d->m_dict[cur_pos + cur_match_len] != c)
    %%%%%: 3869-block  0
        -: 3870:            break;
    #####: 3871:          cur_match_len++;
    %%%%%: 3871-block  0
        -: 3872:        }
    #####: 3873:        if (cur_match_len < TDEFL_MIN_MATCH_LEN)
    %%%%%: 3873-block  0
        -: 3874:          cur_match_len = 0;
        -: 3875:        else
        -: 3876:          cur_match_dist = 1;
        -: 3877:      }
        -: 3878:    } else {
    #####: 3879:      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size,
    %%%%%: 3879-block  0
        -: 3880:                       d->m_lookahead_size, &cur_match_dist, &cur_match_len);
        -: 3881:    }
    #####: 3882:    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) &&
    %%%%%: 3882-block  0
    %%%%%: 3882-block  1
    #####: 3883:         (cur_match_dist >= 8U * 1024U)) ||
    %%%%%: 3883-block  0
    #####: 3884:        (cur_pos == cur_match_dist) ||
    #####: 3885:        ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5))) {
    %%%%%: 3885-block  0
    %%%%%: 3885-block  1
        -: 3886:      cur_match_dist = cur_match_len = 0;
        -: 3887:    }
    #####: 3888:    if (d->m_saved_match_len) {
    %%%%%: 3888-block  0
    #####: 3889:      if (cur_match_len > d->m_saved_match_len) {
    %%%%%: 3889-block  0
    #####: 3890:        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
    %%%%%: 3890-block  0
    #####: 3891:        if (cur_match_len >= 128) {
    %%%%%: 3891-block  0
    #####: 3892:          tdefl_record_match(d, cur_match_len, cur_match_dist);
    %%%%%: 3892-block  0
    #####: 3893:          d->m_saved_match_len = 0;
    #####: 3894:          len_to_move = cur_match_len;
    %%%%%: 3894-block  0
        -: 3895:        } else {
    #####: 3896:          d->m_saved_lit = d->m_dict[cur_pos];
    #####: 3897:          d->m_saved_match_dist = cur_match_dist;
    #####: 3898:          d->m_saved_match_len = cur_match_len;
    %%%%%: 3898-block  0
        -: 3899:        }
        -: 3900:      } else {
    #####: 3901:        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
    %%%%%: 3901-block  0
    #####: 3902:        len_to_move = d->m_saved_match_len - 1;
    #####: 3903:        d->m_saved_match_len = 0;
    %%%%%: 3903-block  0
        -: 3904:      }
    #####: 3905:    } else if (!cur_match_dist)
    %%%%%: 3905-block  0
    #####: 3906:      tdefl_record_literal(d,
    #####: 3907:                           d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
    %%%%%: 3907-block  0
    #####: 3908:    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) ||
    %%%%%: 3908-block  0
    %%%%%: 3908-block  1
    %%%%%: 3908-block  2
        -: 3909:             (cur_match_len >= 128)) {
    #####: 3910:      tdefl_record_match(d, cur_match_len, cur_match_dist);
    %%%%%: 3910-block  0
    #####: 3911:      len_to_move = cur_match_len;
    %%%%%: 3911-block  0
        -: 3912:    } else {
    #####: 3913:      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
    #####: 3914:      d->m_saved_match_dist = cur_match_dist;
    #####: 3915:      d->m_saved_match_len = cur_match_len;
    %%%%%: 3915-block  0
        -: 3916:    }
        -: 3917:    // Move the lookahead forward by len_to_move bytes.
    #####: 3918:    d->m_lookahead_pos += len_to_move;
    #####: 3919:    MZ_ASSERT(d->m_lookahead_size >= len_to_move);
    %%%%%: 3919-block  0
    %%%%%: 3919-block  1
    #####: 3920:    d->m_lookahead_size -= len_to_move;
    #####: 3921:    d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);
        -: 3922:    // Check if it's time to flush the current LZ codes to the internal output
        -: 3923:    // buffer.
    #####: 3924:    if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
    %%%%%: 3924-block  0
    #####: 3925:        ((d->m_total_lz_bytes > 31 * 1024) &&
    %%%%%: 3925-block  0
    #####: 3926:         (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >=
    %%%%%: 3926-block  0
    #####: 3927:           d->m_total_lz_bytes) ||
    #####: 3928:          (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))) {
    %%%%%: 3928-block  0
    #####: 3929:      int n;
    #####: 3930:      d->m_pSrc = pSrc;
    #####: 3931:      d->m_src_buf_left = src_buf_left;
    #####: 3932:      if ((n = tdefl_flush_block(d, 0)) != 0)
    %%%%%: 3932-block  0
    #####: 3933:        return (n < 0) ? MZ_FALSE : MZ_TRUE;
    %%%%%: 3933-block  0
        -: 3934:    }
        -: 3935:  }
        -: 3936:
    #####: 3937:  d->m_pSrc = pSrc;
    #####: 3938:  d->m_src_buf_left = src_buf_left;
    #####: 3939:  return MZ_TRUE;
    %%%%%: 3939-block  0
        -: 3940:}
        -: 3941:
    #####: 3942:static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d) {
    #####: 3943:  if (d->m_pIn_buf_size) {
    %%%%%: 3943-block  0
    #####: 3944:    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
    %%%%%: 3944-block  0
        -: 3945:  }
        -: 3946:
    #####: 3947:  if (d->m_pOut_buf_size) {
    %%%%%: 3947-block  0
    #####: 3948:    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs,
        -: 3949:                      d->m_output_flush_remaining);
    #####: 3950:    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs,
    #####: 3951:           d->m_output_buf + d->m_output_flush_ofs, n);
    %%%%%: 3951-block  0
    #####: 3952:    d->m_output_flush_ofs += (mz_uint)n;
    #####: 3953:    d->m_output_flush_remaining -= (mz_uint)n;
    #####: 3954:    d->m_out_buf_ofs += n;
        -: 3955:
    #####: 3956:    *d->m_pOut_buf_size = d->m_out_buf_ofs;
    %%%%%: 3956-block  0
        -: 3957:  }
        -: 3958:
    #####: 3959:  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE
    %%%%%: 3959-block  0
    %%%%%: 3959-block  1
    #####: 3960:                                                         : TDEFL_STATUS_OKAY;
        -: 3961:}
        -: 3962:
    #####: 3963:tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,
        -: 3964:                            size_t *pIn_buf_size, void *pOut_buf,
        -: 3965:                            size_t *pOut_buf_size, tdefl_flush flush) {
    #####: 3966:  if (!d) {
    %%%%%: 3966-block  0
    #####: 3967:    if (pIn_buf_size)
    %%%%%: 3967-block  0
    #####: 3968:      *pIn_buf_size = 0;
    %%%%%: 3968-block  0
    #####: 3969:    if (pOut_buf_size)
    %%%%%: 3969-block  0
    #####: 3970:      *pOut_buf_size = 0;
    %%%%%: 3970-block  0
    #####: 3971:    return TDEFL_STATUS_BAD_PARAM;
    %%%%%: 3971-block  0
        -: 3972:  }
        -: 3973:
    #####: 3974:  d->m_pIn_buf = pIn_buf;
    #####: 3975:  d->m_pIn_buf_size = pIn_buf_size;
    #####: 3976:  d->m_pOut_buf = pOut_buf;
    #####: 3977:  d->m_pOut_buf_size = pOut_buf_size;
    #####: 3978:  d->m_pSrc = (const mz_uint8 *)(pIn_buf);
    #####: 3979:  d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
    %%%%%: 3979-block  0
    %%%%%: 3979-block  1
    #####: 3980:  d->m_out_buf_ofs = 0;
    #####: 3981:  d->m_flush = flush;
        -: 3982:
    #####: 3983:  if (((d->m_pPut_buf_func != NULL) ==
    #####: 3984:       ((pOut_buf != NULL) || (pOut_buf_size != NULL))) ||
    %%%%%: 3984-block  0
    #####: 3985:      (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
    %%%%%: 3985-block  0
    #####: 3986:      (d->m_wants_to_finish && (flush != TDEFL_FINISH)) ||
    %%%%%: 3986-block  0
    %%%%%: 3986-block  1
    %%%%%: 3986-block  2
    #####: 3987:      (pIn_buf_size && *pIn_buf_size && !pIn_buf) ||
    %%%%%: 3987-block  0
    %%%%%: 3987-block  1
    %%%%%: 3987-block  2
    #####: 3988:      (pOut_buf_size && *pOut_buf_size && !pOut_buf)) {
    %%%%%: 3988-block  0
    %%%%%: 3988-block  1
    #####: 3989:    if (pIn_buf_size)
    %%%%%: 3989-block  0
    #####: 3990:      *pIn_buf_size = 0;
    %%%%%: 3990-block  0
    #####: 3991:    if (pOut_buf_size)
    %%%%%: 3991-block  0
    #####: 3992:      *pOut_buf_size = 0;
    %%%%%: 3992-block  0
    #####: 3993:    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
    %%%%%: 3993-block  0
        -: 3994:  }
    #####: 3995:  d->m_wants_to_finish |= (flush == TDEFL_FINISH);
        -: 3996:
    #####: 3997:  if ((d->m_output_flush_remaining) || (d->m_finished))
    %%%%%: 3997-block  0
    %%%%%: 3997-block  1
    #####: 3998:    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
    %%%%%: 3998-block  0
        -: 3999:
        -: 4000:#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
        -: 4001:  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
        -: 4002:      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
        -: 4003:      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS |
        -: 4004:                      TDEFL_RLE_MATCHES)) == 0)) {
        -: 4005:    if (!tdefl_compress_fast(d))
        -: 4006:      return d->m_prev_return_status;
        -: 4007:  } else
        -: 4008:#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
    #####: 4009:  {
    #####: 4010:    if (!tdefl_compress_normal(d))
    %%%%%: 4010-block  0
    #####: 4011:      return d->m_prev_return_status;
    %%%%%: 4011-block  0
        -: 4012:  }
        -: 4013:
    #####: 4014:  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) &&
    %%%%%: 4014-block  0
    %%%%%: 4014-block  1
        -: 4015:      (pIn_buf))
    #####: 4016:    d->m_adler32 =
    #####: 4017:        (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf,
    #####: 4018:                              d->m_pSrc - (const mz_uint8 *)pIn_buf);
    %%%%%: 4018-block  0
        -: 4019:
    #####: 4020:  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) &&
    %%%%%: 4020-block  0
    %%%%%: 4020-block  1
    %%%%%: 4020-block  2
    #####: 4021:      (!d->m_output_flush_remaining)) {
    %%%%%: 4021-block  0
    #####: 4022:    if (tdefl_flush_block(d, flush) < 0)
    %%%%%: 4022-block  0
    #####: 4023:      return d->m_prev_return_status;
    %%%%%: 4023-block  0
    #####: 4024:    d->m_finished = (flush == TDEFL_FINISH);
    #####: 4025:    if (flush == TDEFL_FULL_FLUSH) {
    %%%%%: 4025-block  0
    #####: 4026:      MZ_CLEAR_OBJ(d->m_hash);
    %%%%%: 4026-block  0
    #####: 4027:      MZ_CLEAR_OBJ(d->m_next);
    #####: 4028:      d->m_dict_size = 0;
    %%%%%: 4028-block  0
        -: 4029:    }
        -: 4030:  }
        -: 4031:
    #####: 4032:  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
    %%%%%: 4032-block  0
        -: 4033:}
        -: 4034:
        -: 4035:tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,
        -: 4036:                                   size_t in_buf_size, tdefl_flush flush) {
        -: 4037:  MZ_ASSERT(d->m_pPut_buf_func);
        -: 4038:  return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
        -: 4039:}
        -: 4040:
    #####: 4041:tdefl_status tdefl_init(tdefl_compressor *d,
        -: 4042:                        tdefl_put_buf_func_ptr pPut_buf_func,
        -: 4043:                        void *pPut_buf_user, int flags) {
    #####: 4044:  d->m_pPut_buf_func = pPut_buf_func;
    #####: 4045:  d->m_pPut_buf_user = pPut_buf_user;
    #####: 4046:  d->m_flags = (mz_uint)(flags);
    #####: 4047:  d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
    #####: 4048:  d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
    #####: 4049:  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
    #####: 4050:  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
    %%%%%: 4050-block  0
    #####: 4051:    MZ_CLEAR_OBJ(d->m_hash);
    %%%%%: 4051-block  0
    #####: 4052:  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size =
    #####: 4053:      d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
    #####: 4054:  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished =
    #####: 4055:      d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
    #####: 4056:  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    #####: 4057:  d->m_pLZ_flags = d->m_lz_code_buf;
    #####: 4058:  d->m_num_flags_left = 8;
    #####: 4059:  d->m_pOutput_buf = d->m_output_buf;
    #####: 4060:  d->m_pOutput_buf_end = d->m_output_buf;
    #####: 4061:  d->m_prev_return_status = TDEFL_STATUS_OKAY;
    #####: 4062:  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
    #####: 4063:  d->m_adler32 = 1;
    #####: 4064:  d->m_pIn_buf = NULL;
    #####: 4065:  d->m_pOut_buf = NULL;
    #####: 4066:  d->m_pIn_buf_size = NULL;
    #####: 4067:  d->m_pOut_buf_size = NULL;
    #####: 4068:  d->m_flush = TDEFL_NO_FLUSH;
    #####: 4069:  d->m_pSrc = NULL;
    #####: 4070:  d->m_src_buf_left = 0;
    #####: 4071:  d->m_out_buf_ofs = 0;
    #####: 4072:  memset(&d->m_huff_count[0][0], 0,
        -: 4073:         sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    #####: 4074:  memset(&d->m_huff_count[1][0], 0,
        -: 4075:         sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
    #####: 4076:  return TDEFL_STATUS_OKAY;
        -: 4077:}
        -: 4078:
        -: 4079:tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d) {
        -: 4080:  return d->m_prev_return_status;
        -: 4081:}
        -: 4082:
    #####: 4083:mz_uint32 tdefl_get_adler32(tdefl_compressor *d) { return d->m_adler32; }
        -: 4084:
        -: 4085:inline mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,
        -: 4086:                                     tdefl_put_buf_func_ptr pPut_buf_func,
        -: 4087:                                     void *pPut_buf_user, int flags) {
        -: 4088:  tdefl_compressor *pComp;
        -: 4089:  mz_bool succeeded;
        -: 4090:  if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
        -: 4091:    return MZ_FALSE;
        -: 4092:  pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
        -: 4093:  if (!pComp)
        -: 4094:    return MZ_FALSE;
        -: 4095:  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) ==
        -: 4096:               TDEFL_STATUS_OKAY);
        -: 4097:  succeeded =
        -: 4098:      succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) ==
        -: 4099:                    TDEFL_STATUS_DONE);
        -: 4100:  MZ_FREE(pComp);
        -: 4101:  return succeeded;
        -: 4102:}
        -: 4103:
        -: 4104:typedef struct {
        -: 4105:  size_t m_size, m_capacity;
        -: 4106:  mz_uint8 *m_pBuf;
        -: 4107:  mz_bool m_expandable;
        -: 4108:} tdefl_output_buffer;
        -: 4109:
        -: 4110:static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len,
        -: 4111:                                          void *pUser) {
        -: 4112:  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
        -: 4113:  size_t new_size = p->m_size + len;
        -: 4114:  if (new_size > p->m_capacity) {
        -: 4115:    size_t new_capacity = p->m_capacity;
        -: 4116:    mz_uint8 *pNew_buf;
        -: 4117:    if (!p->m_expandable)
        -: 4118:      return MZ_FALSE;
        -: 4119:    do {
        -: 4120:      new_capacity = MZ_MAX(128U, new_capacity << 1U);
        -: 4121:    } while (new_size > new_capacity);
        -: 4122:    pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
        -: 4123:    if (!pNew_buf)
        -: 4124:      return MZ_FALSE;
        -: 4125:    p->m_pBuf = pNew_buf;
        -: 4126:    p->m_capacity = new_capacity;
        -: 4127:  }
        -: 4128:  memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
        -: 4129:  p->m_size = new_size;
        -: 4130:  return MZ_TRUE;
        -: 4131:}
        -: 4132:
        -: 4133:inline void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
        -: 4134:                                 size_t *pOut_len, int flags) {
        -: 4135:  tdefl_output_buffer out_buf;
        -: 4136:  MZ_CLEAR_OBJ(out_buf);
        -: 4137:  if (!pOut_len)
        -: 4138:    return MZ_FALSE;
        -: 4139:  else
        -: 4140:    *pOut_len = 0;
        -: 4141:  out_buf.m_expandable = MZ_TRUE;
        -: 4142:  if (!tdefl_compress_mem_to_output(
        -: 4143:          pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        -: 4144:    return NULL;
        -: 4145:  *pOut_len = out_buf.m_size;
        -: 4146:  return out_buf.m_pBuf;
        -: 4147:}
        -: 4148:
        -: 4149:inline size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
        -: 4150:                                 const void *pSrc_buf, size_t src_buf_len,
        -: 4151:                                 int flags) {
        -: 4152:  tdefl_output_buffer out_buf;
        -: 4153:  MZ_CLEAR_OBJ(out_buf);
        -: 4154:  if (!pOut_buf)
        -: 4155:    return 0;
        -: 4156:  out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
        -: 4157:  out_buf.m_capacity = out_buf_len;
        -: 4158:  if (!tdefl_compress_mem_to_output(
        -: 4159:          pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        -: 4160:    return 0;
        -: 4161:  return out_buf.m_size;
        -: 4162:}
        -: 4163:
        -: 4164:#ifndef MINIZ_NO_ZLIB_APIS
        -: 4165:static const mz_uint s_tdefl_num_probes[11] = {0,   1,   6,   32,  16,  32,
        -: 4166:                                               128, 256, 512, 768, 1500};
        -: 4167:
        -: 4168:// level may actually range from [0,10] (10 is a "hidden" max level, where we
        -: 4169:// want a bit more compression and it's fine if throughput to fall off a cliff
        -: 4170:// on some files).
    #####: 4171:inline mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,
        -: 4172:                                                int strategy) {
    #####: 4173:  mz_uint comp_flags =
    #####: 4174:      s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] |
    %%%%%: 4174-block  0
    %%%%%: 4174-block  1
    #####: 4175:      ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
    %%%%%: 4175-block  0
    #####: 4176:  if (window_bits > 0)
    %%%%%: 4176-block  0
    #####: 4177:    comp_flags |= TDEFL_WRITE_ZLIB_HEADER;
    %%%%%: 4177-block  0
        -: 4178:
    #####: 4179:  if (!level)
    %%%%%: 4179-block  0
    #####: 4180:    comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
    %%%%%: 4180-block  0
    #####: 4181:  else if (strategy == MZ_FILTERED)
    %%%%%: 4181-block  0
    #####: 4182:    comp_flags |= TDEFL_FILTER_MATCHES;
    %%%%%: 4182-block  0
    #####: 4183:  else if (strategy == MZ_HUFFMAN_ONLY)
    %%%%%: 4183-block  0
    #####: 4184:    comp_flags &= ~TDEFL_MAX_PROBES_MASK;
    %%%%%: 4184-block  0
    #####: 4185:  else if (strategy == MZ_FIXED)
    %%%%%: 4185-block  0
    #####: 4186:    comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
    %%%%%: 4186-block  0
    #####: 4187:  else if (strategy == MZ_RLE)
    %%%%%: 4187-block  0
    #####: 4188:    comp_flags |= TDEFL_RLE_MATCHES;
    %%%%%: 4188-block  0
        -: 4189:
    #####: 4190:  return comp_flags;
        -: 4191:}
        -: 4192:#endif // MINIZ_NO_ZLIB_APIS
        -: 4193:
        -: 4194:#ifdef _MSC_VER
        -: 4195:#pragma warning(push)
        -: 4196:#pragma warning(disable : 4204) // nonstandard extension used : non-constant
        -: 4197:                                // aggregate initializer (also supported by GNU
        -: 4198:                                // C and C99, so no big deal)
        -: 4199:#endif
        -: 4200:
        -: 4201:// Simple PNG writer function by Alex Evans, 2011. Released into the public
        -: 4202:// domain: https://gist.github.com/908299, more context at
        -: 4203:// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
        -: 4204:// This is actually a modification of Alex's original code so PNG files
        -: 4205:// generated by this function pass pngcheck.
        -: 4206:inline void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,
        -: 4207:                                                 int h, int num_chans,
        -: 4208:                                                 size_t *pLen_out,
        -: 4209:                                                 mz_uint level, mz_bool flip) {
        -: 4210:  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was
        -: 4211:  // defined.
        -: 4212:  static const mz_uint s_tdefl_png_num_probes[11] = {
        -: 4213:      0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};
        -: 4214:  tdefl_compressor *pComp =
        -: 4215:      (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
        -: 4216:  tdefl_output_buffer out_buf;
        -: 4217:  int i, bpl = w * num_chans, y, z;
        -: 4218:  mz_uint32 c;
        -: 4219:  *pLen_out = 0;
        -: 4220:  if (!pComp)
        -: 4221:    return NULL;
        -: 4222:  MZ_CLEAR_OBJ(out_buf);
        -: 4223:  out_buf.m_expandable = MZ_TRUE;
        -: 4224:  out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
        -: 4225:  if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity))) {
        -: 4226:    MZ_FREE(pComp);
        -: 4227:    return NULL;
        -: 4228:  }
        -: 4229:  // write dummy header
        -: 4230:  for (z = 41; z; --z)
        -: 4231:    tdefl_output_buffer_putter(&z, 1, &out_buf);
        -: 4232:  // compress image data
        -: 4233:  tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf,
        -: 4234:             s_tdefl_png_num_probes[MZ_MIN(10, level)] |
        -: 4235:                 TDEFL_WRITE_ZLIB_HEADER);
        -: 4236:  for (y = 0; y < h; ++y) {
        -: 4237:    tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
        -: 4238:    tdefl_compress_buffer(pComp,
        -: 4239:                          (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl,
        -: 4240:                          bpl, TDEFL_NO_FLUSH);
        -: 4241:  }
        -: 4242:  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) !=
        -: 4243:      TDEFL_STATUS_DONE) {
        -: 4244:    MZ_FREE(pComp);
        -: 4245:    MZ_FREE(out_buf.m_pBuf);
        -: 4246:    return NULL;
        -: 4247:  }
        -: 4248:  // write real header
        -: 4249:  *pLen_out = out_buf.m_size - 41;
        -: 4250:  {
        -: 4251:    static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
        -: 4252:    mz_uint8 pnghdr[41] = {
        -: 4253:        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
        -: 4254:        0x49, 0x48, 0x44, 0x52, 0, 0, (mz_uint8)(w >> 8), (mz_uint8)w, 0, 0,
        -: 4255:        (mz_uint8)(h >> 8), (mz_uint8)h, 8, chans[num_chans], 0, 0, 0, 0, 0, 0,
        -: 4256:        0, (mz_uint8)(*pLen_out >> 24), (mz_uint8)(*pLen_out >> 16),
        -: 4257:        (mz_uint8)(*pLen_out >> 8), (mz_uint8)*pLen_out, 0x49, 0x44, 0x41,
        -: 4258:        0x54};
        -: 4259:    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
        -: 4260:    for (i = 0; i < 4; ++i, c <<= 8)
        -: 4261:      ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
        -: 4262:    memcpy(out_buf.m_pBuf, pnghdr, 41);
        -: 4263:  }
        -: 4264:  // write footer (IDAT CRC-32, followed by IEND chunk)
        -: 4265:  if (!tdefl_output_buffer_putter(
        -: 4266:          "\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) {
        -: 4267:    *pLen_out = 0;
        -: 4268:    MZ_FREE(pComp);
        -: 4269:    MZ_FREE(out_buf.m_pBuf);
        -: 4270:    return NULL;
        -: 4271:  }
        -: 4272:  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4,
        -: 4273:                          *pLen_out + 4);
        -: 4274:  for (i = 0; i < 4; ++i, c <<= 8)
        -: 4275:    (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
        -: 4276:  // compute final size of file, grab compressed data buffer and return
        -: 4277:  *pLen_out += 57;
        -: 4278:  MZ_FREE(pComp);
        -: 4279:  return out_buf.m_pBuf;
        -: 4280:}
        -: 4281:inline void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,
        -: 4282:                                              int num_chans, size_t *pLen_out) {
        -: 4283:  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we
        -: 4284:  // can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's
        -: 4285:  // where #defined out)
        -: 4286:  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans,
        -: 4287:                                                    pLen_out, 6, MZ_FALSE);
        -: 4288:}
        -: 4289:
        -: 4290:#ifdef _MSC_VER
        -: 4291:#pragma warning(pop)
        -: 4292:#endif
        -: 4293:
        -: 4294:// ------------------- .ZIP archive reading
        -: 4295:
        -: 4296:#ifndef MINIZ_NO_ARCHIVE_APIS
        -: 4297:
        -: 4298:#ifdef MINIZ_NO_STDIO
        -: 4299:#define MZ_FILE void *
        -: 4300:#else
        -: 4301:#include <stdio.h>
        -: 4302:#include <sys/stat.h>
        -: 4303:
        -: 4304:#if defined(_MSC_VER) || defined(__MINGW64__)
        -: 4305:static FILE *mz_fopen(const char *pFilename, const char *pMode) {
        -: 4306:  FILE *pFile = NULL;
        -: 4307:  fopen_s(&pFile, pFilename, pMode);
        -: 4308:  return pFile;
        -: 4309:}
        -: 4310:static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream) {
        -: 4311:  FILE *pFile = NULL;
        -: 4312:  if (freopen_s(&pFile, pPath, pMode, pStream))
        -: 4313:    return NULL;
        -: 4314:  return pFile;
        -: 4315:}
        -: 4316:#ifndef MINIZ_NO_TIME
        -: 4317:#include <sys/utime.h>
        -: 4318:#endif
        -: 4319:#define MZ_FILE FILE
        -: 4320:#define MZ_FOPEN mz_fopen
        -: 4321:#define MZ_FCLOSE fclose
        -: 4322:#define MZ_FREAD fread
        -: 4323:#define MZ_FWRITE fwrite
        -: 4324:#define MZ_FTELL64 _ftelli64
        -: 4325:#define MZ_FSEEK64 _fseeki64
        -: 4326:#define MZ_FILE_STAT_STRUCT _stat
        -: 4327:#define MZ_FILE_STAT _stat
        -: 4328:#define MZ_FFLUSH fflush
        -: 4329:#define MZ_FREOPEN mz_freopen
        -: 4330:#define MZ_DELETE_FILE remove
        -: 4331:#elif defined(__MINGW32__)
        -: 4332:#ifndef MINIZ_NO_TIME
        -: 4333:#include <sys/utime.h>
        -: 4334:#endif
        -: 4335:#define MZ_FILE FILE
        -: 4336:#define MZ_FOPEN(f, m) fopen(f, m)
        -: 4337:#define MZ_FCLOSE fclose
        -: 4338:#define MZ_FREAD fread
        -: 4339:#define MZ_FWRITE fwrite
        -: 4340:#define MZ_FTELL64 ftello64
        -: 4341:#define MZ_FSEEK64 fseeko64
        -: 4342:#define MZ_FILE_STAT_STRUCT _stat
        -: 4343:#define MZ_FILE_STAT _stat
        -: 4344:#define MZ_FFLUSH fflush
        -: 4345:#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
        -: 4346:#define MZ_DELETE_FILE remove
        -: 4347:#elif defined(__TINYC__)
        -: 4348:#ifndef MINIZ_NO_TIME
        -: 4349:#include <sys/utime.h>
        -: 4350:#endif
        -: 4351:#define MZ_FILE FILE
        -: 4352:#define MZ_FOPEN(f, m) fopen(f, m)
        -: 4353:#define MZ_FCLOSE fclose
        -: 4354:#define MZ_FREAD fread
        -: 4355:#define MZ_FWRITE fwrite
        -: 4356:#define MZ_FTELL64 ftell
        -: 4357:#define MZ_FSEEK64 fseek
        -: 4358:#define MZ_FILE_STAT_STRUCT stat
        -: 4359:#define MZ_FILE_STAT stat
        -: 4360:#define MZ_FFLUSH fflush
        -: 4361:#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
        -: 4362:#define MZ_DELETE_FILE remove
        -: 4363:#elif defined(__GNUC__) && _LARGEFILE64_SOURCE
        -: 4364:#ifndef MINIZ_NO_TIME
        -: 4365:#include <utime.h>
        -: 4366:#endif
        -: 4367:#define MZ_FILE FILE
        -: 4368:#define MZ_FOPEN(f, m) fopen64(f, m)
        -: 4369:#define MZ_FCLOSE fclose
        -: 4370:#define MZ_FREAD fread
        -: 4371:#define MZ_FWRITE fwrite
        -: 4372:#define MZ_FTELL64 ftello64
        -: 4373:#define MZ_FSEEK64 fseeko64
        -: 4374:#define MZ_FILE_STAT_STRUCT stat64
        -: 4375:#define MZ_FILE_STAT stat64
        -: 4376:#define MZ_FFLUSH fflush
        -: 4377:#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
        -: 4378:#define MZ_DELETE_FILE remove
        -: 4379:#else
        -: 4380:#ifndef MINIZ_NO_TIME
        -: 4381:#include <utime.h>
        -: 4382:#endif
        -: 4383:#define MZ_FILE FILE
        -: 4384:#define MZ_FOPEN(f, m) fopen(f, m)
        -: 4385:#define MZ_FCLOSE fclose
        -: 4386:#define MZ_FREAD fread
        -: 4387:#define MZ_FWRITE fwrite
        -: 4388:#define MZ_FTELL64 ftello
        -: 4389:#define MZ_FSEEK64 fseeko
        -: 4390:#define MZ_FILE_STAT_STRUCT stat
        -: 4391:#define MZ_FILE_STAT stat
        -: 4392:#define MZ_FFLUSH fflush
        -: 4393:#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
        -: 4394:#define MZ_DELETE_FILE remove
        -: 4395:#endif // #ifdef _MSC_VER
        -: 4396:#endif // #ifdef MINIZ_NO_STDIO
        -: 4397:
        -: 4398:#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))
        -: 4399:
        -: 4400:// Various ZIP archive enums. To completely avoid cross platform compiler
        -: 4401:// alignment and platform endian issues, miniz.c doesn't use structs for any of
        -: 4402:// this stuff.
        -: 4403:enum {
        -: 4404:  // ZIP archive identifiers and record sizes
        -: 4405:  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
        -: 4406:  MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
        -: 4407:  MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
        -: 4408:  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
        -: 4409:  MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
        -: 4410:  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
        -: 4411:  // Central directory header record offsets
        -: 4412:  MZ_ZIP_CDH_SIG_OFS = 0,
        -: 4413:  MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
        -: 4414:  MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
        -: 4415:  MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
        -: 4416:  MZ_ZIP_CDH_METHOD_OFS = 10,
        -: 4417:  MZ_ZIP_CDH_FILE_TIME_OFS = 12,
        -: 4418:  MZ_ZIP_CDH_FILE_DATE_OFS = 14,
        -: 4419:  MZ_ZIP_CDH_CRC32_OFS = 16,
        -: 4420:  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
        -: 4421:  MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
        -: 4422:  MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
        -: 4423:  MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
        -: 4424:  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
        -: 4425:  MZ_ZIP_CDH_DISK_START_OFS = 34,
        -: 4426:  MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
        -: 4427:  MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
        -: 4428:  MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
        -: 4429:  // Local directory header offsets
        -: 4430:  MZ_ZIP_LDH_SIG_OFS = 0,
        -: 4431:  MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
        -: 4432:  MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
        -: 4433:  MZ_ZIP_LDH_METHOD_OFS = 8,
        -: 4434:  MZ_ZIP_LDH_FILE_TIME_OFS = 10,
        -: 4435:  MZ_ZIP_LDH_FILE_DATE_OFS = 12,
        -: 4436:  MZ_ZIP_LDH_CRC32_OFS = 14,
        -: 4437:  MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
        -: 4438:  MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
        -: 4439:  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
        -: 4440:  MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
        -: 4441:  // End of central directory offsets
        -: 4442:  MZ_ZIP_ECDH_SIG_OFS = 0,
        -: 4443:  MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
        -: 4444:  MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
        -: 4445:  MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
        -: 4446:  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
        -: 4447:  MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
        -: 4448:  MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
        -: 4449:  MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
        -: 4450:};
        -: 4451:
        -: 4452:typedef struct {
        -: 4453:  void *m_p;
        -: 4454:  size_t m_size, m_capacity;
        -: 4455:  mz_uint m_element_size;
        -: 4456:} mz_zip_array;
        -: 4457:
        -: 4458:struct mz_zip_internal_state_tag {
        -: 4459:  mz_zip_array m_central_dir;
        -: 4460:  mz_zip_array m_central_dir_offsets;
        -: 4461:  mz_zip_array m_sorted_central_dir_offsets;
        -: 4462:  MZ_FILE *m_pFile;
        -: 4463:  void *m_pMem;
        -: 4464:  size_t m_mem_size;
        -: 4465:  size_t m_mem_capacity;
        -: 4466:};
        -: 4467:
        -: 4468:#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size)                 \
        -: 4469:  (array_ptr)->m_element_size = element_size
        -: 4470:#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index)                   \
        -: 4471:  ((element_type *)((array_ptr)->m_p))[index]
        -: 4472:
        -: 4473:static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip,
        -: 4474:                                              mz_zip_array *pArray) {
        -: 4475:  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
        -: 4476:  memset(pArray, 0, sizeof(mz_zip_array));
        -: 4477:}
        -: 4478:
        -: 4479:static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip,
        -: 4480:                                            mz_zip_array *pArray,
        -: 4481:                                            size_t min_new_capacity,
        -: 4482:                                            mz_uint growing) {
        -: 4483:  void *pNew_p;
        -: 4484:  size_t new_capacity = min_new_capacity;
        -: 4485:  MZ_ASSERT(pArray->m_element_size);
        -: 4486:  if (pArray->m_capacity >= min_new_capacity)
        -: 4487:    return MZ_TRUE;
        -: 4488:  if (growing) {
        -: 4489:    new_capacity = MZ_MAX(1, pArray->m_capacity);
        -: 4490:    while (new_capacity < min_new_capacity)
        -: 4491:      new_capacity *= 2;
        -: 4492:  }
        -: 4493:  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p,
        -: 4494:                                         pArray->m_element_size, new_capacity)))
        -: 4495:    return MZ_FALSE;
        -: 4496:  pArray->m_p = pNew_p;
        -: 4497:  pArray->m_capacity = new_capacity;
        -: 4498:  return MZ_TRUE;
        -: 4499:}
        -: 4500:
        -: 4501:static MZ_FORCEINLINE mz_bool
        -: 4502:mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray,
        -: 4503:                     size_t new_capacity, mz_uint growing) {
        -: 4504:  if (new_capacity > pArray->m_capacity) {
        -: 4505:    if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
        -: 4506:      return MZ_FALSE;
        -: 4507:  }
        -: 4508:  return MZ_TRUE;
        -: 4509:}
        -: 4510:
        -: 4511:static MZ_FORCEINLINE mz_bool
        -: 4512:mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size,
        -: 4513:                    mz_uint growing) {
        -: 4514:  if (new_size > pArray->m_capacity) {
        -: 4515:    if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
        -: 4516:      return MZ_FALSE;
        -: 4517:  }
        -: 4518:  pArray->m_size = new_size;
        -: 4519:  return MZ_TRUE;
        -: 4520:}
        -: 4521:
        -: 4522:static MZ_FORCEINLINE mz_bool
        -: 4523:mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n) {
        -: 4524:  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
        -: 4525:}
        -: 4526:
        -: 4527:static MZ_FORCEINLINE mz_bool
        -: 4528:mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray,
        -: 4529:                       const void *pElements, size_t n) {
        -: 4530:  size_t orig_size = pArray->m_size;
        -: 4531:  if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
        -: 4532:    return MZ_FALSE;
        -: 4533:  memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size,
        -: 4534:         pElements, n * pArray->m_element_size);
        -: 4535:  return MZ_TRUE;
        -: 4536:}
        -: 4537:
        -: 4538:#ifndef MINIZ_NO_TIME
        -: 4539:static time_t mz_zip_dos_to_time_t(int dos_time, int dos_date) {
        -: 4540:  struct tm tm;
        -: 4541:  memset(&tm, 0, sizeof(tm));
        -: 4542:  tm.tm_isdst = -1;
        -: 4543:  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
        -: 4544:  tm.tm_mon = ((dos_date >> 5) & 15) - 1;
        -: 4545:  tm.tm_mday = dos_date & 31;
        -: 4546:  tm.tm_hour = (dos_time >> 11) & 31;
        -: 4547:  tm.tm_min = (dos_time >> 5) & 63;
        -: 4548:  tm.tm_sec = (dos_time << 1) & 62;
        -: 4549:  return mktime(&tm);
        -: 4550:}
        -: 4551:
        -: 4552:static void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time,
        -: 4553:                                    mz_uint16 *pDOS_date) {
        -: 4554:#ifdef _MSC_VER
        -: 4555:  struct tm tm_struct;
        -: 4556:  struct tm *tm = &tm_struct;
        -: 4557:  errno_t err = localtime_s(tm, &time);
        -: 4558:  if (err) {
        -: 4559:    *pDOS_date = 0;
        -: 4560:    *pDOS_time = 0;
        -: 4561:    return;
        -: 4562:  }
        -: 4563:#else
        -: 4564:  struct tm *tm = localtime(&time);
        -: 4565:#endif
        -: 4566:  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) +
        -: 4567:                           ((tm->tm_sec) >> 1));
        -: 4568:  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) +
        -: 4569:                           ((tm->tm_mon + 1) << 5) + tm->tm_mday);
        -: 4570:}
        -: 4571:#endif
        -: 4572:
        -: 4573:#ifndef MINIZ_NO_STDIO
        -: 4574:static mz_bool mz_zip_get_file_modified_time(const char *pFilename,
        -: 4575:                                             mz_uint16 *pDOS_time,
        -: 4576:                                             mz_uint16 *pDOS_date) {
        -: 4577:#ifdef MINIZ_NO_TIME
        -: 4578:  (void)pFilename;
        -: 4579:  *pDOS_date = *pDOS_time = 0;
        -: 4580:#else
        -: 4581:  struct MZ_FILE_STAT_STRUCT file_stat;
        -: 4582:  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000
        -: 4583:  // bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.
        -: 4584:  if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
        -: 4585:    return MZ_FALSE;
        -: 4586:  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);
        -: 4587:#endif // #ifdef MINIZ_NO_TIME
        -: 4588:  return MZ_TRUE;
        -: 4589:}
        -: 4590:
        -: 4591:#ifndef MINIZ_NO_TIME
        -: 4592:static mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time,
        -: 4593:                                     time_t modified_time) {
        -: 4594:  struct utimbuf t;
        -: 4595:  t.actime = access_time;
        -: 4596:  t.modtime = modified_time;
        -: 4597:  return !utime(pFilename, &t);
        -: 4598:}
        -: 4599:#endif // #ifndef MINIZ_NO_TIME
        -: 4600:#endif // #ifndef MINIZ_NO_STDIO
        -: 4601:
        -: 4602:static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip,
        -: 4603:                                           mz_uint32 flags) {
        -: 4604:  (void)flags;
        -: 4605:  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
        -: 4606:    return MZ_FALSE;
        -: 4607:
        -: 4608:  if (!pZip->m_pAlloc)
        -: 4609:    pZip->m_pAlloc = def_alloc_func;
        -: 4610:  if (!pZip->m_pFree)
        -: 4611:    pZip->m_pFree = def_free_func;
        -: 4612:  if (!pZip->m_pRealloc)
        -: 4613:    pZip->m_pRealloc = def_realloc_func;
        -: 4614:
        -: 4615:  pZip->m_zip_mode = MZ_ZIP_MODE_READING;
        -: 4616:  pZip->m_archive_size = 0;
        -: 4617:  pZip->m_central_directory_file_ofs = 0;
        -: 4618:  pZip->m_total_files = 0;
        -: 4619:
        -: 4620:  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(
        -: 4621:                   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        -: 4622:    return MZ_FALSE;
        -: 4623:  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
        -: 4624:  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,
        -: 4625:                                sizeof(mz_uint8));
        -: 4626:  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,
        -: 4627:                                sizeof(mz_uint32));
        -: 4628:  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,
        -: 4629:                                sizeof(mz_uint32));
        -: 4630:  return MZ_TRUE;
        -: 4631:}
        -: 4632:
        -: 4633:static MZ_FORCEINLINE mz_bool
        -: 4634:mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array,
        -: 4635:                            const mz_zip_array *pCentral_dir_offsets,
        -: 4636:                            mz_uint l_index, mz_uint r_index) {
        -: 4637:  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(
        -: 4638:                           pCentral_dir_array, mz_uint8,
        -: 4639:                           MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,
        -: 4640:                                                l_index)),
        -: 4641:                 *pE;
        -: 4642:  const mz_uint8 *pR =
        -: 4643:      &MZ_ZIP_ARRAY_ELEMENT(
        -: 4644:          pCentral_dir_array, mz_uint8,
        -: 4645:          MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
        -: 4646:  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS),
        -: 4647:          r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        -: 4648:  mz_uint8 l = 0, r = 0;
        -: 4649:  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        -: 4650:  pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        -: 4651:  pE = pL + MZ_MIN(l_len, r_len);
        -: 4652:  while (pL < pE) {
        -: 4653:    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
        -: 4654:      break;
        -: 4655:    pL++;
        -: 4656:    pR++;
        -: 4657:  }
        -: 4658:  return (pL == pE) ? (l_len < r_len) : (l < r);
        -: 4659:}
        -: 4660:
        -: 4661:#define MZ_SWAP_UINT32(a, b)                                                   \
        -: 4662:  do {                                                                         \
        -: 4663:    mz_uint32 t = a;                                                           \
        -: 4664:    a = b;                                                                     \
        -: 4665:    b = t;                                                                     \
        -: 4666:  }                                                                            \
        -: 4667:  MZ_MACRO_END
        -: 4668:
        -: 4669:// Heap sort of lowercased filenames, used to help accelerate plain central
        -: 4670:// directory searches by mz_zip_reader_locate_file(). (Could also use qsort(),
        -: 4671:// but it could allocate memory.)
        -: 4672:static void
        -: 4673:mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip) {
        -: 4674:  mz_zip_internal_state *pState = pZip->m_pState;
        -: 4675:  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
        -: 4676:  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
        -: 4677:  mz_uint32 *pIndices =
        -: 4678:      &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32,
        -: 4679:                            0);
        -: 4680:  const int size = pZip->m_total_files;
        -: 4681:  int start = (size - 2) >> 1, end;
        -: 4682:  while (start >= 0) {
        -: 4683:    int child, root = start;
        -: 4684:    for (;;) {
        -: 4685:      if ((child = (root << 1) + 1) >= size)
        -: 4686:        break;
        -: 4687:      child +=
        -: 4688:          (((child + 1) < size) &&
        -: 4689:           (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
        -: 4690:                                        pIndices[child], pIndices[child + 1])));
        -: 4691:      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
        -: 4692:                                       pIndices[root], pIndices[child]))
        -: 4693:        break;
        -: 4694:      MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
        -: 4695:      root = child;
        -: 4696:    }
        -: 4697:    start--;
        -: 4698:  }
        -: 4699:
        -: 4700:  end = size - 1;
        -: 4701:  while (end > 0) {
        -: 4702:    int child, root = 0;
        -: 4703:    MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
        -: 4704:    for (;;) {
        -: 4705:      if ((child = (root << 1) + 1) >= end)
        -: 4706:        break;
        -: 4707:      child +=
        -: 4708:          (((child + 1) < end) &&
        -: 4709:           mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
        -: 4710:                                       pIndices[child], pIndices[child + 1]));
        -: 4711:      if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
        -: 4712:                                       pIndices[root], pIndices[child]))
        -: 4713:        break;
        -: 4714:      MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
        -: 4715:      root = child;
        -: 4716:    }
        -: 4717:    end--;
        -: 4718:  }
        -: 4719:}
        -: 4720:
        -: 4721:static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip,
        -: 4722:                                              mz_uint32 flags) {
        -: 4723:  mz_uint cdir_size, num_this_disk, cdir_disk_index;
        -: 4724:  mz_uint64 cdir_ofs;
        -: 4725:  mz_int64 cur_file_ofs;
        -: 4726:  const mz_uint8 *p;
        -: 4727:  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
        -: 4728:  mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
        -: 4729:  mz_bool sort_central_dir =
        -: 4730:      ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
        -: 4731:  // Basic sanity checks - reject files which are too small, and check the first
        -: 4732:  // 4 bytes of the file to make sure a local header is there.
        -: 4733:  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        -: 4734:    return MZ_FALSE;
        -: 4735:  // Find the end of central directory record by scanning the file from the end
        -: 4736:  // towards the beginning.
        -: 4737:  cur_file_ofs =
        -: 4738:      MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
        -: 4739:  for (;;) {
        -: 4740:    int i,
        -: 4741:        n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
        -: 4742:    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
        -: 4743:      return MZ_FALSE;
        -: 4744:    for (i = n - 4; i >= 0; --i)
        -: 4745:      if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
        -: 4746:        break;
        -: 4747:    if (i >= 0) {
        -: 4748:      cur_file_ofs += i;
        -: 4749:      break;
        -: 4750:    }
        -: 4751:    if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >=
        -: 4752:                            (0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
        -: 4753:      return MZ_FALSE;
        -: 4754:    cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
        -: 4755:  }
        -: 4756:  // Read and verify the end of central directory record.
        -: 4757:  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,
        -: 4758:                    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) !=
        -: 4759:      MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        -: 4760:    return MZ_FALSE;
        -: 4761:  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) !=
        -: 4762:       MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||
        -: 4763:      ((pZip->m_total_files =
        -: 4764:            MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) !=
        -: 4765:       MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))
        -: 4766:    return MZ_FALSE;
        -: 4767:
        -: 4768:  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
        -: 4769:  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
        -: 4770:  if (((num_this_disk | cdir_disk_index) != 0) &&
        -: 4771:      ((num_this_disk != 1) || (cdir_disk_index != 1)))
        -: 4772:    return MZ_FALSE;
        -: 4773:
        -: 4774:  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) <
        -: 4775:      pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
        -: 4776:    return MZ_FALSE;
        -: 4777:
        -: 4778:  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
        -: 4779:  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
        -: 4780:    return MZ_FALSE;
        -: 4781:
        -: 4782:  pZip->m_central_directory_file_ofs = cdir_ofs;
        -: 4783:
        -: 4784:  if (pZip->m_total_files) {
        -: 4785:    mz_uint i, n;
        -: 4786:
        -: 4787:    // Read the entire central directory into a heap block, and allocate another
        -: 4788:    // heap block to hold the unsorted central dir file record offsets, and
        -: 4789:    // another to hold the sorted indices.
        -: 4790:    if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size,
        -: 4791:                              MZ_FALSE)) ||
        -: 4792:        (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets,
        -: 4793:                              pZip->m_total_files, MZ_FALSE)))
        -: 4794:      return MZ_FALSE;
        -: 4795:
        -: 4796:    if (sort_central_dir) {
        -: 4797:      if (!mz_zip_array_resize(pZip,
        -: 4798:                               &pZip->m_pState->m_sorted_central_dir_offsets,
        -: 4799:                               pZip->m_total_files, MZ_FALSE))
        -: 4800:        return MZ_FALSE;
        -: 4801:    }
        -: 4802:
        -: 4803:    if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs,
        -: 4804:                      pZip->m_pState->m_central_dir.m_p,
        -: 4805:                      cdir_size) != cdir_size)
        -: 4806:      return MZ_FALSE;
        -: 4807:
        -: 4808:    // Now create an index into the central directory file records, do some
        -: 4809:    // basic sanity checking on each record, and check for zip64 entries (which
        -: 4810:    // are not yet supported).
        -: 4811:    p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
        -: 4812:    for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i) {
        -: 4813:      mz_uint total_header_size, comp_size, decomp_size, disk_index;
        -: 4814:      if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) ||
        -: 4815:          (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
        -: 4816:        return MZ_FALSE;
        -: 4817:      MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,
        -: 4818:                           i) =
        -: 4819:          (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);
        -: 4820:      if (sort_central_dir)
        -: 4821:        MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets,
        -: 4822:                             mz_uint32, i) = i;
        -: 4823:      comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
        -: 4824:      decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
        -: 4825:      if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) &&
        -: 4826:           (decomp_size != comp_size)) ||
        -: 4827:          (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) ||
        -: 4828:          (comp_size == 0xFFFFFFFF))
        -: 4829:        return MZ_FALSE;
        -: 4830:      disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
        -: 4831:      if ((disk_index != num_this_disk) && (disk_index != 1))
        -: 4832:        return MZ_FALSE;
        -: 4833:      if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) +
        -: 4834:           MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
        -: 4835:        return MZ_FALSE;
        -: 4836:      if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
        -: 4837:                               MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +
        -: 4838:                               MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) +
        -: 4839:                               MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) >
        -: 4840:          n)
        -: 4841:        return MZ_FALSE;
        -: 4842:      n -= total_header_size;
        -: 4843:      p += total_header_size;
        -: 4844:    }
        -: 4845:  }
        -: 4846:
        -: 4847:  if (sort_central_dir)
        -: 4848:    mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);
        -: 4849:
        -: 4850:  return MZ_TRUE;
        -: 4851:}
        -: 4852:
        -: 4853:mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,
        -: 4854:                           mz_uint32 flags) {
        -: 4855:  if ((!pZip) || (!pZip->m_pRead))
        -: 4856:    return MZ_FALSE;
        -: 4857:  if (!mz_zip_reader_init_internal(pZip, flags))
        -: 4858:    return MZ_FALSE;
        -: 4859:  pZip->m_archive_size = size;
        -: 4860:  if (!mz_zip_reader_read_central_dir(pZip, flags)) {
        -: 4861:    mz_zip_reader_end(pZip);
        -: 4862:    return MZ_FALSE;
        -: 4863:  }
        -: 4864:  return MZ_TRUE;
        -: 4865:}
        -: 4866:
        -: 4867:static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs,
        -: 4868:                                   void *pBuf, size_t n) {
        -: 4869:  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        -: 4870:  size_t s = (file_ofs >= pZip->m_archive_size)
        -: 4871:                 ? 0
        -: 4872:                 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
        -: 4873:  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
        -: 4874:  return s;
        -: 4875:}
        -: 4876:
        -: 4877:mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,
        -: 4878:                               size_t size, mz_uint32 flags) {
        -: 4879:  if (!mz_zip_reader_init_internal(pZip, flags))
        -: 4880:    return MZ_FALSE;
        -: 4881:  pZip->m_archive_size = size;
        -: 4882:  pZip->m_pRead = mz_zip_mem_read_func;
        -: 4883:  pZip->m_pIO_opaque = pZip;
        -: 4884:#ifdef __cplusplus
        -: 4885:  pZip->m_pState->m_pMem = const_cast<void *>(pMem);
        -: 4886:#else
        -: 4887:  pZip->m_pState->m_pMem = (void *)pMem;
        -: 4888:#endif
        -: 4889:  pZip->m_pState->m_mem_size = size;
        -: 4890:  if (!mz_zip_reader_read_central_dir(pZip, flags)) {
        -: 4891:    mz_zip_reader_end(pZip);
        -: 4892:    return MZ_FALSE;
        -: 4893:  }
        -: 4894:  return MZ_TRUE;
        -: 4895:}
        -: 4896:
        -: 4897:#ifndef MINIZ_NO_STDIO
        -: 4898:static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs,
        -: 4899:                                    void *pBuf, size_t n) {
        -: 4900:  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        -: 4901:  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
        -: 4902:  if (((mz_int64)file_ofs < 0) ||
        -: 4903:      (((cur_ofs != (mz_int64)file_ofs)) &&
        -: 4904:       (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
        -: 4905:    return 0;
        -: 4906:  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
        -: 4907:}
        -: 4908:
        -: 4909:mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,
        -: 4910:                                mz_uint32 flags) {
        -: 4911:  mz_uint64 file_size;
        -: 4912:  MZ_FILE *pFile = MZ_FOPEN(pFilename, "rb");
        -: 4913:  if (!pFile)
        -: 4914:    return MZ_FALSE;
        -: 4915:  if (MZ_FSEEK64(pFile, 0, SEEK_END)) {
        -: 4916:    MZ_FCLOSE(pFile);
        -: 4917:    return MZ_FALSE;
        -: 4918:  }
        -: 4919:  file_size = MZ_FTELL64(pFile);
        -: 4920:  if (!mz_zip_reader_init_internal(pZip, flags)) {
        -: 4921:    MZ_FCLOSE(pFile);
        -: 4922:    return MZ_FALSE;
        -: 4923:  }
        -: 4924:  pZip->m_pRead = mz_zip_file_read_func;
        -: 4925:  pZip->m_pIO_opaque = pZip;
        -: 4926:  pZip->m_pState->m_pFile = pFile;
        -: 4927:  pZip->m_archive_size = file_size;
        -: 4928:  if (!mz_zip_reader_read_central_dir(pZip, flags)) {
        -: 4929:    mz_zip_reader_end(pZip);
        -: 4930:    return MZ_FALSE;
        -: 4931:  }
        -: 4932:  return MZ_TRUE;
        -: 4933:}
        -: 4934:#endif // #ifndef MINIZ_NO_STDIO
        -: 4935:
        -: 4936:mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip) {
        -: 4937:  return pZip ? pZip->m_total_files : 0;
        -: 4938:}
        -: 4939:
        -: 4940:static MZ_FORCEINLINE const mz_uint8 *
        -: 4941:mz_zip_reader_get_cdh(mz_zip_archive *pZip, mz_uint file_index) {
        -: 4942:  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) ||
        -: 4943:      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        -: 4944:    return NULL;
        -: 4945:  return &MZ_ZIP_ARRAY_ELEMENT(
        -: 4946:             &pZip->m_pState->m_central_dir, mz_uint8,
        -: 4947:             MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets,
        -: 4948:                                  mz_uint32, file_index));
        -: 4949:}
        -: 4950:
        -: 4951:mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,
        -: 4952:                                        mz_uint file_index) {
        -: 4953:  mz_uint m_bit_flag;
        -: 4954:  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
        -: 4955:  if (!p)
        -: 4956:    return MZ_FALSE;
        -: 4957:  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
        -: 4958:  return (m_bit_flag & 1);
        -: 4959:}
        -: 4960:
        -: 4961:mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,
        -: 4962:                                          mz_uint file_index) {
        -: 4963:  mz_uint filename_len, external_attr;
        -: 4964:  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
        -: 4965:  if (!p)
        -: 4966:    return MZ_FALSE;
        -: 4967:
        -: 4968:  // First see if the filename ends with a '/' character.
        -: 4969:  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        -: 4970:  if (filename_len) {
        -: 4971:    if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
        -: 4972:      return MZ_TRUE;
        -: 4973:  }
        -: 4974:
        -: 4975:  // Bugfix: This code was also checking if the internal attribute was non-zero,
        -: 4976:  // which wasn't correct.
        -: 4977:  // Most/all zip writers (hopefully) set DOS file/directory attributes in the
        -: 4978:  // low 16-bits, so check for the DOS directory flag and ignore the source OS
        -: 4979:  // ID in the created by field.
        -: 4980:  // FIXME: Remove this check? Is it necessary - we already check the filename.
        -: 4981:  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
        -: 4982:  if ((external_attr & 0x10) != 0)
        -: 4983:    return MZ_TRUE;
        -: 4984:
        -: 4985:  return MZ_FALSE;
        -: 4986:}
        -: 4987:
        -: 4988:mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,
        -: 4989:                                mz_zip_archive_file_stat *pStat) {
        -: 4990:  mz_uint n;
        -: 4991:  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
        -: 4992:  if ((!p) || (!pStat))
        -: 4993:    return MZ_FALSE;
        -: 4994:
        -: 4995:  // Unpack the central directory record.
        -: 4996:  pStat->m_file_index = file_index;
        -: 4997:  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(
        -: 4998:      &pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
        -: 4999:  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
        -: 5000:  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
        -: 5001:  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
        -: 5002:  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
        -: 5003:#ifndef MINIZ_NO_TIME
        -: 5004:  pStat->m_time =
        -: 5005:      mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS),
        -: 5006:                           MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
        -: 5007:#endif
        -: 5008:  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
        -: 5009:  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
        -: 5010:  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
        -: 5011:  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
        -: 5012:  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
        -: 5013:  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
        -: 5014:
        -: 5015:  // Copy as much of the filename and comment as possible.
        -: 5016:  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        -: 5017:  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
        -: 5018:  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
        -: 5019:  pStat->m_filename[n] = '\0';
        -: 5020:
        -: 5021:  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
        -: 5022:  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
        -: 5023:  pStat->m_comment_size = n;
        -: 5024:  memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
        -: 5025:                               MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +
        -: 5026:                               MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS),
        -: 5027:         n);
        -: 5028:  pStat->m_comment[n] = '\0';
        -: 5029:
        -: 5030:  return MZ_TRUE;
        -: 5031:}
        -: 5032:
        -: 5033:mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,
        -: 5034:                                   char *pFilename, mz_uint filename_buf_size) {
        -: 5035:  mz_uint n;
        -: 5036:  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
        -: 5037:  if (!p) {
        -: 5038:    if (filename_buf_size)
        -: 5039:      pFilename[0] = '\0';
        -: 5040:    return 0;
        -: 5041:  }
        -: 5042:  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        -: 5043:  if (filename_buf_size) {
        -: 5044:    n = MZ_MIN(n, filename_buf_size - 1);
        -: 5045:    memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
        -: 5046:    pFilename[n] = '\0';
        -: 5047:  }
        -: 5048:  return n + 1;
        -: 5049:}
        -: 5050:
        -: 5051:static MZ_FORCEINLINE mz_bool
        -: 5052:mz_zip_reader_string_equal(const char *pA, const char *pB, mz_uint len,
        -: 5053:                           mz_uint flags) {
        -: 5054:  mz_uint i;
        -: 5055:  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
        -: 5056:    return 0 == memcmp(pA, pB, len);
        -: 5057:  for (i = 0; i < len; ++i)
        -: 5058:    if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
        -: 5059:      return MZ_FALSE;
        -: 5060:  return MZ_TRUE;
        -: 5061:}
        -: 5062:
        -: 5063:static MZ_FORCEINLINE int
        -: 5064:mz_zip_reader_filename_compare(const mz_zip_array *pCentral_dir_array,
        -: 5065:                               const mz_zip_array *pCentral_dir_offsets,
        -: 5066:                               mz_uint l_index, const char *pR, mz_uint r_len) {
        -: 5067:  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(
        -: 5068:                           pCentral_dir_array, mz_uint8,
        -: 5069:                           MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,
        -: 5070:                                                l_index)),
        -: 5071:                 *pE;
        -: 5072:  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        -: 5073:  mz_uint8 l = 0, r = 0;
        -: 5074:  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        -: 5075:  pE = pL + MZ_MIN(l_len, r_len);
        -: 5076:  while (pL < pE) {
        -: 5077:    if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
        -: 5078:      break;
        -: 5079:    pL++;
        -: 5080:    pR++;
        -: 5081:  }
        -: 5082:  return (pL == pE) ? (int)(l_len - r_len) : (l - r);
        -: 5083:}
        -: 5084:
        -: 5085:static int mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip,
        -: 5086:                                                   const char *pFilename) {
        -: 5087:  mz_zip_internal_state *pState = pZip->m_pState;
        -: 5088:  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
        -: 5089:  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
        -: 5090:  mz_uint32 *pIndices =
        -: 5091:      &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32,
        -: 5092:                            0);
        -: 5093:  const int size = pZip->m_total_files;
        -: 5094:  const mz_uint filename_len = (mz_uint)strlen(pFilename);
        -: 5095:  int l = 0, h = size - 1;
        -: 5096:  while (l <= h) {
        -: 5097:    int m = (l + h) >> 1, file_index = pIndices[m],
        -: 5098:        comp =
        -: 5099:            mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets,
        -: 5100:                                           file_index, pFilename, filename_len);
        -: 5101:    if (!comp)
        -: 5102:      return file_index;
        -: 5103:    else if (comp < 0)
        -: 5104:      l = m + 1;
        -: 5105:    else
        -: 5106:      h = m - 1;
        -: 5107:  }
        -: 5108:  return -1;
        -: 5109:}
        -: 5110:
        -: 5111:int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,
        -: 5112:                              const char *pComment, mz_uint flags) {
        -: 5113:  mz_uint file_index;
        -: 5114:  size_t name_len, comment_len;
        -: 5115:  if ((!pZip) || (!pZip->m_pState) || (!pName) ||
        -: 5116:      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        -: 5117:    return -1;
        -: 5118:  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) &&
        -: 5119:      (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
        -: 5120:    return mz_zip_reader_locate_file_binary_search(pZip, pName);
        -: 5121:  name_len = strlen(pName);
        -: 5122:  if (name_len > 0xFFFF)
        -: 5123:    return -1;
        -: 5124:  comment_len = pComment ? strlen(pComment) : 0;
        -: 5125:  if (comment_len > 0xFFFF)
        -: 5126:    return -1;
        -: 5127:  for (file_index = 0; file_index < pZip->m_total_files; file_index++) {
        -: 5128:    const mz_uint8 *pHeader =
        -: 5129:        &MZ_ZIP_ARRAY_ELEMENT(
        -: 5130:            &pZip->m_pState->m_central_dir, mz_uint8,
        -: 5131:            MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets,
        -: 5132:                                 mz_uint32, file_index));
        -: 5133:    mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        -: 5134:    const char *pFilename =
        -: 5135:        (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        -: 5136:    if (filename_len < name_len)
        -: 5137:      continue;
        -: 5138:    if (comment_len) {
        -: 5139:      mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS),
        -: 5140:              file_comment_len =
        -: 5141:                  MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
        -: 5142:      const char *pFile_comment = pFilename + filename_len + file_extra_len;
        -: 5143:      if ((file_comment_len != comment_len) ||
        -: 5144:          (!mz_zip_reader_string_equal(pComment, pFile_comment,
        -: 5145:                                       file_comment_len, flags)))
        -: 5146:        continue;
        -: 5147:    }
        -: 5148:    if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len)) {
        -: 5149:      int ofs = filename_len - 1;
        -: 5150:      do {
        -: 5151:        if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') ||
        -: 5152:            (pFilename[ofs] == ':'))
        -: 5153:          break;
        -: 5154:      } while (--ofs >= 0);
        -: 5155:      ofs++;
        -: 5156:      pFilename += ofs;
        -: 5157:      filename_len -= ofs;
        -: 5158:    }
        -: 5159:    if ((filename_len == name_len) &&
        -: 5160:        (mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))
        -: 5161:      return file_index;
        -: 5162:  }
        -: 5163:  return -1;
        -: 5164:}
        -: 5165:
        -: 5166:mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,
        -: 5167:                                              mz_uint file_index, void *pBuf,
        -: 5168:                                              size_t buf_size, mz_uint flags,
        -: 5169:                                              void *pUser_read_buf,
        -: 5170:                                              size_t user_read_buf_size) {
        -: 5171:  int status = TINFL_STATUS_DONE;
        -: 5172:  mz_uint64 needed_size, cur_file_ofs, comp_remaining,
        -: 5173:      out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
        -: 5174:  mz_zip_archive_file_stat file_stat;
        -: 5175:  void *pRead_buf;
        -: 5176:  mz_uint32
        -: 5177:      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /
        -: 5178:                       sizeof(mz_uint32)];
        -: 5179:  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
        -: 5180:  tinfl_decompressor inflator;
        -: 5181:
        -: 5182:  if ((buf_size) && (!pBuf))
        -: 5183:    return MZ_FALSE;
        -: 5184:
        -: 5185:  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        -: 5186:    return MZ_FALSE;
        -: 5187:
        -: 5188:  // Empty file, or a directory (but not always a directory - I've seen odd zips
        -: 5189:  // with directories that have compressed data which inflates to 0 bytes)
        -: 5190:  if (!file_stat.m_comp_size)
        -: 5191:    return MZ_TRUE;
        -: 5192:
        -: 5193:  // Entry is a subdirectory (I've seen old zips with dir entries which have
        -: 5194:  // compressed deflate data which inflates to 0 bytes, but these entries claim
        -: 5195:  // to uncompress to 512 bytes in the headers).
        -: 5196:  // I'm torn how to handle this case - should it fail instead?
        -: 5197:  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
        -: 5198:    return MZ_TRUE;
        -: 5199:
        -: 5200:  // Encryption and patch files are not supported.
        -: 5201:  if (file_stat.m_bit_flag & (1 | 32))
        -: 5202:    return MZ_FALSE;
        -: 5203:
        -: 5204:  // This function only supports stored and deflate.
        -: 5205:  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&
        -: 5206:      (file_stat.m_method != MZ_DEFLATED))
        -: 5207:    return MZ_FALSE;
        -: 5208:
        -: 5209:  // Ensure supplied output buffer is large enough.
        -: 5210:  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size
        -: 5211:                                                      : file_stat.m_uncomp_size;
        -: 5212:  if (buf_size < needed_size)
        -: 5213:    return MZ_FALSE;
        -: 5214:
        -: 5215:  // Read and parse the local directory entry.
        -: 5216:  cur_file_ofs = file_stat.m_local_header_ofs;
        -: 5217:  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,
        -: 5218:                    MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
        -: 5219:      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        -: 5220:    return MZ_FALSE;
        -: 5221:  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        -: 5222:    return MZ_FALSE;
        -: 5223:
        -: 5224:  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +
        -: 5225:                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +
        -: 5226:                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        -: 5227:  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        -: 5228:    return MZ_FALSE;
        -: 5229:
        -: 5230:  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
        -: 5231:    // The file is stored or the caller has requested the compressed data.
        -: 5232:    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,
        -: 5233:                      (size_t)needed_size) != needed_size)
        -: 5234:      return MZ_FALSE;
        -: 5235:    return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) ||
        -: 5236:           (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,
        -: 5237:                     (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);
        -: 5238:  }
        -: 5239:
        -: 5240:  // Decompress the file either directly from memory or from a file input
        -: 5241:  // buffer.
        -: 5242:  tinfl_init(&inflator);
        -: 5243:
        -: 5244:  if (pZip->m_pState->m_pMem) {
        -: 5245:    // Read directly from the archive in memory.
        -: 5246:    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        -: 5247:    read_buf_size = read_buf_avail = file_stat.m_comp_size;
        -: 5248:    comp_remaining = 0;
        -: 5249:  } else if (pUser_read_buf) {
        -: 5250:    // Use a user provided read buffer.
        -: 5251:    if (!user_read_buf_size)
        -: 5252:      return MZ_FALSE;
        -: 5253:    pRead_buf = (mz_uint8 *)pUser_read_buf;
        -: 5254:    read_buf_size = user_read_buf_size;
        -: 5255:    read_buf_avail = 0;
        -: 5256:    comp_remaining = file_stat.m_comp_size;
        -: 5257:  } else {
        -: 5258:    // Temporarily allocate a read buffer.
        -: 5259:    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
        -: 5260:#ifdef _MSC_VER
        -: 5261:    if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&
        -: 5262:        (read_buf_size > 0x7FFFFFFF))
        -: 5263:#else
        -: 5264:    if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
        -: 5265:#endif
        -: 5266:      return MZ_FALSE;
        -: 5267:    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
        -: 5268:                                            (size_t)read_buf_size)))
        -: 5269:      return MZ_FALSE;
        -: 5270:    read_buf_avail = 0;
        -: 5271:    comp_remaining = file_stat.m_comp_size;
        -: 5272:  }
        -: 5273:
        -: 5274:  do {
        -: 5275:    size_t in_buf_size,
        -: 5276:        out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
        -: 5277:    if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
        -: 5278:      read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
        -: 5279:      if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,
        -: 5280:                        (size_t)read_buf_avail) != read_buf_avail) {
        -: 5281:        status = TINFL_STATUS_FAILED;
        -: 5282:        break;
        -: 5283:      }
        -: 5284:      cur_file_ofs += read_buf_avail;
        -: 5285:      comp_remaining -= read_buf_avail;
        -: 5286:      read_buf_ofs = 0;
        -: 5287:    }
        -: 5288:    in_buf_size = (size_t)read_buf_avail;
        -: 5289:    status = tinfl_decompress(
        -: 5290:        &inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,
        -: 5291:        (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size,
        -: 5292:        TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF |
        -: 5293:            (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
        -: 5294:    read_buf_avail -= in_buf_size;
        -: 5295:    read_buf_ofs += in_buf_size;
        -: 5296:    out_buf_ofs += out_buf_size;
        -: 5297:  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);
        -: 5298:
        -: 5299:  if (status == TINFL_STATUS_DONE) {
        -: 5300:    // Make sure the entire file was decompressed, and check its CRC.
        -: 5301:    if ((out_buf_ofs != file_stat.m_uncomp_size) ||
        -: 5302:        (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,
        -: 5303:                  (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))
        -: 5304:      status = TINFL_STATUS_FAILED;
        -: 5305:  }
        -: 5306:
        -: 5307:  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
        -: 5308:    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        -: 5309:
        -: 5310:  return status == TINFL_STATUS_DONE;
        -: 5311:}
        -: 5312:
        -: 5313:mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(
        -: 5314:    mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,
        -: 5315:    mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size) {
        -: 5316:  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
        -: 5317:  if (file_index < 0)
        -: 5318:    return MZ_FALSE;
        -: 5319:  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,
        -: 5320:                                               flags, pUser_read_buf,
        -: 5321:                                               user_read_buf_size);
        -: 5322:}
        -: 5323:
        -: 5324:mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,
        -: 5325:                                     void *pBuf, size_t buf_size,
        -: 5326:                                     mz_uint flags) {
        -: 5327:  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,
        -: 5328:                                               flags, NULL, 0);
        -: 5329:}
        -: 5330:
        -: 5331:mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,
        -: 5332:                                          const char *pFilename, void *pBuf,
        -: 5333:                                          size_t buf_size, mz_uint flags) {
        -: 5334:  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf,
        -: 5335:                                                    buf_size, flags, NULL, 0);
        -: 5336:}
        -: 5337:
        -: 5338:void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,
        -: 5339:                                    size_t *pSize, mz_uint flags) {
        -: 5340:  mz_uint64 comp_size, uncomp_size, alloc_size;
        -: 5341:  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
        -: 5342:  void *pBuf;
        -: 5343:
        -: 5344:  if (pSize)
        -: 5345:    *pSize = 0;
        -: 5346:  if (!p)
        -: 5347:    return NULL;
        -: 5348:
        -: 5349:  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
        -: 5350:  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
        -: 5351:
        -: 5352:  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
        -: 5353:#ifdef _MSC_VER
        -: 5354:  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
        -: 5355:#else
        -: 5356:  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
        -: 5357:#endif
        -: 5358:    return NULL;
        -: 5359:  if (NULL ==
        -: 5360:      (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
        -: 5361:    return NULL;
        -: 5362:
        -: 5363:  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size,
        -: 5364:                                    flags)) {
        -: 5365:    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        -: 5366:    return NULL;
        -: 5367:  }
        -: 5368:
        -: 5369:  if (pSize)
        -: 5370:    *pSize = (size_t)alloc_size;
        -: 5371:  return pBuf;
        -: 5372:}
        -: 5373:
        -: 5374:void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,
        -: 5375:                                         const char *pFilename, size_t *pSize,
        -: 5376:                                         mz_uint flags) {
        -: 5377:  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
        -: 5378:  if (file_index < 0) {
        -: 5379:    if (pSize)
        -: 5380:      *pSize = 0;
        -: 5381:    return MZ_FALSE;
        -: 5382:  }
        -: 5383:  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
        -: 5384:}
        -: 5385:
        -: 5386:mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,
        -: 5387:                                          mz_uint file_index,
        -: 5388:                                          mz_file_write_func pCallback,
        -: 5389:                                          void *pOpaque, mz_uint flags) {
        -: 5390:  int status = TINFL_STATUS_DONE;
        -: 5391:  mz_uint file_crc32 = MZ_CRC32_INIT;
        -: 5392:  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining,
        -: 5393:                           out_buf_ofs = 0, cur_file_ofs;
        -: 5394:  mz_zip_archive_file_stat file_stat;
        -: 5395:  void *pRead_buf = NULL;
        -: 5396:  void *pWrite_buf = NULL;
        -: 5397:  mz_uint32
        -: 5398:      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /
        -: 5399:                       sizeof(mz_uint32)];
        -: 5400:  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
        -: 5401:
        -: 5402:  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        -: 5403:    return MZ_FALSE;
        -: 5404:
        -: 5405:  // Empty file, or a directory (but not always a directory - I've seen odd zips
        -: 5406:  // with directories that have compressed data which inflates to 0 bytes)
        -: 5407:  if (!file_stat.m_comp_size)
        -: 5408:    return MZ_TRUE;
        -: 5409:
        -: 5410:  // Entry is a subdirectory (I've seen old zips with dir entries which have
        -: 5411:  // compressed deflate data which inflates to 0 bytes, but these entries claim
        -: 5412:  // to uncompress to 512 bytes in the headers).
        -: 5413:  // I'm torn how to handle this case - should it fail instead?
        -: 5414:  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
        -: 5415:    return MZ_TRUE;
        -: 5416:
        -: 5417:  // Encryption and patch files are not supported.
        -: 5418:  if (file_stat.m_bit_flag & (1 | 32))
        -: 5419:    return MZ_FALSE;
        -: 5420:
        -: 5421:  // This function only supports stored and deflate.
        -: 5422:  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&
        -: 5423:      (file_stat.m_method != MZ_DEFLATED))
        -: 5424:    return MZ_FALSE;
        -: 5425:
        -: 5426:  // Read and parse the local directory entry.
        -: 5427:  cur_file_ofs = file_stat.m_local_header_ofs;
        -: 5428:  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,
        -: 5429:                    MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
        -: 5430:      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        -: 5431:    return MZ_FALSE;
        -: 5432:  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        -: 5433:    return MZ_FALSE;
        -: 5434:
        -: 5435:  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +
        -: 5436:                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +
        -: 5437:                  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        -: 5438:  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        -: 5439:    return MZ_FALSE;
        -: 5440:
        -: 5441:  // Decompress the file either directly from memory or from a file input
        -: 5442:  // buffer.
        -: 5443:  if (pZip->m_pState->m_pMem) {
        -: 5444:    pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        -: 5445:    read_buf_size = read_buf_avail = file_stat.m_comp_size;
        -: 5446:    comp_remaining = 0;
        -: 5447:  } else {
        -: 5448:    read_buf_size = MZ_MIN(file_stat.m_comp_size, MZ_ZIP_MAX_IO_BUF_SIZE);
        -: 5449:    if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
        -: 5450:                                            (size_t)read_buf_size)))
        -: 5451:      return MZ_FALSE;
        -: 5452:    read_buf_avail = 0;
        -: 5453:    comp_remaining = file_stat.m_comp_size;
        -: 5454:  }
        -: 5455:
        -: 5456:  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
        -: 5457:    // The file is stored or the caller has requested the compressed data.
        -: 5458:    if (pZip->m_pState->m_pMem) {
        -: 5459:#ifdef _MSC_VER
        -: 5460:      if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&
        -: 5461:          (file_stat.m_comp_size > 0xFFFFFFFF))
        -: 5462:#else
        -: 5463:      if (((sizeof(size_t) == sizeof(mz_uint32))) &&
        -: 5464:          (file_stat.m_comp_size > 0xFFFFFFFF))
        -: 5465:#endif
        -: 5466:        return MZ_FALSE;
        -: 5467:      if (pCallback(pOpaque, out_buf_ofs, pRead_buf,
        -: 5468:                    (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
        -: 5469:        status = TINFL_STATUS_FAILED;
        -: 5470:      else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
        -: 5471:        file_crc32 =
        -: 5472:            (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf,
        -: 5473:                                (size_t)file_stat.m_comp_size);
        -: 5474:      cur_file_ofs += file_stat.m_comp_size;
        -: 5475:      out_buf_ofs += file_stat.m_comp_size;
        -: 5476:      comp_remaining = 0;
        -: 5477:    } else {
        -: 5478:      while (comp_remaining) {
        -: 5479:        read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
        -: 5480:        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,
        -: 5481:                          (size_t)read_buf_avail) != read_buf_avail) {
        -: 5482:          status = TINFL_STATUS_FAILED;
        -: 5483:          break;
        -: 5484:        }
        -: 5485:
        -: 5486:        if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
        -: 5487:          file_crc32 = (mz_uint32)mz_crc32(
        -: 5488:              file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
        -: 5489:
        -: 5490:        if (pCallback(pOpaque, out_buf_ofs, pRead_buf,
        -: 5491:                      (size_t)read_buf_avail) != read_buf_avail) {
        -: 5492:          status = TINFL_STATUS_FAILED;
        -: 5493:          break;
        -: 5494:        }
        -: 5495:        cur_file_ofs += read_buf_avail;
        -: 5496:        out_buf_ofs += read_buf_avail;
        -: 5497:        comp_remaining -= read_buf_avail;
        -: 5498:      }
        -: 5499:    }
        -: 5500:  } else {
        -: 5501:    tinfl_decompressor inflator;
        -: 5502:    tinfl_init(&inflator);
        -: 5503:
        -: 5504:    if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
        -: 5505:                                             TINFL_LZ_DICT_SIZE)))
        -: 5506:      status = TINFL_STATUS_FAILED;
        -: 5507:    else {
        -: 5508:      do {
        -: 5509:        mz_uint8 *pWrite_buf_cur =
        -: 5510:            (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
        -: 5511:        size_t in_buf_size,
        -: 5512:            out_buf_size =
        -: 5513:                TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
        -: 5514:        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
        -: 5515:          read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
        -: 5516:          if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,
        -: 5517:                            (size_t)read_buf_avail) != read_buf_avail) {
        -: 5518:            status = TINFL_STATUS_FAILED;
        -: 5519:            break;
        -: 5520:          }
        -: 5521:          cur_file_ofs += read_buf_avail;
        -: 5522:          comp_remaining -= read_buf_avail;
        -: 5523:          read_buf_ofs = 0;
        -: 5524:        }
        -: 5525:
        -: 5526:        in_buf_size = (size_t)read_buf_avail;
        -: 5527:        status = tinfl_decompress(
        -: 5528:            &inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,
        -: 5529:            (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size,
        -: 5530:            comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
        -: 5531:        read_buf_avail -= in_buf_size;
        -: 5532:        read_buf_ofs += in_buf_size;
        -: 5533:
        -: 5534:        if (out_buf_size) {
        -: 5535:          if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) !=
        -: 5536:              out_buf_size) {
        -: 5537:            status = TINFL_STATUS_FAILED;
        -: 5538:            break;
        -: 5539:          }
        -: 5540:          file_crc32 =
        -: 5541:              (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
        -: 5542:          if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size) {
        -: 5543:            status = TINFL_STATUS_FAILED;
        -: 5544:            break;
        -: 5545:          }
        -: 5546:        }
        -: 5547:      } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) ||
        -: 5548:               (status == TINFL_STATUS_HAS_MORE_OUTPUT));
        -: 5549:    }
        -: 5550:  }
        -: 5551:
        -: 5552:  if ((status == TINFL_STATUS_DONE) &&
        -: 5553:      (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))) {
        -: 5554:    // Make sure the entire file was decompressed, and check its CRC.
        -: 5555:    if ((out_buf_ofs != file_stat.m_uncomp_size) ||
        -: 5556:        (file_crc32 != file_stat.m_crc32))
        -: 5557:      status = TINFL_STATUS_FAILED;
        -: 5558:  }
        -: 5559:
        -: 5560:  if (!pZip->m_pState->m_pMem)
        -: 5561:    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        -: 5562:  if (pWrite_buf)
        -: 5563:    pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);
        -: 5564:
        -: 5565:  return status == TINFL_STATUS_DONE;
        -: 5566:}
        -: 5567:
        -: 5568:mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,
        -: 5569:                                               const char *pFilename,
        -: 5570:                                               mz_file_write_func pCallback,
        -: 5571:                                               void *pOpaque, mz_uint flags) {
        -: 5572:  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
        -: 5573:  if (file_index < 0)
        -: 5574:    return MZ_FALSE;
        -: 5575:  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque,
        -: 5576:                                           flags);
        -: 5577:}
        -: 5578:
        -: 5579:#ifndef MINIZ_NO_STDIO
        -: 5580:static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs,
        -: 5581:                                         const void *pBuf, size_t n) {
        -: 5582:  (void)ofs;
        -: 5583:  return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
        -: 5584:}
        -: 5585:
        -: 5586:mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,
        -: 5587:                                      const char *pDst_filename,
        -: 5588:                                      mz_uint flags) {
        -: 5589:  mz_bool status;
        -: 5590:  mz_zip_archive_file_stat file_stat;
        -: 5591:  MZ_FILE *pFile;
        -: 5592:  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        -: 5593:    return MZ_FALSE;
        -: 5594:  pFile = MZ_FOPEN(pDst_filename, "wb");
        -: 5595:  if (!pFile)
        -: 5596:    return MZ_FALSE;
        -: 5597:  status = mz_zip_reader_extract_to_callback(
        -: 5598:      pZip, file_index, mz_zip_file_write_callback, pFile, flags);
        -: 5599:  if (MZ_FCLOSE(pFile) == EOF)
        -: 5600:    return MZ_FALSE;
        -: 5601:#ifndef MINIZ_NO_TIME
        -: 5602:  if (status)
        -: 5603:    mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
        -: 5604:#endif
        -: 5605:  return status;
        -: 5606:}
        -: 5607:#endif // #ifndef MINIZ_NO_STDIO
        -: 5608:
        -: 5609:mz_bool mz_zip_reader_end(mz_zip_archive *pZip) {
        -: 5610:  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||
        -: 5611:      (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        -: 5612:    return MZ_FALSE;
        -: 5613:
        -: 5614:  if (pZip->m_pState) {
        -: 5615:    mz_zip_internal_state *pState = pZip->m_pState;
        -: 5616:    pZip->m_pState = NULL;
        -: 5617:    mz_zip_array_clear(pZip, &pState->m_central_dir);
        -: 5618:    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
        -: 5619:    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
        -: 5620:
        -: 5621:#ifndef MINIZ_NO_STDIO
        -: 5622:    if (pState->m_pFile) {
        -: 5623:      MZ_FCLOSE(pState->m_pFile);
        -: 5624:      pState->m_pFile = NULL;
        -: 5625:    }
        -: 5626:#endif // #ifndef MINIZ_NO_STDIO
        -: 5627:
        -: 5628:    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        -: 5629:  }
        -: 5630:  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
        -: 5631:
        -: 5632:  return MZ_TRUE;
        -: 5633:}
        -: 5634:
        -: 5635:#ifndef MINIZ_NO_STDIO
        -: 5636:mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,
        -: 5637:                                           const char *pArchive_filename,
        -: 5638:                                           const char *pDst_filename,
        -: 5639:                                           mz_uint flags) {
        -: 5640:  int file_index =
        -: 5641:      mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);
        -: 5642:  if (file_index < 0)
        -: 5643:    return MZ_FALSE;
        -: 5644:  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
        -: 5645:}
        -: 5646:#endif
        -: 5647:
        -: 5648:// ------------------- .ZIP archive writing
        -: 5649:
        -: 5650:#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
        -: 5651:
        -: 5652:static void mz_write_le16(mz_uint8 *p, mz_uint16 v) {
        -: 5653:  p[0] = (mz_uint8)v;
        -: 5654:  p[1] = (mz_uint8)(v >> 8);
        -: 5655:}
        -: 5656:static void mz_write_le32(mz_uint8 *p, mz_uint32 v) {
        -: 5657:  p[0] = (mz_uint8)v;
        -: 5658:  p[1] = (mz_uint8)(v >> 8);
        -: 5659:  p[2] = (mz_uint8)(v >> 16);
        -: 5660:  p[3] = (mz_uint8)(v >> 24);
        -: 5661:}
        -: 5662:#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
        -: 5663:#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
        -: 5664:
        -: 5665:mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size) {
        -: 5666:  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) ||
        -: 5667:      (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
        -: 5668:    return MZ_FALSE;
        -: 5669:
        -: 5670:  if (pZip->m_file_offset_alignment) {
        -: 5671:    // Ensure user specified file offset alignment is a power of 2.
        -: 5672:    if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
        -: 5673:      return MZ_FALSE;
        -: 5674:  }
        -: 5675:
        -: 5676:  if (!pZip->m_pAlloc)
        -: 5677:    pZip->m_pAlloc = def_alloc_func;
        -: 5678:  if (!pZip->m_pFree)
        -: 5679:    pZip->m_pFree = def_free_func;
        -: 5680:  if (!pZip->m_pRealloc)
        -: 5681:    pZip->m_pRealloc = def_realloc_func;
        -: 5682:
        -: 5683:  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
        -: 5684:  pZip->m_archive_size = existing_size;
        -: 5685:  pZip->m_central_directory_file_ofs = 0;
        -: 5686:  pZip->m_total_files = 0;
        -: 5687:
        -: 5688:  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(
        -: 5689:                   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        -: 5690:    return MZ_FALSE;
        -: 5691:  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
        -: 5692:  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,
        -: 5693:                                sizeof(mz_uint8));
        -: 5694:  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,
        -: 5695:                                sizeof(mz_uint32));
        -: 5696:  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,
        -: 5697:                                sizeof(mz_uint32));
        -: 5698:  return MZ_TRUE;
        -: 5699:}
        -: 5700:
        -: 5701:static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs,
        -: 5702:                                     const void *pBuf, size_t n) {
        -: 5703:  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        -: 5704:  mz_zip_internal_state *pState = pZip->m_pState;
        -: 5705:  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
        -: 5706:#ifdef _MSC_VER
        -: 5707:  if ((!n) ||
        -: 5708:      ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
        -: 5709:#else
        -: 5710:  if ((!n) ||
        -: 5711:      ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
        -: 5712:#endif
        -: 5713:    return 0;
        -: 5714:  if (new_size > pState->m_mem_capacity) {
        -: 5715:    void *pNew_block;
        -: 5716:    size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);
        -: 5717:    while (new_capacity < new_size)
        -: 5718:      new_capacity *= 2;
        -: 5719:    if (NULL == (pNew_block = pZip->m_pRealloc(
        -: 5720:                     pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
        -: 5721:      return 0;
        -: 5722:    pState->m_pMem = pNew_block;
        -: 5723:    pState->m_mem_capacity = new_capacity;
        -: 5724:  }
        -: 5725:  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
        -: 5726:  pState->m_mem_size = (size_t)new_size;
        -: 5727:  return n;
        -: 5728:}
        -: 5729:
        -: 5730:mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,
        -: 5731:                                size_t size_to_reserve_at_beginning,
        -: 5732:                                size_t initial_allocation_size) {
        -: 5733:  pZip->m_pWrite = mz_zip_heap_write_func;
        -: 5734:  pZip->m_pIO_opaque = pZip;
        -: 5735:  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
        -: 5736:    return MZ_FALSE;
        -: 5737:  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size,
        -: 5738:                                             size_to_reserve_at_beginning))) {
        -: 5739:    if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(
        -: 5740:                     pZip->m_pAlloc_opaque, 1, initial_allocation_size))) {
        -: 5741:      mz_zip_writer_end(pZip);
        -: 5742:      return MZ_FALSE;
        -: 5743:    }
        -: 5744:    pZip->m_pState->m_mem_capacity = initial_allocation_size;
        -: 5745:  }
        -: 5746:  return MZ_TRUE;
        -: 5747:}
        -: 5748:
        -: 5749:#ifndef MINIZ_NO_STDIO
        -: 5750:static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs,
        -: 5751:                                     const void *pBuf, size_t n) {
        -: 5752:  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
        -: 5753:  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
        -: 5754:  if (((mz_int64)file_ofs < 0) ||
        -: 5755:      (((cur_ofs != (mz_int64)file_ofs)) &&
        -: 5756:       (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
        -: 5757:    return 0;
        -: 5758:  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
        -: 5759:}
        -: 5760:
        -: 5761:mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,
        -: 5762:                                mz_uint64 size_to_reserve_at_beginning) {
        -: 5763:  MZ_FILE *pFile;
        -: 5764:  pZip->m_pWrite = mz_zip_file_write_func;
        -: 5765:  pZip->m_pIO_opaque = pZip;
        -: 5766:  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
        -: 5767:    return MZ_FALSE;
        -: 5768:  if (NULL == (pFile = MZ_FOPEN(pFilename, "wb"))) {
        -: 5769:    mz_zip_writer_end(pZip);
        -: 5770:    return MZ_FALSE;
        -: 5771:  }
        -: 5772:  pZip->m_pState->m_pFile = pFile;
        -: 5773:  if (size_to_reserve_at_beginning) {
        -: 5774:    mz_uint64 cur_ofs = 0;
        -: 5775:    char buf[4096];
        -: 5776:    MZ_CLEAR_OBJ(buf);
        -: 5777:    do {
        -: 5778:      size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
        -: 5779:      if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n) {
        -: 5780:        mz_zip_writer_end(pZip);
        -: 5781:        return MZ_FALSE;
        -: 5782:      }
        -: 5783:      cur_ofs += n;
        -: 5784:      size_to_reserve_at_beginning -= n;
        -: 5785:    } while (size_to_reserve_at_beginning);
        -: 5786:  }
        -: 5787:  return MZ_TRUE;
        -: 5788:}
        -: 5789:#endif // #ifndef MINIZ_NO_STDIO
        -: 5790:
        -: 5791:mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,
        -: 5792:                                       const char *pFilename) {
        -: 5793:  mz_zip_internal_state *pState;
        -: 5794:  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        -: 5795:    return MZ_FALSE;
        -: 5796:  // No sense in trying to write to an archive that's already at the support max
        -: 5797:  // size
        -: 5798:  if ((pZip->m_total_files == 0xFFFF) ||
        -: 5799:      ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
        -: 5800:        MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
        -: 5801:    return MZ_FALSE;
        -: 5802:
        -: 5803:  pState = pZip->m_pState;
        -: 5804:
        -: 5805:  if (pState->m_pFile) {
        -: 5806:#ifdef MINIZ_NO_STDIO
        -: 5807:    pFilename;
        -: 5808:    return MZ_FALSE;
        -: 5809:#else
        -: 5810:    // Archive is being read from stdio - try to reopen as writable.
        -: 5811:    if (pZip->m_pIO_opaque != pZip)
        -: 5812:      return MZ_FALSE;
        -: 5813:    if (!pFilename)
        -: 5814:      return MZ_FALSE;
        -: 5815:    pZip->m_pWrite = mz_zip_file_write_func;
        -: 5816:    if (NULL ==
        -: 5817:        (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile))) {
        -: 5818:      // The mz_zip_archive is now in a bogus state because pState->m_pFile is
        -: 5819:      // NULL, so just close it.
        -: 5820:      mz_zip_reader_end(pZip);
        -: 5821:      return MZ_FALSE;
        -: 5822:    }
        -: 5823:#endif // #ifdef MINIZ_NO_STDIO
        -: 5824:  } else if (pState->m_pMem) {
        -: 5825:    // Archive lives in a memory block. Assume it's from the heap that we can
        -: 5826:    // resize using the realloc callback.
        -: 5827:    if (pZip->m_pIO_opaque != pZip)
        -: 5828:      return MZ_FALSE;
        -: 5829:    pState->m_mem_capacity = pState->m_mem_size;
        -: 5830:    pZip->m_pWrite = mz_zip_heap_write_func;
        -: 5831:  }
        -: 5832:  // Archive is being read via a user provided read function - make sure the
        -: 5833:  // user has specified a write function too.
        -: 5834:  else if (!pZip->m_pWrite)
        -: 5835:    return MZ_FALSE;
        -: 5836:
        -: 5837:  // Start writing new files at the archive's current central directory
        -: 5838:  // location.
        -: 5839:  pZip->m_archive_size = pZip->m_central_directory_file_ofs;
        -: 5840:  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
        -: 5841:  pZip->m_central_directory_file_ofs = 0;
        -: 5842:
        -: 5843:  return MZ_TRUE;
        -: 5844:}
        -: 5845:
        -: 5846:mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,
        -: 5847:                              const void *pBuf, size_t buf_size,
        -: 5848:                              mz_uint level_and_flags) {
        -: 5849:  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0,
        -: 5850:                                  level_and_flags, 0, 0);
        -: 5851:}
        -: 5852:
        -: 5853:typedef struct {
        -: 5854:  mz_zip_archive *m_pZip;
        -: 5855:  mz_uint64 m_cur_archive_file_ofs;
        -: 5856:  mz_uint64 m_comp_size;
        -: 5857:} mz_zip_writer_add_state;
        -: 5858:
        -: 5859:static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len,
        -: 5860:                                                  void *pUser) {
        -: 5861:  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
        -: 5862:  if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque,
        -: 5863:                                    pState->m_cur_archive_file_ofs, pBuf,
        -: 5864:                                    len) != len)
        -: 5865:    return MZ_FALSE;
        -: 5866:  pState->m_cur_archive_file_ofs += len;
        -: 5867:  pState->m_comp_size += len;
        -: 5868:  return MZ_TRUE;
        -: 5869:}
        -: 5870:
        -: 5871:static mz_bool mz_zip_writer_create_local_dir_header(
        -: 5872:    mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,
        -: 5873:    mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size,
        -: 5874:    mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,
        -: 5875:    mz_uint16 dos_time, mz_uint16 dos_date) {
        -: 5876:  (void)pZip;
        -: 5877:  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
        -: 5878:  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
        -: 5879:  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
        -: 5880:  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
        -: 5881:  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
        -: 5882:  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
        -: 5883:  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
        -: 5884:  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
        -: 5885:  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);
        -: 5886:  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
        -: 5887:  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
        -: 5888:  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
        -: 5889:  return MZ_TRUE;
        -: 5890:}
        -: 5891:
        -: 5892:static mz_bool mz_zip_writer_create_central_dir_header(
        -: 5893:    mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,
        -: 5894:    mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size,
        -: 5895:    mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method,
        -: 5896:    mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
        -: 5897:    mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {
        -: 5898:  (void)pZip;
        -: 5899:  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
        -: 5900:  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
        -: 5901:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
        -: 5902:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
        -: 5903:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
        -: 5904:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
        -: 5905:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
        -: 5906:  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
        -: 5907:  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);
        -: 5908:  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
        -: 5909:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
        -: 5910:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
        -: 5911:  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
        -: 5912:  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
        -: 5913:  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);
        -: 5914:  return MZ_TRUE;
        -: 5915:}
        -: 5916:
        -: 5917:static mz_bool mz_zip_writer_add_to_central_dir(
        -: 5918:    mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
        -: 5919:    const void *pExtra, mz_uint16 extra_size, const void *pComment,
        -: 5920:    mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size,
        -: 5921:    mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,
        -: 5922:    mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs,
        -: 5923:    mz_uint32 ext_attributes) {
        -: 5924:  mz_zip_internal_state *pState = pZip->m_pState;
        -: 5925:  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
        -: 5926:  size_t orig_central_dir_size = pState->m_central_dir.m_size;
        -: 5927:  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
        -: 5928:
        -: 5929:  // No zip64 support yet
        -: 5930:  if ((local_header_ofs > 0xFFFFFFFF) ||
        -: 5931:      (((mz_uint64)pState->m_central_dir.m_size +
        -: 5932:        MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size +
        -: 5933:        comment_size) > 0xFFFFFFFF))
        -: 5934:    return MZ_FALSE;
        -: 5935:
        -: 5936:  if (!mz_zip_writer_create_central_dir_header(
        -: 5937:          pZip, central_dir_header, filename_size, extra_size, comment_size,
        -: 5938:          uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time,
        -: 5939:          dos_date, local_header_ofs, ext_attributes))
        -: 5940:    return MZ_FALSE;
        -: 5941:
        -: 5942:  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header,
        -: 5943:                               MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
        -: 5944:      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename,
        -: 5945:                               filename_size)) ||
        -: 5946:      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra,
        -: 5947:                               extra_size)) ||
        -: 5948:      (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment,
        -: 5949:                               comment_size)) ||
        -: 5950:      (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets,
        -: 5951:                               &central_dir_ofs, 1))) {
        -: 5952:    // Try to push the central directory array back into its original state.
        -: 5953:    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,
        -: 5954:                        MZ_FALSE);
        -: 5955:    return MZ_FALSE;
        -: 5956:  }
        -: 5957:
        -: 5958:  return MZ_TRUE;
        -: 5959:}
        -: 5960:
        -: 5961:static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name) {
        -: 5962:  // Basic ZIP archive filename validity checks: Valid filenames cannot start
        -: 5963:  // with a forward slash, cannot contain a drive letter, and cannot use
        -: 5964:  // DOS-style backward slashes.
        -: 5965:  if (*pArchive_name == '/')
        -: 5966:    return MZ_FALSE;
        -: 5967:  while (*pArchive_name) {
        -: 5968:    if ((*pArchive_name == '\\') || (*pArchive_name == ':'))
        -: 5969:      return MZ_FALSE;
        -: 5970:    pArchive_name++;
        -: 5971:  }
        -: 5972:  return MZ_TRUE;
        -: 5973:}
        -: 5974:
        -: 5975:static mz_uint
        -: 5976:mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip) {
        -: 5977:  mz_uint32 n;
        -: 5978:  if (!pZip->m_file_offset_alignment)
        -: 5979:    return 0;
        -: 5980:  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
        -: 5981:  return (pZip->m_file_offset_alignment - n) &
        -: 5982:         (pZip->m_file_offset_alignment - 1);
        -: 5983:}
        -: 5984:
        -: 5985:static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip,
        -: 5986:                                         mz_uint64 cur_file_ofs, mz_uint32 n) {
        -: 5987:  char buf[4096];
        -: 5988:  memset(buf, 0, MZ_MIN(sizeof(buf), n));
        -: 5989:  while (n) {
        -: 5990:    mz_uint32 s = MZ_MIN(sizeof(buf), n);
        -: 5991:    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
        -: 5992:      return MZ_FALSE;
        -: 5993:    cur_file_ofs += s;
        -: 5994:    n -= s;
        -: 5995:  }
        -: 5996:  return MZ_TRUE;
        -: 5997:}
        -: 5998:
        -: 5999:mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,
        -: 6000:                                 const char *pArchive_name, const void *pBuf,
        -: 6001:                                 size_t buf_size, const void *pComment,
        -: 6002:                                 mz_uint16 comment_size,
        -: 6003:                                 mz_uint level_and_flags, mz_uint64 uncomp_size,
        -: 6004:                                 mz_uint32 uncomp_crc32) {
        -: 6005:  mz_uint16 method = 0, dos_time = 0, dos_date = 0;
        -: 6006:  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
        -: 6007:  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,
        -: 6008:            cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
        -: 6009:  size_t archive_name_size;
        -: 6010:  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
        -: 6011:  tdefl_compressor *pComp = NULL;
        -: 6012:  mz_bool store_data_uncompressed;
        -: 6013:  mz_zip_internal_state *pState;
        -: 6014:
        -: 6015:  if ((int)level_and_flags < 0)
        -: 6016:    level_and_flags = MZ_DEFAULT_LEVEL;
        -: 6017:  level = level_and_flags & 0xF;
        -: 6018:  store_data_uncompressed =
        -: 6019:      ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));
        -: 6020:
        -: 6021:  if ((!pZip) || (!pZip->m_pState) ||
        -: 6022:      (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) ||
        -: 6023:      (!pArchive_name) || ((comment_size) && (!pComment)) ||
        -: 6024:      (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))
        -: 6025:    return MZ_FALSE;
        -: 6026:
        -: 6027:  pState = pZip->m_pState;
        -: 6028:
        -: 6029:  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
        -: 6030:    return MZ_FALSE;
        -: 6031:  // No zip64 support yet
        -: 6032:  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
        -: 6033:    return MZ_FALSE;
        -: 6034:  if (!mz_zip_writer_validate_archive_name(pArchive_name))
        -: 6035:    return MZ_FALSE;
        -: 6036:
        -: 6037:#ifndef MINIZ_NO_TIME
        -: 6038:  {
        -: 6039:    time_t cur_time;
        -: 6040:    time(&cur_time);
        -: 6041:    mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);
        -: 6042:  }
        -: 6043:#endif // #ifndef MINIZ_NO_TIME
        -: 6044:
        -: 6045:  archive_name_size = strlen(pArchive_name);
        -: 6046:  if (archive_name_size > 0xFFFF)
        -: 6047:    return MZ_FALSE;
        -: 6048:
        -: 6049:  num_alignment_padding_bytes =
        -: 6050:      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
        -: 6051:
        -: 6052:  // no zip64 support yet
        -: 6053:  if ((pZip->m_total_files == 0xFFFF) ||
        -: 6054:      ((pZip->m_archive_size + num_alignment_padding_bytes +
        -: 6055:        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
        -: 6056:        comment_size + archive_name_size) > 0xFFFFFFFF))
        -: 6057:    return MZ_FALSE;
        -: 6058:
        -: 6059:  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/')) {
        -: 6060:    // Set DOS Subdirectory attribute bit.
        -: 6061:    ext_attributes |= 0x10;
        -: 6062:    // Subdirectories cannot contain data.
        -: 6063:    if ((buf_size) || (uncomp_size))
        -: 6064:      return MZ_FALSE;
        -: 6065:  }
        -: 6066:
        -: 6067:  // Try to do any allocations before writing to the archive, so if an
        -: 6068:  // allocation fails the file remains unmodified. (A good idea if we're doing
        -: 6069:  // an in-place modification.)
        -: 6070:  if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir,
        -: 6071:                                 MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
        -: 6072:                                     archive_name_size + comment_size)) ||
        -: 6073:      (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
        -: 6074:    return MZ_FALSE;
        -: 6075:
        -: 6076:  if ((!store_data_uncompressed) && (buf_size)) {
        -: 6077:    if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(
        -: 6078:                     pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
        -: 6079:      return MZ_FALSE;
        -: 6080:  }
        -: 6081:
        -: 6082:  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs,
        -: 6083:                                 num_alignment_padding_bytes +
        -: 6084:                                     sizeof(local_dir_header))) {
        -: 6085:    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        -: 6086:    return MZ_FALSE;
        -: 6087:  }
        -: 6088:  local_dir_header_ofs += num_alignment_padding_bytes;
        -: 6089:  if (pZip->m_file_offset_alignment) {
        -: 6090:    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==
        -: 6091:              0);
        -: 6092:  }
        -: 6093:  cur_archive_file_ofs +=
        -: 6094:      num_alignment_padding_bytes + sizeof(local_dir_header);
        -: 6095:
        -: 6096:  MZ_CLEAR_OBJ(local_dir_header);
        -: 6097:  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,
        -: 6098:                     archive_name_size) != archive_name_size) {
        -: 6099:    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        -: 6100:    return MZ_FALSE;
        -: 6101:  }
        -: 6102:  cur_archive_file_ofs += archive_name_size;
        -: 6103:
        -: 6104:  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) {
        -: 6105:    uncomp_crc32 =
        -: 6106:        (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
        -: 6107:    uncomp_size = buf_size;
        -: 6108:    if (uncomp_size <= 3) {
        -: 6109:      level = 0;
        -: 6110:      store_data_uncompressed = MZ_TRUE;
        -: 6111:    }
        -: 6112:  }
        -: 6113:
        -: 6114:  if (store_data_uncompressed) {
        -: 6115:    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf,
        -: 6116:                       buf_size) != buf_size) {
        -: 6117:      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        -: 6118:      return MZ_FALSE;
        -: 6119:    }
        -: 6120:
        -: 6121:    cur_archive_file_ofs += buf_size;
        -: 6122:    comp_size = buf_size;
        -: 6123:
        -: 6124:    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
        -: 6125:      method = MZ_DEFLATED;
        -: 6126:  } else if (buf_size) {
        -: 6127:    mz_zip_writer_add_state state;
        -: 6128:
        -: 6129:    state.m_pZip = pZip;
        -: 6130:    state.m_cur_archive_file_ofs = cur_archive_file_ofs;
        -: 6131:    state.m_comp_size = 0;
        -: 6132:
        -: 6133:    if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
        -: 6134:                    tdefl_create_comp_flags_from_zip_params(
        -: 6135:                        level, -15, MZ_DEFAULT_STRATEGY)) !=
        -: 6136:         TDEFL_STATUS_OKAY) ||
        -: 6137:        (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) !=
        -: 6138:         TDEFL_STATUS_DONE)) {
        -: 6139:      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        -: 6140:      return MZ_FALSE;
        -: 6141:    }
        -: 6142:
        -: 6143:    comp_size = state.m_comp_size;
        -: 6144:    cur_archive_file_ofs = state.m_cur_archive_file_ofs;
        -: 6145:
        -: 6146:    method = MZ_DEFLATED;
        -: 6147:  }
        -: 6148:
        -: 6149:  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        -: 6150:  pComp = NULL;
        -: 6151:
        -: 6152:  // no zip64 support yet
        -: 6153:  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
        -: 6154:    return MZ_FALSE;
        -: 6155:
        -: 6156:  if (!mz_zip_writer_create_local_dir_header(
        -: 6157:          pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,
        -: 6158:          comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
        -: 6159:    return MZ_FALSE;
        -: 6160:
        -: 6161:  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,
        -: 6162:                     sizeof(local_dir_header)) != sizeof(local_dir_header))
        -: 6163:    return MZ_FALSE;
        -: 6164:
        -: 6165:  if (!mz_zip_writer_add_to_central_dir(
        -: 6166:          pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,
        -: 6167:          comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,
        -: 6168:          dos_time, dos_date, local_dir_header_ofs, ext_attributes))
        -: 6169:    return MZ_FALSE;
        -: 6170:
        -: 6171:  pZip->m_total_files++;
        -: 6172:  pZip->m_archive_size = cur_archive_file_ofs;
        -: 6173:
        -: 6174:  return MZ_TRUE;
        -: 6175:}
        -: 6176:
        -: 6177:#ifndef MINIZ_NO_STDIO
        -: 6178:mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,
        -: 6179:                               const char *pSrc_filename, const void *pComment,
        -: 6180:                               mz_uint16 comment_size,
        -: 6181:                               mz_uint level_and_flags) {
        -: 6182:  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
        -: 6183:  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
        -: 6184:  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,
        -: 6185:            cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0,
        -: 6186:            comp_size = 0;
        -: 6187:  size_t archive_name_size;
        -: 6188:  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
        -: 6189:  MZ_FILE *pSrc_file = NULL;
        -: 6190:
        -: 6191:  if ((int)level_and_flags < 0)
        -: 6192:    level_and_flags = MZ_DEFAULT_LEVEL;
        -: 6193:  level = level_and_flags & 0xF;
        -: 6194:
        -: 6195:  if ((!pZip) || (!pZip->m_pState) ||
        -: 6196:      (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) ||
        -: 6197:      ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
        -: 6198:    return MZ_FALSE;
        -: 6199:  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
        -: 6200:    return MZ_FALSE;
        -: 6201:  if (!mz_zip_writer_validate_archive_name(pArchive_name))
        -: 6202:    return MZ_FALSE;
        -: 6203:
        -: 6204:  archive_name_size = strlen(pArchive_name);
        -: 6205:  if (archive_name_size > 0xFFFF)
        -: 6206:    return MZ_FALSE;
        -: 6207:
        -: 6208:  num_alignment_padding_bytes =
        -: 6209:      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
        -: 6210:
        -: 6211:  // no zip64 support yet
        -: 6212:  if ((pZip->m_total_files == 0xFFFF) ||
        -: 6213:      ((pZip->m_archive_size + num_alignment_padding_bytes +
        -: 6214:        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
        -: 6215:        comment_size + archive_name_size) > 0xFFFFFFFF))
        -: 6216:    return MZ_FALSE;
        -: 6217:
        -: 6218:  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))
        -: 6219:    return MZ_FALSE;
        -: 6220:
        -: 6221:  pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
        -: 6222:  if (!pSrc_file)
        -: 6223:    return MZ_FALSE;
        -: 6224:  MZ_FSEEK64(pSrc_file, 0, SEEK_END);
        -: 6225:  uncomp_size = MZ_FTELL64(pSrc_file);
        -: 6226:  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);
        -: 6227:
        -: 6228:  if (uncomp_size > 0xFFFFFFFF) {
        -: 6229:    // No zip64 support yet
        -: 6230:    MZ_FCLOSE(pSrc_file);
        -: 6231:    return MZ_FALSE;
        -: 6232:  }
        -: 6233:  if (uncomp_size <= 3)
        -: 6234:    level = 0;
        -: 6235:
        -: 6236:  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs,
        -: 6237:                                 num_alignment_padding_bytes +
        -: 6238:                                     sizeof(local_dir_header))) {
        -: 6239:    MZ_FCLOSE(pSrc_file);
        -: 6240:    return MZ_FALSE;
        -: 6241:  }
        -: 6242:  local_dir_header_ofs += num_alignment_padding_bytes;
        -: 6243:  if (pZip->m_file_offset_alignment) {
        -: 6244:    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==
        -: 6245:              0);
        -: 6246:  }
        -: 6247:  cur_archive_file_ofs +=
        -: 6248:      num_alignment_padding_bytes + sizeof(local_dir_header);
        -: 6249:
        -: 6250:  MZ_CLEAR_OBJ(local_dir_header);
        -: 6251:  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,
        -: 6252:                     archive_name_size) != archive_name_size) {
        -: 6253:    MZ_FCLOSE(pSrc_file);
        -: 6254:    return MZ_FALSE;
        -: 6255:  }
        -: 6256:  cur_archive_file_ofs += archive_name_size;
        -: 6257:
        -: 6258:  if (uncomp_size) {
        -: 6259:    mz_uint64 uncomp_remaining = uncomp_size;
        -: 6260:    void *pRead_buf =
        -: 6261:        pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
        -: 6262:    if (!pRead_buf) {
        -: 6263:      MZ_FCLOSE(pSrc_file);
        -: 6264:      return MZ_FALSE;
        -: 6265:    }
        -: 6266:
        -: 6267:    if (!level) {
        -: 6268:      while (uncomp_remaining) {
        -: 6269:        mz_uint n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
        -: 6270:        if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) ||
        -: 6271:            (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf,
        -: 6272:                            n) != n)) {
        -: 6273:          pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        -: 6274:          MZ_FCLOSE(pSrc_file);
        -: 6275:          return MZ_FALSE;
        -: 6276:        }
        -: 6277:        uncomp_crc32 =
        -: 6278:            (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
        -: 6279:        uncomp_remaining -= n;
        -: 6280:        cur_archive_file_ofs += n;
        -: 6281:      }
        -: 6282:      comp_size = uncomp_size;
        -: 6283:    } else {
        -: 6284:      mz_bool result = MZ_FALSE;
        -: 6285:      mz_zip_writer_add_state state;
        -: 6286:      tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(
        -: 6287:          pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
        -: 6288:      if (!pComp) {
        -: 6289:        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        -: 6290:        MZ_FCLOSE(pSrc_file);
        -: 6291:        return MZ_FALSE;
        -: 6292:      }
        -: 6293:
        -: 6294:      state.m_pZip = pZip;
        -: 6295:      state.m_cur_archive_file_ofs = cur_archive_file_ofs;
        -: 6296:      state.m_comp_size = 0;
        -: 6297:
        -: 6298:      if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
        -: 6299:                     tdefl_create_comp_flags_from_zip_params(
        -: 6300:                         level, -15, MZ_DEFAULT_STRATEGY)) !=
        -: 6301:          TDEFL_STATUS_OKAY) {
        -: 6302:        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        -: 6303:        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        -: 6304:        MZ_FCLOSE(pSrc_file);
        -: 6305:        return MZ_FALSE;
        -: 6306:      }
        -: 6307:
        -: 6308:      for (;;) {
        -: 6309:        size_t in_buf_size =
        -: 6310:            (mz_uint32)MZ_MIN(uncomp_remaining, MZ_ZIP_MAX_IO_BUF_SIZE);
        -: 6311:        tdefl_status status;
        -: 6312:
        -: 6313:        if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)
        -: 6314:          break;
        -: 6315:
        -: 6316:        uncomp_crc32 = (mz_uint32)mz_crc32(
        -: 6317:            uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);
        -: 6318:        uncomp_remaining -= in_buf_size;
        -: 6319:
        -: 6320:        status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size,
        -: 6321:                                       uncomp_remaining ? TDEFL_NO_FLUSH
        -: 6322:                                                        : TDEFL_FINISH);
        -: 6323:        if (status == TDEFL_STATUS_DONE) {
        -: 6324:          result = MZ_TRUE;
        -: 6325:          break;
        -: 6326:        } else if (status != TDEFL_STATUS_OKAY)
        -: 6327:          break;
        -: 6328:      }
        -: 6329:
        -: 6330:      pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        -: 6331:
        -: 6332:      if (!result) {
        -: 6333:        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        -: 6334:        MZ_FCLOSE(pSrc_file);
        -: 6335:        return MZ_FALSE;
        -: 6336:      }
        -: 6337:
        -: 6338:      comp_size = state.m_comp_size;
        -: 6339:      cur_archive_file_ofs = state.m_cur_archive_file_ofs;
        -: 6340:
        -: 6341:      method = MZ_DEFLATED;
        -: 6342:    }
        -: 6343:
        -: 6344:    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
        -: 6345:  }
        -: 6346:
        -: 6347:  MZ_FCLOSE(pSrc_file);
        -: 6348:  pSrc_file = NULL;
        -: 6349:
        -: 6350:  // no zip64 support yet
        -: 6351:  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
        -: 6352:    return MZ_FALSE;
        -: 6353:
        -: 6354:  if (!mz_zip_writer_create_local_dir_header(
        -: 6355:          pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,
        -: 6356:          comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
        -: 6357:    return MZ_FALSE;
        -: 6358:
        -: 6359:  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,
        -: 6360:                     sizeof(local_dir_header)) != sizeof(local_dir_header))
        -: 6361:    return MZ_FALSE;
        -: 6362:
        -: 6363:  if (!mz_zip_writer_add_to_central_dir(
        -: 6364:          pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,
        -: 6365:          comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,
        -: 6366:          dos_time, dos_date, local_dir_header_ofs, ext_attributes))
        -: 6367:    return MZ_FALSE;
        -: 6368:
        -: 6369:  pZip->m_total_files++;
        -: 6370:  pZip->m_archive_size = cur_archive_file_ofs;
        -: 6371:
        -: 6372:  return MZ_TRUE;
        -: 6373:}
        -: 6374:#endif // #ifndef MINIZ_NO_STDIO
        -: 6375:
        -: 6376:mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,
        -: 6377:                                          mz_zip_archive *pSource_zip,
        -: 6378:                                          mz_uint file_index) {
        -: 6379:  mz_uint n, bit_flags, num_alignment_padding_bytes;
        -: 6380:  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;
        -: 6381:  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
        -: 6382:  mz_uint32
        -: 6383:      local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /
        -: 6384:                       sizeof(mz_uint32)];
        -: 6385:  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
        -: 6386:  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
        -: 6387:  size_t orig_central_dir_size;
        -: 6388:  mz_zip_internal_state *pState;
        -: 6389:  void *pBuf;
        -: 6390:  const mz_uint8 *pSrc_central_header;
        -: 6391:
        -: 6392:  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
        -: 6393:    return MZ_FALSE;
        -: 6394:  if (NULL ==
        -: 6395:      (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))
        -: 6396:    return MZ_FALSE;
        -: 6397:  pState = pZip->m_pState;
        -: 6398:
        -: 6399:  num_alignment_padding_bytes =
        -: 6400:      mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);
        -: 6401:
        -: 6402:  // no zip64 support yet
        -: 6403:  if ((pZip->m_total_files == 0xFFFF) ||
        -: 6404:      ((pZip->m_archive_size + num_alignment_padding_bytes +
        -: 6405:        MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) >
        -: 6406:       0xFFFFFFFF))
        -: 6407:    return MZ_FALSE;
        -: 6408:
        -: 6409:  cur_src_file_ofs =
        -: 6410:      MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
        -: 6411:  cur_dst_file_ofs = pZip->m_archive_size;
        -: 6412:
        -: 6413:  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs,
        -: 6414:                           pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
        -: 6415:      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        -: 6416:    return MZ_FALSE;
        -: 6417:  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        -: 6418:    return MZ_FALSE;
        -: 6419:  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
        -: 6420:
        -: 6421:  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs,
        -: 6422:                                 num_alignment_padding_bytes))
        -: 6423:    return MZ_FALSE;
        -: 6424:  cur_dst_file_ofs += num_alignment_padding_bytes;
        -: 6425:  local_dir_header_ofs = cur_dst_file_ofs;
        -: 6426:  if (pZip->m_file_offset_alignment) {
        -: 6427:    MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==
        -: 6428:              0);
        -: 6429:  }
        -: 6430:
        -: 6431:  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header,
        -: 6432:                     MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
        -: 6433:      MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        -: 6434:    return MZ_FALSE;
        -: 6435:  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;
        -: 6436:
        -: 6437:  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +
        -: 6438:      MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
        -: 6439:  comp_bytes_remaining =
        -: 6440:      n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
        -: 6441:
        -: 6442:  if (NULL ==
        -: 6443:      (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
        -: 6444:                             (size_t)MZ_MAX(sizeof(mz_uint32) * 4,
        -: 6445:                                            MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE,
        -: 6446:                                                   comp_bytes_remaining)))))
        -: 6447:    return MZ_FALSE;
        -: 6448:
        -: 6449:  while (comp_bytes_remaining) {
        -: 6450:    n = (mz_uint)MZ_MIN(MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);
        -: 6451:    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,
        -: 6452:                             n) != n) {
        -: 6453:      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        -: 6454:      return MZ_FALSE;
        -: 6455:    }
        -: 6456:    cur_src_file_ofs += n;
        -: 6457:
        -: 6458:    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
        -: 6459:      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        -: 6460:      return MZ_FALSE;
        -: 6461:    }
        -: 6462:    cur_dst_file_ofs += n;
        -: 6463:
        -: 6464:    comp_bytes_remaining -= n;
        -: 6465:  }
        -: 6466:
        -: 6467:  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
        -: 6468:  if (bit_flags & 8) {
        -: 6469:    // Copy data descriptor
        -: 6470:    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,
        -: 6471:                             sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4) {
        -: 6472:      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        -: 6473:      return MZ_FALSE;
        -: 6474:    }
        -: 6475:
        -: 6476:    n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);
        -: 6477:    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
        -: 6478:      pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        -: 6479:      return MZ_FALSE;
        -: 6480:    }
        -: 6481:
        -: 6482:    cur_src_file_ofs += n;
        -: 6483:    cur_dst_file_ofs += n;
        -: 6484:  }
        -: 6485:  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        -: 6486:
        -: 6487:  // no zip64 support yet
        -: 6488:  if (cur_dst_file_ofs > 0xFFFFFFFF)
        -: 6489:    return MZ_FALSE;
        -: 6490:
        -: 6491:  orig_central_dir_size = pState->m_central_dir.m_size;
        -: 6492:
        -: 6493:  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
        -: 6494:  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS,
        -: 6495:                local_dir_header_ofs);
        -: 6496:  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header,
        -: 6497:                              MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
        -: 6498:    return MZ_FALSE;
        -: 6499:
        -: 6500:  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) +
        -: 6501:      MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) +
        -: 6502:      MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
        -: 6503:  if (!mz_zip_array_push_back(
        -: 6504:          pZip, &pState->m_central_dir,
        -: 6505:          pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)) {
        -: 6506:    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,
        -: 6507:                        MZ_FALSE);
        -: 6508:    return MZ_FALSE;
        -: 6509:  }
        -: 6510:
        -: 6511:  if (pState->m_central_dir.m_size > 0xFFFFFFFF)
        -: 6512:    return MZ_FALSE;
        -: 6513:  n = (mz_uint32)orig_central_dir_size;
        -: 6514:  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1)) {
        -: 6515:    mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,
        -: 6516:                        MZ_FALSE);
        -: 6517:    return MZ_FALSE;
        -: 6518:  }
        -: 6519:
        -: 6520:  pZip->m_total_files++;
        -: 6521:  pZip->m_archive_size = cur_dst_file_ofs;
        -: 6522:
        -: 6523:  return MZ_TRUE;
        -: 6524:}
        -: 6525:
        -: 6526:mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip) {
        -: 6527:  mz_zip_internal_state *pState;
        -: 6528:  mz_uint64 central_dir_ofs, central_dir_size;
        -: 6529:  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];
        -: 6530:
        -: 6531:  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
        -: 6532:    return MZ_FALSE;
        -: 6533:
        -: 6534:  pState = pZip->m_pState;
        -: 6535:
        -: 6536:  // no zip64 support yet
        -: 6537:  if ((pZip->m_total_files > 0xFFFF) ||
        -: 6538:      ((pZip->m_archive_size + pState->m_central_dir.m_size +
        -: 6539:        MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
        -: 6540:    return MZ_FALSE;
        -: 6541:
        -: 6542:  central_dir_ofs = 0;
        -: 6543:  central_dir_size = 0;
        -: 6544:  if (pZip->m_total_files) {
        -: 6545:    // Write central directory
        -: 6546:    central_dir_ofs = pZip->m_archive_size;
        -: 6547:    central_dir_size = pState->m_central_dir.m_size;
        -: 6548:    pZip->m_central_directory_file_ofs = central_dir_ofs;
        -: 6549:    if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs,
        -: 6550:                       pState->m_central_dir.m_p,
        -: 6551:                       (size_t)central_dir_size) != central_dir_size)
        -: 6552:      return MZ_FALSE;
        -: 6553:    pZip->m_archive_size += central_dir_size;
        -: 6554:  }
        -: 6555:
        -: 6556:  // Write end of central directory record
        -: 6557:  MZ_CLEAR_OBJ(hdr);
        -: 6558:  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS,
        -: 6559:                MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
        -: 6560:  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS,
        -: 6561:                pZip->m_total_files);
        -: 6562:  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
        -: 6563:  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);
        -: 6564:  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);
        -: 6565:
        -: 6566:  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr,
        -: 6567:                     sizeof(hdr)) != sizeof(hdr))
        -: 6568:    return MZ_FALSE;
        -: 6569:#ifndef MINIZ_NO_STDIO
        -: 6570:  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
        -: 6571:    return MZ_FALSE;
        -: 6572:#endif // #ifndef MINIZ_NO_STDIO
        -: 6573:
        -: 6574:  pZip->m_archive_size += sizeof(hdr);
        -: 6575:
        -: 6576:  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
        -: 6577:  return MZ_TRUE;
        -: 6578:}
        -: 6579:
        -: 6580:mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,
        -: 6581:                                            size_t *pSize) {
        -: 6582:  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize))
        -: 6583:    return MZ_FALSE;
        -: 6584:  if (pZip->m_pWrite != mz_zip_heap_write_func)
        -: 6585:    return MZ_FALSE;
        -: 6586:  if (!mz_zip_writer_finalize_archive(pZip))
        -: 6587:    return MZ_FALSE;
        -: 6588:
        -: 6589:  *pBuf = pZip->m_pState->m_pMem;
        -: 6590:  *pSize = pZip->m_pState->m_mem_size;
        -: 6591:  pZip->m_pState->m_pMem = NULL;
        -: 6592:  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
        -: 6593:  return MZ_TRUE;
        -: 6594:}
        -: 6595:
        -: 6596:mz_bool mz_zip_writer_end(mz_zip_archive *pZip) {
        -: 6597:  mz_zip_internal_state *pState;
        -: 6598:  mz_bool status = MZ_TRUE;
        -: 6599:  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||
        -: 6600:      ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) &&
        -: 6601:       (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
        -: 6602:    return MZ_FALSE;
        -: 6603:
        -: 6604:  pState = pZip->m_pState;
        -: 6605:  pZip->m_pState = NULL;
        -: 6606:  mz_zip_array_clear(pZip, &pState->m_central_dir);
        -: 6607:  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
        -: 6608:  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);
        -: 6609:
        -: 6610:#ifndef MINIZ_NO_STDIO
        -: 6611:  if (pState->m_pFile) {
        -: 6612:    MZ_FCLOSE(pState->m_pFile);
        -: 6613:    pState->m_pFile = NULL;
        -: 6614:  }
        -: 6615:#endif // #ifndef MINIZ_NO_STDIO
        -: 6616:
        -: 6617:  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem)) {
        -: 6618:    pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
        -: 6619:    pState->m_pMem = NULL;
        -: 6620:  }
        -: 6621:
        -: 6622:  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        -: 6623:  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
        -: 6624:  return status;
        -: 6625:}
        -: 6626:
        -: 6627:#ifndef MINIZ_NO_STDIO
        -: 6628:mz_bool mz_zip_add_mem_to_archive_file_in_place(
        -: 6629:    const char *pZip_filename, const char *pArchive_name, const void *pBuf,
        -: 6630:    size_t buf_size, const void *pComment, mz_uint16 comment_size,
        -: 6631:    mz_uint level_and_flags) {
        -: 6632:  mz_bool status, created_new_archive = MZ_FALSE;
        -: 6633:  mz_zip_archive zip_archive;
        -: 6634:  struct MZ_FILE_STAT_STRUCT file_stat;
        -: 6635:  MZ_CLEAR_OBJ(zip_archive);
        -: 6636:  if ((int)level_and_flags < 0)
        -: 6637:    level_and_flags = MZ_DEFAULT_LEVEL;
        -: 6638:  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) ||
        -: 6639:      ((comment_size) && (!pComment)) ||
        -: 6640:      ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
        -: 6641:    return MZ_FALSE;
        -: 6642:  if (!mz_zip_writer_validate_archive_name(pArchive_name))
        -: 6643:    return MZ_FALSE;
        -: 6644:  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0) {
        -: 6645:    // Create a new archive.
        -: 6646:    if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))
        -: 6647:      return MZ_FALSE;
        -: 6648:    created_new_archive = MZ_TRUE;
        -: 6649:  } else {
        -: 6650:    // Append to an existing archive.
        -: 6651:    if (!mz_zip_reader_init_file(&zip_archive, pZip_filename,
        -: 6652:                                 level_and_flags |
        -: 6653:                                     MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
        -: 6654:      return MZ_FALSE;
        -: 6655:    if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename)) {
        -: 6656:      mz_zip_reader_end(&zip_archive);
        -: 6657:      return MZ_FALSE;
        -: 6658:    }
        -: 6659:  }
        -: 6660:  status =
        -: 6661:      mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size,
        -: 6662:                               pComment, comment_size, level_and_flags, 0, 0);
        -: 6663:  // Always finalize, even if adding failed for some reason, so we have a valid
        -: 6664:  // central directory. (This may not always succeed, but we can try.)
        -: 6665:  if (!mz_zip_writer_finalize_archive(&zip_archive))
        -: 6666:    status = MZ_FALSE;
        -: 6667:  if (!mz_zip_writer_end(&zip_archive))
        -: 6668:    status = MZ_FALSE;
        -: 6669:  if ((!status) && (created_new_archive)) {
        -: 6670:    // It's a new archive and something went wrong, so just delete it.
        -: 6671:    int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
        -: 6672:    (void)ignoredStatus;
        -: 6673:  }
        -: 6674:  return status;
        -: 6675:}
        -: 6676:
        -: 6677:void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,
        -: 6678:                                          const char *pArchive_name,
        -: 6679:                                          size_t *pSize, mz_uint flags) {
        -: 6680:  int file_index;
        -: 6681:  mz_zip_archive zip_archive;
        -: 6682:  void *p = NULL;
        -: 6683:
        -: 6684:  if (pSize)
        -: 6685:    *pSize = 0;
        -: 6686:
        -: 6687:  if ((!pZip_filename) || (!pArchive_name))
        -: 6688:    return NULL;
        -: 6689:
        -: 6690:  MZ_CLEAR_OBJ(zip_archive);
        -: 6691:  if (!mz_zip_reader_init_file(&zip_archive, pZip_filename,
        -: 6692:                               flags |
        -: 6693:                                   MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
        -: 6694:    return NULL;
        -: 6695:
        -: 6696:  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL,
        -: 6697:                                              flags)) >= 0)
        -: 6698:    p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
        -: 6699:
        -: 6700:  mz_zip_reader_end(&zip_archive);
        -: 6701:  return p;
        -: 6702:}
        -: 6703:
        -: 6704:#endif // #ifndef MINIZ_NO_STDIO
        -: 6705:
        -: 6706:#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
        -: 6707:
        -: 6708:#endif // #ifndef MINIZ_NO_ARCHIVE_APIS
        -: 6709:
        -: 6710:#ifdef __cplusplus
        -: 6711:}
        -: 6712:#endif
        -: 6713:
        -: 6714:#endif // MINIZ_HEADER_FILE_ONLY
        -: 6715:
        -: 6716:/*
        -: 6717:  This is free and unencumbered software released into the public domain.
        -: 6718:
        -: 6719:  Anyone is free to copy, modify, publish, use, compile, sell, or
        -: 6720:  distribute this software, either in source code form or as a compiled
        -: 6721:  binary, for any purpose, commercial or non-commercial, and by any
        -: 6722:  means.
        -: 6723:
        -: 6724:  In jurisdictions that recognize copyright laws, the author or authors
        -: 6725:  of this software dedicate any and all copyright interest in the
        -: 6726:  software to the public domain. We make this dedication for the benefit
        -: 6727:  of the public at large and to the detriment of our heirs and
        -: 6728:  successors. We intend this dedication to be an overt act of
        -: 6729:  relinquishment in perpetuity of all present and future rights to this
        -: 6730:  software under copyright law.
        -: 6731:
        -: 6732:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
        -: 6733:  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        -: 6734:  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        -: 6735:  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
        -: 6736:  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
        -: 6737:  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        -: 6738:  OTHER DEALINGS IN THE SOFTWARE.
        -: 6739:
        -: 6740:  For more information, please refer to <http://unlicense.org/>
        -: 6741:*/
        -: 6742:
        -: 6743:// ---------------------- end of miniz ----------------------------------------
        -: 6744:}
        -: 6745:
    #####: 6746:bool IsBigEndian(void) {
    #####: 6747:  union {
        -: 6748:    unsigned int i;
        -: 6749:    char c[4];
        -: 6750:  } bint = {0x01020304};
        -: 6751:
    #####: 6752:  return bint.c[0] == 1;
        -: 6753:}
        -: 6754:
        -: 6755:void swap2(unsigned short *val) {
        -: 6756:  unsigned short tmp = *val;
        -: 6757:  unsigned char *dst = (unsigned char *)val;
        -: 6758:  unsigned char *src = (unsigned char *)&tmp;
        -: 6759:
        -: 6760:  dst[0] = src[1];
        -: 6761:  dst[1] = src[0];
        -: 6762:}
        -: 6763:
        -: 6764:void swap4(unsigned int *val) {
        -: 6765:  unsigned int tmp = *val;
        -: 6766:  unsigned char *dst = (unsigned char *)val;
        -: 6767:  unsigned char *src = (unsigned char *)&tmp;
        -: 6768:
        -: 6769:  dst[0] = src[3];
        -: 6770:  dst[1] = src[2];
        -: 6771:  dst[2] = src[1];
        -: 6772:  dst[3] = src[0];
        -: 6773:}
        -: 6774:
        -: 6775:void swap8(unsigned long long *val) {
        -: 6776:  unsigned long long tmp = (*val);
        -: 6777:  unsigned char *dst = (unsigned char *)val;
        -: 6778:  unsigned char *src = (unsigned char *)&tmp;
        -: 6779:
        -: 6780:  dst[0] = src[7];
        -: 6781:  dst[1] = src[6];
        -: 6782:  dst[2] = src[5];
        -: 6783:  dst[3] = src[4];
        -: 6784:  dst[4] = src[3];
        -: 6785:  dst[5] = src[2];
        -: 6786:  dst[6] = src[1];
        -: 6787:  dst[7] = src[0];
        -: 6788:}
        -: 6789:
        -: 6790:// https://gist.github.com/rygorous/2156668
        -: 6791:// Reuse MINIZ_LITTLE_ENDIAN flag from miniz.
        -: 6792:union FP32 {
        -: 6793:  unsigned int u;
        -: 6794:  float f;
        -: 6795:  struct {
        -: 6796:#if MINIZ_LITTLE_ENDIAN
        -: 6797:    unsigned int Mantissa : 23;
        -: 6798:    unsigned int Exponent : 8;
        -: 6799:    unsigned int Sign : 1;
        -: 6800:#else
        -: 6801:    unsigned int Sign : 1;
        -: 6802:    unsigned int Exponent : 8;
        -: 6803:    unsigned int Mantissa : 23;
        -: 6804:#endif
        -: 6805:  } s;
        -: 6806:};
        -: 6807:
        -: 6808:union FP16 {
        -: 6809:  unsigned short u;
        -: 6810:  struct {
        -: 6811:#if MINIZ_LITTLE_ENDIAN
        -: 6812:    unsigned int Mantissa : 10;
        -: 6813:    unsigned int Exponent : 5;
        -: 6814:    unsigned int Sign : 1;
        -: 6815:#else
        -: 6816:    unsigned int Sign : 1;
        -: 6817:    unsigned int Exponent : 5;
        -: 6818:    unsigned int Mantissa : 10;
        -: 6819:#endif
        -: 6820:  } s;
        -: 6821:};
        -: 6822:
        -: 6823:FP32 half_to_float(FP16 h) {
        -: 6824:  static const FP32 magic = {113 << 23};
        -: 6825:  static const unsigned int shifted_exp = 0x7c00
        -: 6826:                                          << 13; // exponent mask after shift
        -: 6827:  FP32 o;
        -: 6828:
        -: 6829:  o.u = (h.u & 0x7fff) << 13;            // exponent/mantissa bits
        -: 6830:  unsigned int exp_ = shifted_exp & o.u; // just the exponent
        -: 6831:  o.u += (127 - 15) << 23;               // exponent adjust
        -: 6832:
        -: 6833:  // handle exponent special cases
        -: 6834:  if (exp_ == shifted_exp)   // Inf/NaN?
        -: 6835:    o.u += (128 - 16) << 23; // extra exp adjust
        -: 6836:  else if (exp_ == 0)        // Zero/Denormal?
        -: 6837:  {
        -: 6838:    o.u += 1 << 23; // extra exp adjust
        -: 6839:    o.f -= magic.f; // renormalize
        -: 6840:  }
        -: 6841:
        -: 6842:  o.u |= (h.u & 0x8000) << 16; // sign bit
        -: 6843:  return o;
        -: 6844:}
        -: 6845:
    #####: 6846:FP16 float_to_half_full(FP32 f) {
    #####: 6847:  FP16 o = {0};
        -: 6848:
        -: 6849:  // Based on ISPC reference code (with minor modifications)
    #####: 6850:  if (f.s.Exponent == 0) // Signed zero/denormal (which will underflow)
    %%%%%: 6850-block  0
    #####: 6851:    o.s.Exponent = 0;
    %%%%%: 6851-block  0
    #####: 6852:  else if (f.s.Exponent == 255) // Inf or NaN (all exponent bits set)
    %%%%%: 6852-block  0
        -: 6853:  {
    #####: 6854:    o.s.Exponent = 31;
    #####: 6855:    o.s.Mantissa = f.s.Mantissa ? 0x200 : 0; // NaN->qNaN and Inf->Inf
    %%%%%: 6855-block  0
    %%%%%: 6855-block  1
        -: 6856:  } else                                     // Normalized number
        -: 6857:  {
        -: 6858:    // Exponent unbias the single, then bias the halfp
    #####: 6859:    int newexp = f.s.Exponent - 127 + 15;
    #####: 6860:    if (newexp >= 31) // Overflow, return signed infinity
    %%%%%: 6860-block  0
    #####: 6861:      o.s.Exponent = 31;
    %%%%%: 6861-block  0
    #####: 6862:    else if (newexp <= 0) // Underflow
    %%%%%: 6862-block  0
        -: 6863:    {
    #####: 6864:      if ((14 - newexp) <= 24) // Mantissa might be non-zero
    %%%%%: 6864-block  0
        -: 6865:      {
    #####: 6866:        unsigned int mant = f.s.Mantissa | 0x800000; // Hidden 1 bit
    #####: 6867:        o.s.Mantissa = mant >> (14 - newexp);
    #####: 6868:        if ((mant >> (13 - newexp)) & 1) // Check for rounding
    %%%%%: 6868-block  0
    #####: 6869:          o.u++; // Round, might overflow into exp bit, but this is OK
    %%%%%: 6869-block  0
        -: 6870:      }
        -: 6871:    } else {
    #####: 6872:      o.s.Exponent = newexp;
    #####: 6873:      o.s.Mantissa = f.s.Mantissa >> 13;
    #####: 6874:      if (f.s.Mantissa & 0x1000) // Check for rounding
    %%%%%: 6874-block  0
    #####: 6875:        o.u++;                   // Round, might overflow to inf, this is OK
    %%%%%: 6875-block  0
        -: 6876:    }
        -: 6877:  }
        -: 6878:
    #####: 6879:  o.s.Sign = f.s.Sign;
    #####: 6880:  return o;
        -: 6881:}
        -: 6882:
        -: 6883:// NOTE: From OpenEXR code
        -: 6884:// #define IMF_INCREASING_Y  0
        -: 6885:// #define IMF_DECREASING_Y  1
        -: 6886:// #define IMF_RAMDOM_Y    2
        -: 6887://
        -: 6888:// #define IMF_NO_COMPRESSION  0
        -: 6889:// #define IMF_RLE_COMPRESSION 1
        -: 6890:// #define IMF_ZIPS_COMPRESSION  2
        -: 6891:// #define IMF_ZIP_COMPRESSION 3
        -: 6892:// #define IMF_PIZ_COMPRESSION 4
        -: 6893:// #define IMF_PXR24_COMPRESSION 5
        -: 6894:// #define IMF_B44_COMPRESSION 6
        -: 6895:// #define IMF_B44A_COMPRESSION  7
        -: 6896:
    #####: 6897:const char *ReadString(std::string &s, const char *ptr) {
        -: 6898:  // Read untile NULL(\0).
    #####: 6899:  const char *p = ptr;
    #####: 6900:  const char *q = ptr;
    %%%%%: 6900-block  0
    #####: 6901:  while ((*q) != 0)
    %%%%%: 6901-block  0
    #####: 6902:    q++;
    %%%%%: 6902-block  0
        -: 6903:
    #####: 6904:  s = std::string(p, q);
    %%%%%: 6904-block  0
        -: 6905:
    #####: 6906:  return q + 1; // skip '\0'
        -: 6907:}
        -: 6908:
    #####: 6909:const char *ReadAttribute(std::string &name, std::string &ty,
        -: 6910:                          std::vector<unsigned char> &data, const char *ptr) {
        -: 6911:
    #####: 6912:  if ((*ptr) == 0) {
    %%%%%: 6912-block  0
        -: 6913:    // end of attribute.
        -: 6914:    return NULL;
        -: 6915:  }
        -: 6916:
    #####: 6917:  const char *p = ReadString(name, ptr);
    %%%%%: 6917-block  0
        -: 6918:
    #####: 6919:  p = ReadString(ty, p);
        -: 6920:
    #####: 6921:  int dataLen;
    #####: 6922:  memcpy(&dataLen, p, sizeof(int));
    #####: 6923:  p += 4;
        -: 6924:
    #####: 6925:  if (IsBigEndian()) {
    #####: 6926:    swap4(reinterpret_cast<unsigned int *>(&dataLen));
        -: 6927:  }
        -: 6928:
    #####: 6929:  data.resize(dataLen);
    #####: 6930:  memcpy(&data.at(0), p, dataLen);
    %%%%%: 6930-block  0
    #####: 6931:  p += dataLen;
        -: 6932:
    #####: 6933:  return p;
    %%%%%: 6933-block  0
        -: 6934:}
        -: 6935:
        -: 6936:void WriteAttribute(FILE *fp, const char *name, const char *type,
        -: 6937:                    const unsigned char *data, int len) {
        -: 6938:  size_t n = fwrite(name, 1, strlen(name) + 1, fp);
        -: 6939:  assert(n == strlen(name) + 1);
        -: 6940:
        -: 6941:  n = fwrite(type, 1, strlen(type) + 1, fp);
        -: 6942:  assert(n == strlen(type) + 1);
        -: 6943:
        -: 6944:  int outLen = len;
        -: 6945:  if (IsBigEndian()) {
        -: 6946:    swap4(reinterpret_cast<unsigned int *>(&outLen));
        -: 6947:  }
        -: 6948:  n = fwrite(&outLen, 1, sizeof(int), fp);
        -: 6949:  assert(n == sizeof(int));
        -: 6950:
        -: 6951:  n = fwrite(data, 1, len, fp);
        -: 6952:  assert(n == (size_t)len);
        -: 6953:
        -: 6954:  (void)n;
        -: 6955:}
        -: 6956:
    #####: 6957:void WriteAttributeToMemory(std::vector<unsigned char> &out, const char *name,
        -: 6958:                            const char *type, const unsigned char *data,
        -: 6959:                            int len) {
    #####: 6960:  out.insert(out.end(), name, name + strlen(name) + 1);
    %%%%%: 6960-block  0
    #####: 6961:  out.insert(out.end(), type, type + strlen(type) + 1);
        -: 6962:
    #####: 6963:  int outLen = len;
    #####: 6964:  if (IsBigEndian()) {
    #####: 6965:    swap4(reinterpret_cast<unsigned int *>(&outLen));
        -: 6966:  }
    #####: 6967:  out.insert(out.end(), reinterpret_cast<unsigned char *>(&outLen),
    #####: 6968:             reinterpret_cast<unsigned char *>(&outLen) + sizeof(int));
    #####: 6969:  out.insert(out.end(), data, data + len);
    #####: 6970:}
        -: 6971:
        -: 6972:typedef struct {
        -: 6973:  std::string name; // less than 255 bytes long
        -: 6974:  int pixelType;
        -: 6975:  unsigned char pLinear;
        -: 6976:  int xSampling;
        -: 6977:  int ySampling;
    #####: 6978:} ChannelInfo;
    $$$$$: 6978-block  0
    $$$$$: 6978-block  1
    %%%%%: 6978-block  2
    %%%%%: 6978-block  3
    %%%%%: 6978-block  4
    $$$$$: 6978-block  5
    %%%%%: 6978-block  6
    $$$$$: 6978-block  7
        -: 6979:
    #####: 6980:void ReadChannelInfo(std::vector<ChannelInfo> &channels,
        -: 6981:                     const std::vector<unsigned char> &data) {
    #####: 6982:  const char *p = reinterpret_cast<const char *>(&data.at(0));
    %%%%%: 6982-block  0
        -: 6983:
    #####: 6984:  for (;;) {
    #####: 6985:    if ((*p) == 0) {
    %%%%%: 6985-block  0
        -: 6986:      break;
        -: 6987:    }
    #####: 6988:    ChannelInfo info;
    %%%%%: 6988-block  0
    #####: 6989:    p = ReadString(info.name, p);
    %%%%%: 6989-block  0
        -: 6990:
    #####: 6991:    memcpy(&info.pixelType, p, sizeof(int));
    %%%%%: 6991-block  0
    #####: 6992:    p += 4;
    #####: 6993:    info.pLinear = p[0];                     // uchar
    #####: 6994:    p += 1 + 3;                              // reserved: uchar[3]
    #####: 6995:    memcpy(&info.xSampling, p, sizeof(int)); // int
    #####: 6996:    p += 4;
    #####: 6997:    memcpy(&info.ySampling, p, sizeof(int)); // int
    #####: 6998:    p += 4;
        -: 6999:
    #####: 7000:    if (IsBigEndian()) {
        -: 7001:      swap4(reinterpret_cast<unsigned int *>(&info.pixelType));
        -: 7002:      swap4(reinterpret_cast<unsigned int *>(&info.xSampling));
    #####: 7003:      swap4(reinterpret_cast<unsigned int *>(&info.ySampling));
        -: 7004:    }
        -: 7005:
    #####: 7006:    channels.push_back(info);
    %%%%%: 7006-block  0
    #####: 7007:  }
    %%%%%: 7007-block  0
    #####: 7008:}
    %%%%%: 7008-block  0
        -: 7009:
    #####: 7010:void WriteChannelInfo(std::vector<unsigned char> &data,
        -: 7011:                      const std::vector<ChannelInfo> &channels) {
        -: 7012:
    #####: 7013:  size_t sz = 0;
        -: 7014:
        -: 7015:  // Calculate total size.
    #####: 7016:  for (size_t c = 0; c < channels.size(); c++) {
    %%%%%: 7016-block  0
    %%%%%: 7016-block  1
    #####: 7017:    sz += strlen(channels[c].name.c_str()) + 1; // +1 for \0
    %%%%%: 7017-block  0
    #####: 7018:    sz += 16;                                   // 4 * int
    %%%%%: 7018-block  0
        -: 7019:  }
    #####: 7020:  data.resize(sz + 1);
    %%%%%: 7020-block  0
        -: 7021:
    #####: 7022:  unsigned char *p = &data.at(0);
        -: 7023:
    #####: 7024:  for (size_t c = 0; c < channels.size(); c++) {
    %%%%%: 7024-block  0
    #####: 7025:    memcpy(p, channels[c].name.c_str(), strlen(channels[c].name.c_str()));
    %%%%%: 7025-block  0
    #####: 7026:    p += strlen(channels[c].name.c_str());
    #####: 7027:    (*p) = '\0';
    #####: 7028:    p++;
        -: 7029:
    #####: 7030:    int pixelType = channels[c].pixelType;
    #####: 7031:    int xSampling = channels[c].xSampling;
    #####: 7032:    int ySampling = channels[c].ySampling;
    #####: 7033:    if (IsBigEndian()) {
        -: 7034:      swap4(reinterpret_cast<unsigned int *>(&pixelType));
        -: 7035:      swap4(reinterpret_cast<unsigned int *>(&xSampling));
    #####: 7036:      swap4(reinterpret_cast<unsigned int *>(&ySampling));
        -: 7037:    }
        -: 7038:
    #####: 7039:    memcpy(p, &pixelType, sizeof(int));
    #####: 7040:    p += sizeof(int);
        -: 7041:
    #####: 7042:    (*p) = channels[c].pLinear;
    #####: 7043:    p += 4;
        -: 7044:
    #####: 7045:    memcpy(p, &xSampling, sizeof(int));
    #####: 7046:    p += sizeof(int);
        -: 7047:
    #####: 7048:    memcpy(p, &ySampling, sizeof(int));
    #####: 7049:    p += sizeof(int);
    %%%%%: 7049-block  0
        -: 7050:  }
        -: 7051:
    #####: 7052:  (*p) = '\0';
    #####: 7053:}
        -: 7054:
    #####: 7055:void CompressZip(unsigned char *dst, unsigned long long &compressedSize,
        -: 7056:                 const unsigned char *src, unsigned long srcSize) {
        -: 7057:
    #####: 7058:  std::vector<unsigned char> tmpBuf(srcSize);
    %%%%%: 7058-block  0
        -: 7059:
        -: 7060:  //
        -: 7061:  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's
        -: 7062:  // ImfZipCompressor.cpp
        -: 7063:  //
        -: 7064:
        -: 7065:  //
        -: 7066:  // Reorder the pixel data.
        -: 7067:  //
        -: 7068:
    #####: 7069:  {
    #####: 7070:    char *t1 = (char *)&tmpBuf.at(0);
    #####: 7071:    char *t2 = (char *)&tmpBuf.at(0) + (srcSize + 1) / 2;
    %%%%%: 7071-block  0
    #####: 7072:    const char *stop = (const char *)src + srcSize;
    %%%%%: 7072-block  0
        -: 7073:
    #####: 7074:    while (true) {
    #####: 7075:      if ((const char *)src < stop)
    %%%%%: 7075-block  0
    #####: 7076:        *(t1++) = *(src++);
        -: 7077:      else
        -: 7078:        break;
        -: 7079:
    #####: 7080:      if ((const char *)src < stop)
    %%%%%: 7080-block  0
    #####: 7081:        *(t2++) = *(src++);
    %%%%%: 7081-block  0
        -: 7082:      else
        -: 7083:        break;
        -: 7084:    }
        -: 7085:  }
        -: 7086:
        -: 7087:  //
        -: 7088:  // Predictor.
        -: 7089:  //
        -: 7090:
    #####: 7091:  {
    #####: 7092:    unsigned char *t = &tmpBuf.at(0) + 1;
    %%%%%: 7092-block  0
    #####: 7093:    unsigned char *stop = &tmpBuf.at(0) + srcSize;
    %%%%%: 7093-block  0
    #####: 7094:    int p = t[-1];
    %%%%%: 7094-block  0
        -: 7095:
    #####: 7096:    while (t < stop) {
    %%%%%: 7096-block  0
    #####: 7097:      int d = int(t[0]) - p + (128 + 256);
    #####: 7098:      p = t[0];
    #####: 7099:      t[0] = d;
    #####: 7100:      ++t;
    %%%%%: 7100-block  0
        -: 7101:    }
        -: 7102:  }
        -: 7103:
        -: 7104:  //
        -: 7105:  // Compress the data using miniz
        -: 7106:  //
        -: 7107:
    #####: 7108:  miniz::mz_ulong outSize = miniz::mz_compressBound(srcSize);
    #####: 7109:  int ret = miniz::mz_compress(dst, &outSize,
    %%%%%: 7109-block  0
    #####: 7110:                               (const unsigned char *)&tmpBuf.at(0), srcSize);
    %%%%%: 7110-block  0
    #####: 7111:  assert(ret == miniz::MZ_OK);
    %%%%%: 7111-block  0
    %%%%%: 7111-block  1
    #####: 7112:  (void)ret;
        -: 7113:
    #####: 7114:  compressedSize = outSize;
    %%%%%: 7114-block  0
    #####: 7115:}
    %%%%%: 7115-block  0
        -: 7116:
    #####: 7117:void DecompressZip(unsigned char *dst, unsigned long &uncompressedSize,
        -: 7118:                   const unsigned char *src, unsigned long srcSize) {
    #####: 7119:  std::vector<unsigned char> tmpBuf(uncompressedSize);
    %%%%%: 7119-block  0
        -: 7120:
    #####: 7121:  int ret =
    #####: 7122:      miniz::mz_uncompress(&tmpBuf.at(0), &uncompressedSize, src, srcSize);
    %%%%%: 7122-block  0
    #####: 7123:  assert(ret == miniz::MZ_OK);
    %%%%%: 7123-block  0
    %%%%%: 7123-block  1
    #####: 7124:  (void)ret;
        -: 7125:
        -: 7126:  //
        -: 7127:  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's
        -: 7128:  // ImfZipCompressor.cpp
        -: 7129:  //
        -: 7130:
        -: 7131:  // Predictor.
    #####: 7132:  {
    #####: 7133:    unsigned char *t = &tmpBuf.at(0) + 1;
    %%%%%: 7133-block  0
    #####: 7134:    unsigned char *stop = &tmpBuf.at(0) + uncompressedSize;
    %%%%%: 7134-block  0
        -: 7135:
    #####: 7136:    while (t < stop) {
    %%%%%: 7136-block  0
    #####: 7137:      int d = int(t[-1]) + int(t[0]) - 128;
    #####: 7138:      t[0] = d;
    #####: 7139:      ++t;
    %%%%%: 7139-block  0
        -: 7140:    }
        -: 7141:  }
        -: 7142:
        -: 7143:  // Reorder the pixel data.
    #####: 7144:  {
    #####: 7145:    const char *t1 = reinterpret_cast<const char *>(&tmpBuf.at(0));
    %%%%%: 7145-block  0
    #####: 7146:    const char *t2 = reinterpret_cast<const char *>(&tmpBuf.at(0)) +
    %%%%%: 7146-block  0
    #####: 7147:                     (uncompressedSize + 1) / 2;
    #####: 7148:    char *s = reinterpret_cast<char *>(dst);
    #####: 7149:    char *stop = s + uncompressedSize;
    %%%%%: 7149-block  0
        -: 7150:
    #####: 7151:    while (true) {
    #####: 7152:      if (s < stop)
    %%%%%: 7152-block  0
    #####: 7153:        *(s++) = *(t1++);
        -: 7154:      else
        -: 7155:        break;
        -: 7156:
    #####: 7157:      if (s < stop)
    %%%%%: 7157-block  0
    #####: 7158:        *(s++) = *(t2++);
    %%%%%: 7158-block  0
        -: 7159:      else
        -: 7160:        break;
        -: 7161:    }
        -: 7162:  }
    #####: 7163:}
    %%%%%: 7163-block  0
        -: 7164:
        -: 7165://
        -: 7166:// PIZ compress/uncompress, based on OpenEXR's ImfPizCompressor.cpp
        -: 7167://
        -: 7168:// -----------------------------------------------------------------
        -: 7169:// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas
        -: 7170:// Digital Ltd. LLC)
        -: 7171:// (3 clause BSD license)
        -: 7172://
        -: 7173:
        -: 7174:struct PIZChannelData {
        -: 7175:  unsigned short *start;
        -: 7176:  unsigned short *end;
        -: 7177:  int nx;
        -: 7178:  int ny;
        -: 7179:  int ys;
        -: 7180:  int size;
        -: 7181:};
        -: 7182:
        -: 7183://-----------------------------------------------------------------------------
        -: 7184://
        -: 7185://  16-bit Haar Wavelet encoding and decoding
        -: 7186://
        -: 7187://  The source code in this file is derived from the encoding
        -: 7188://  and decoding routines written by Christian Rouet for his
        -: 7189://  PIZ image file format.
        -: 7190://
        -: 7191://-----------------------------------------------------------------------------
        -: 7192:
        -: 7193://
        -: 7194:// Wavelet basis functions without modulo arithmetic; they produce
        -: 7195:// the best compression ratios when the wavelet-transformed data are
        -: 7196:// Huffman-encoded, but the wavelet transform works only for 14-bit
        -: 7197:// data (untransformed data values must be less than (1 << 14)).
        -: 7198://
        -: 7199:
        -: 7200:#if 0 // @todo
        -: 7201:inline void wenc14(unsigned short a, unsigned short b, unsigned short &l,
        -: 7202:                   unsigned short &h) {
        -: 7203:  short as = a;
        -: 7204:  short bs = b;
        -: 7205:
        -: 7206:  short ms = (as + bs) >> 1;
        -: 7207:  short ds = as - bs;
        -: 7208:
        -: 7209:  l = ms;
        -: 7210:  h = ds;
        -: 7211:}
        -: 7212:#endif
        -: 7213:
    #####: 7214:inline void wdec14(unsigned short l, unsigned short h, unsigned short &a,
        -: 7215:                   unsigned short &b) {
    #####: 7216:  short ls = l;
    #####: 7217:  short hs = h;
        -: 7218:
    #####: 7219:  int hi = hs;
    #####: 7220:  int ai = ls + (hi & 1) + (hi >> 1);
        -: 7221:
    #####: 7222:  short as = ai;
    #####: 7223:  short bs = ai - hi;
        -: 7224:
    #####: 7225:  a = as;
    #####: 7226:  b = bs;
    #####: 7227:}
        -: 7228:
        -: 7229://
        -: 7230:// Wavelet basis functions with modulo arithmetic; they work with full
        -: 7231:// 16-bit data, but Huffman-encoding the wavelet-transformed data doesn't
        -: 7232:// compress the data quite as well.
        -: 7233://
        -: 7234:
        -: 7235:const int NBITS = 16;
        -: 7236:const int A_OFFSET = 1 << (NBITS - 1);
        -: 7237://const int M_OFFSET = 1 << (NBITS - 1);
        -: 7238:const int MOD_MASK = (1 << NBITS) - 1;
        -: 7239:
        -: 7240:#if 0 // @ood
        -: 7241:inline void wenc16(unsigned short a, unsigned short b, unsigned short &l,
        -: 7242:                   unsigned short &h) {
        -: 7243:  int ao = (a + A_OFFSET) & MOD_MASK;
        -: 7244:  int m = ((ao + b) >> 1);
        -: 7245:  int d = ao - b;
        -: 7246:
        -: 7247:  if (d < 0)
        -: 7248:    m = (m + M_OFFSET) & MOD_MASK;
        -: 7249:
        -: 7250:  d &= MOD_MASK;
        -: 7251:
        -: 7252:  l = m;
        -: 7253:  h = d;
        -: 7254:}
        -: 7255:#endif
        -: 7256:
    #####: 7257:inline void wdec16(unsigned short l, unsigned short h, unsigned short &a,
        -: 7258:                   unsigned short &b) {
    #####: 7259:  int m = l;
    #####: 7260:  int d = h;
    #####: 7261:  int bb = (m - (d >> 1)) & MOD_MASK;
    #####: 7262:  int aa = (d + bb - A_OFFSET) & MOD_MASK;
    #####: 7263:  b = bb;
    #####: 7264:  a = aa;
    #####: 7265:}
        -: 7266:
        -: 7267://
        -: 7268:// 2D Wavelet encoding:
        -: 7269://
        -: 7270:
        -: 7271:#if 0 // @todo
        -: 7272:void wav2Encode(unsigned short *in, // io: values are transformed in place
        -: 7273:                int nx,             // i : x size
        -: 7274:                int ox,             // i : x offset
        -: 7275:                int ny,             // i : y size
        -: 7276:                int oy,             // i : y offset
        -: 7277:                unsigned short mx)  // i : maximum in[x][y] value
        -: 7278:{
        -: 7279:  bool w14 = (mx < (1 << 14));
        -: 7280:  int n = (nx > ny) ? ny : nx;
        -: 7281:  int p = 1;  // == 1 <<  level
        -: 7282:  int p2 = 2; // == 1 << (level+1)
        -: 7283:
        -: 7284:  //
        -: 7285:  // Hierachical loop on smaller dimension n
        -: 7286:  //
        -: 7287:
        -: 7288:  while (p2 <= n) {
        -: 7289:    unsigned short *py = in;
        -: 7290:    unsigned short *ey = in + oy * (ny - p2);
        -: 7291:    int oy1 = oy * p;
        -: 7292:    int oy2 = oy * p2;
        -: 7293:    int ox1 = ox * p;
        -: 7294:    int ox2 = ox * p2;
        -: 7295:    unsigned short i00, i01, i10, i11;
        -: 7296:
        -: 7297:    //
        -: 7298:    // Y loop
        -: 7299:    //
        -: 7300:
        -: 7301:    for (; py <= ey; py += oy2) {
        -: 7302:      unsigned short *px = py;
        -: 7303:      unsigned short *ex = py + ox * (nx - p2);
        -: 7304:
        -: 7305:      //
        -: 7306:      // X loop
        -: 7307:      //
        -: 7308:
        -: 7309:      for (; px <= ex; px += ox2) {
        -: 7310:        unsigned short *p01 = px + ox1;
        -: 7311:        unsigned short *p10 = px + oy1;
        -: 7312:        unsigned short *p11 = p10 + ox1;
        -: 7313:
        -: 7314:        //
        -: 7315:        // 2D wavelet encoding
        -: 7316:        //
        -: 7317:
        -: 7318:        if (w14) {
        -: 7319:          wenc14(*px, *p01, i00, i01);
        -: 7320:          wenc14(*p10, *p11, i10, i11);
        -: 7321:          wenc14(i00, i10, *px, *p10);
        -: 7322:          wenc14(i01, i11, *p01, *p11);
        -: 7323:        } else {
        -: 7324:          wenc16(*px, *p01, i00, i01);
        -: 7325:          wenc16(*p10, *p11, i10, i11);
        -: 7326:          wenc16(i00, i10, *px, *p10);
        -: 7327:          wenc16(i01, i11, *p01, *p11);
        -: 7328:        }
        -: 7329:      }
        -: 7330:
        -: 7331:      //
        -: 7332:      // Encode (1D) odd column (still in Y loop)
        -: 7333:      //
        -: 7334:
        -: 7335:      if (nx & p) {
        -: 7336:        unsigned short *p10 = px + oy1;
        -: 7337:
        -: 7338:        if (w14)
        -: 7339:          wenc14(*px, *p10, i00, *p10);
        -: 7340:        else
        -: 7341:          wenc16(*px, *p10, i00, *p10);
        -: 7342:
        -: 7343:        *px = i00;
        -: 7344:      }
        -: 7345:    }
        -: 7346:
        -: 7347:    //
        -: 7348:    // Encode (1D) odd line (must loop in X)
        -: 7349:    //
        -: 7350:
        -: 7351:    if (ny & p) {
        -: 7352:      unsigned short *px = py;
        -: 7353:      unsigned short *ex = py + ox * (nx - p2);
        -: 7354:
        -: 7355:      for (; px <= ex; px += ox2) {
        -: 7356:        unsigned short *p01 = px + ox1;
        -: 7357:
        -: 7358:        if (w14)
        -: 7359:          wenc14(*px, *p01, i00, *p01);
        -: 7360:        else
        -: 7361:          wenc16(*px, *p01, i00, *p01);
        -: 7362:
        -: 7363:        *px = i00;
        -: 7364:      }
        -: 7365:    }
        -: 7366:
        -: 7367:    //
        -: 7368:    // Next level
        -: 7369:    //
        -: 7370:
        -: 7371:    p = p2;
        -: 7372:    p2 <<= 1;
        -: 7373:  }
        -: 7374:}
        -: 7375:#endif
        -: 7376:
        -: 7377://
        -: 7378:// 2D Wavelet decoding:
        -: 7379://
        -: 7380:
    #####: 7381:void wav2Decode(unsigned short *in, // io: values are transformed in place
        -: 7382:                int nx,             // i : x size
        -: 7383:                int ox,             // i : x offset
        -: 7384:                int ny,             // i : y size
        -: 7385:                int oy,             // i : y offset
        -: 7386:                unsigned short mx)  // i : maximum in[x][y] value
        -: 7387:{
    #####: 7388:  bool w14 = (mx < (1 << 14));
    #####: 7389:  int n = (nx > ny) ? ny : nx;
    #####: 7390:  int p = 1;
    %%%%%: 7390-block  0
    #####: 7391:  int p2;
        -: 7392:
        -: 7393:  //
        -: 7394:  // Search max level
        -: 7395:  //
        -: 7396:
    #####: 7397:  while (p <= n)
    %%%%%: 7397-block  0
    #####: 7398:    p <<= 1;
    %%%%%: 7398-block  0
        -: 7399:
    #####: 7400:  p >>= 1;
    #####: 7401:  p2 = p;
    #####: 7402:  p >>= 1;
    %%%%%: 7402-block  0
        -: 7403:
        -: 7404:  //
        -: 7405:  // Hierarchical loop on smaller dimension n
        -: 7406:  //
        -: 7407:
    #####: 7408:  while (p >= 1) {
    %%%%%: 7408-block  0
    #####: 7409:    unsigned short *py = in;
    #####: 7410:    unsigned short *ey = in + oy * (ny - p2);
    #####: 7411:    int oy1 = oy * p;
    #####: 7412:    int oy2 = oy * p2;
    #####: 7413:    int ox1 = ox * p;
    #####: 7414:    int ox2 = ox * p2;
    %%%%%: 7414-block  0
    #####: 7415:    unsigned short i00, i01, i10, i11;
        -: 7416:
        -: 7417:    //
        -: 7418:    // Y loop
        -: 7419:    //
        -: 7420:
    #####: 7421:    for (; py <= ey; py += oy2) {
    %%%%%: 7421-block  0
    %%%%%: 7421-block  1
    #####: 7422:      unsigned short *px = py;
    #####: 7423:      unsigned short *ex = py + ox * (nx - p2);
    %%%%%: 7423-block  0
        -: 7424:
        -: 7425:      //
        -: 7426:      // X loop
        -: 7427:      //
        -: 7428:
    #####: 7429:      for (; px <= ex; px += ox2) {
    %%%%%: 7429-block  0
    #####: 7430:        unsigned short *p01 = px + ox1;
    #####: 7431:        unsigned short *p10 = px + oy1;
    #####: 7432:        unsigned short *p11 = p10 + ox1;
        -: 7433:
        -: 7434:        //
        -: 7435:        // 2D wavelet decoding
        -: 7436:        //
        -: 7437:
    #####: 7438:        if (w14) {
    %%%%%: 7438-block  0
    #####: 7439:          wdec14(*px, *p10, i00, i10);
    #####: 7440:          wdec14(*p01, *p11, i01, i11);
    #####: 7441:          wdec14(i00, i01, *px, *p01);
    #####: 7442:          wdec14(i10, i11, *p10, *p11);
    %%%%%: 7442-block  0
        -: 7443:        } else {
    #####: 7444:          wdec16(*px, *p10, i00, i10);
    #####: 7445:          wdec16(*p01, *p11, i01, i11);
    #####: 7446:          wdec16(i00, i01, *px, *p01);
    #####: 7447:          wdec16(i10, i11, *p10, *p11);
    %%%%%: 7447-block  0
    %%%%%: 7447-block  1
        -: 7448:        }
        -: 7449:      }
        -: 7450:
        -: 7451:      //
        -: 7452:      // Decode (1D) odd column (still in Y loop)
        -: 7453:      //
        -: 7454:
    #####: 7455:      if (nx & p) {
    %%%%%: 7455-block  0
    #####: 7456:        unsigned short *p10 = px + oy1;
        -: 7457:
    #####: 7458:        if (w14)
    %%%%%: 7458-block  0
    #####: 7459:          wdec14(*px, *p10, i00, *p10);
    %%%%%: 7459-block  0
        -: 7460:        else
    #####: 7461:          wdec16(*px, *p10, i00, *p10);
    %%%%%: 7461-block  0
        -: 7462:
    #####: 7463:        *px = i00;
    %%%%%: 7463-block  0
        -: 7464:      }
        -: 7465:    }
        -: 7466:
        -: 7467:    //
        -: 7468:    // Decode (1D) odd line (must loop in X)
        -: 7469:    //
        -: 7470:
    #####: 7471:    if (ny & p) {
    %%%%%: 7471-block  0
    #####: 7472:      unsigned short *px = py;
    #####: 7473:      unsigned short *ex = py + ox * (nx - p2);
    %%%%%: 7473-block  0
        -: 7474:
    #####: 7475:      for (; px <= ex; px += ox2) {
    %%%%%: 7475-block  0
    #####: 7476:        unsigned short *p01 = px + ox1;
        -: 7477:
    #####: 7478:        if (w14)
    %%%%%: 7478-block  0
    #####: 7479:          wdec14(*px, *p01, i00, *p01);
    %%%%%: 7479-block  0
        -: 7480:        else
    #####: 7481:          wdec16(*px, *p01, i00, *p01);
    %%%%%: 7481-block  0
        -: 7482:
    #####: 7483:        *px = i00;
    %%%%%: 7483-block  0
        -: 7484:      }
        -: 7485:    }
        -: 7486:
        -: 7487:    //
        -: 7488:    // Next level
        -: 7489:    //
        -: 7490:
    #####: 7491:    p2 = p;
    #####: 7492:    p >>= 1;
    %%%%%: 7492-block  0
        -: 7493:  }
    #####: 7494:}
        -: 7495:
        -: 7496://-----------------------------------------------------------------------------
        -: 7497://
        -: 7498://	16-bit Huffman compression and decompression.
        -: 7499://
        -: 7500://	The source code in this file is derived from the 8-bit
        -: 7501://	Huffman compression and decompression routines written
        -: 7502://	by Christian Rouet for his PIZ image file format.
        -: 7503://
        -: 7504://-----------------------------------------------------------------------------
        -: 7505:
        -: 7506:// Adds some modification for tinyexr.
        -: 7507:
        -: 7508:const int HUF_ENCBITS = 16; // literal (value) bit length
        -: 7509:const int HUF_DECBITS = 14; // decoding bit size (>= 8)
        -: 7510:
        -: 7511:const int HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size
        -: 7512:const int HUF_DECSIZE = 1 << HUF_DECBITS;       // decoding table size
        -: 7513:const int HUF_DECMASK = HUF_DECSIZE - 1;
        -: 7514:
        -: 7515:struct HufDec { // short code		long code
        -: 7516:  //-------------------------------
        -: 7517:  int len : 8;  // code length		0
        -: 7518:  int lit : 24; // lit			p size
        -: 7519:  int *p;       // 0			lits
        -: 7520:};
        -: 7521:
    #####: 7522:inline long long hufLength(long long code) { return code & 63; }
        -: 7523:
    #####: 7524:inline long long hufCode(long long code) { return code >> 6; }
        -: 7525:
        -: 7526:#if 0  
        -: 7527:inline void outputBits(int nBits, long long bits, long long &c, int &lc,
        -: 7528:                       char *&out) {
        -: 7529:  c <<= nBits;
        -: 7530:  lc += nBits;
        -: 7531:
        -: 7532:  c |= bits;
        -: 7533:
        -: 7534:  while (lc >= 8)
        -: 7535:    *out++ = (c >> (lc -= 8));
        -: 7536:}
        -: 7537:#endif
        -: 7538:
    #####: 7539:inline long long getBits(int nBits, long long &c, int &lc, const char *&in) {
    #####: 7540:  while (lc < nBits) {
    %%%%%: 7540-block  0
    #####: 7541:    c = (c << 8) | *(unsigned char *)(in++);
    #####: 7542:    lc += 8;
    %%%%%: 7542-block  0
    %%%%%: 7542-block  1
        -: 7543:  }
        -: 7544:
    #####: 7545:  lc -= nBits;
    #####: 7546:  return (c >> lc) & ((1 << nBits) - 1);
        -: 7547:}
        -: 7548:
        -: 7549://
        -: 7550:// ENCODING TABLE BUILDING & (UN)PACKING
        -: 7551://
        -: 7552:
        -: 7553://
        -: 7554:// Build a "canonical" Huffman code table:
        -: 7555://	- for each (uncompressed) symbol, hcode contains the length
        -: 7556://	  of the corresponding code (in the compressed data)
        -: 7557://	- canonical codes are computed and stored in hcode
        -: 7558://	- the rules for constructing canonical codes are as follows:
        -: 7559://	  * shorter codes (if filled with zeroes to the right)
        -: 7560://	    have a numerically higher value than longer codes
        -: 7561://	  * for codes with the same length, numerical values
        -: 7562://	    increase with numerical symbol values
        -: 7563://	- because the canonical code table can be constructed from
        -: 7564://	  symbol lengths alone, the code table can be transmitted
        -: 7565://	  without sending the actual code values
        -: 7566://	- see http://www.compressconsult.com/huffman/
        -: 7567://
        -: 7568:
    #####: 7569:void hufCanonicalCodeTable(long long hcode[HUF_ENCSIZE]) {
    #####: 7570:  long long n[59];
        -: 7571:
        -: 7572:  //
        -: 7573:  // For each i from 0 through 58, count the
        -: 7574:  // number of different codes of length i, and
        -: 7575:  // store the count in n[i].
        -: 7576:  //
        -: 7577:
    #####: 7578:  for (int i = 0; i <= 58; ++i)
    %%%%%: 7578-block  0
    %%%%%: 7578-block  1
    #####: 7579:    n[i] = 0;
    %%%%%: 7579-block  0
        -: 7580:
    #####: 7581:  for (int i = 0; i < HUF_ENCSIZE; ++i)
    %%%%%: 7581-block  0
    #####: 7582:    n[hcode[i]] += 1;
    %%%%%: 7582-block  0
        -: 7583:
        -: 7584:  //
        -: 7585:  // For each i from 58 through 1, compute the
        -: 7586:  // numerically lowest code with length i, and
        -: 7587:  // store that code in n[i].
        -: 7588:  //
        -: 7589:
        -: 7590:  long long c = 0;
        -: 7591:
    #####: 7592:  for (int i = 58; i > 0; --i) {
    %%%%%: 7592-block  0
    #####: 7593:    long long nc = ((c + n[i]) >> 1);
    #####: 7594:    n[i] = c;
    #####: 7595:    c = nc;
    %%%%%: 7595-block  0
        -: 7596:  }
        -: 7597:
        -: 7598:  //
        -: 7599:  // hcode[i] contains the length, l, of the
        -: 7600:  // code for symbol i.  Assign the next available
        -: 7601:  // code of length l to the symbol and store both
        -: 7602:  // l and the code in hcode[i].
        -: 7603:  //
        -: 7604:
    #####: 7605:  for (int i = 0; i < HUF_ENCSIZE; ++i) {
    %%%%%: 7605-block  0
    %%%%%: 7605-block  1
    #####: 7606:    int l = hcode[i];
        -: 7607:
    #####: 7608:    if (l > 0)
    %%%%%: 7608-block  0
    #####: 7609:      hcode[i] = l | (n[l]++ << 6);
    %%%%%: 7609-block  0
        -: 7610:  }
    #####: 7611:}
        -: 7612:
        -: 7613://
        -: 7614:// Compute Huffman codes (based on frq input) and store them in frq:
        -: 7615://	- code structure is : [63:lsb - 6:msb] | [5-0: bit length];
        -: 7616://	- max code length is 58 bits;
        -: 7617://	- codes outside the range [im-iM] have a null length (unused values);
        -: 7618://	- original frequencies are destroyed;
        -: 7619://	- encoding tables are used by hufEncode() and hufBuildDecTable();
        -: 7620://
        -: 7621:#if 0 // @todo
        -: 7622:
        -: 7623:struct FHeapCompare {
        -: 7624:  bool operator()(long long *a, long long *b) { return *a > *b; }
        -: 7625:};
        -: 7626:
        -: 7627:void hufBuildEncTable(
        -: 7628:    long long *frq, // io: input frequencies [HUF_ENCSIZE], output table
        -: 7629:    int *im,        //  o: min frq index
        -: 7630:    int *iM)        //  o: max frq index
        -: 7631:{
        -: 7632:  //
        -: 7633:  // This function assumes that when it is called, array frq
        -: 7634:  // indicates the frequency of all possible symbols in the data
        -: 7635:  // that are to be Huffman-encoded.  (frq[i] contains the number
        -: 7636:  // of occurrences of symbol i in the data.)
        -: 7637:  //
        -: 7638:  // The loop below does three things:
        -: 7639:  //
        -: 7640:  // 1) Finds the minimum and maximum indices that point
        -: 7641:  //    to non-zero entries in frq:
        -: 7642:  //
        -: 7643:  //     frq[im] != 0, and frq[i] == 0 for all i < im
        -: 7644:  //     frq[iM] != 0, and frq[i] == 0 for all i > iM
        -: 7645:  //
        -: 7646:  // 2) Fills array fHeap with pointers to all non-zero
        -: 7647:  //    entries in frq.
        -: 7648:  //
        -: 7649:  // 3) Initializes array hlink such that hlink[i] == i
        -: 7650:  //    for all array entries.
        -: 7651:  //
        -: 7652:
        -: 7653:  int hlink[HUF_ENCSIZE];
        -: 7654:  long long *fHeap[HUF_ENCSIZE];
        -: 7655:
        -: 7656:  *im = 0;
        -: 7657:
        -: 7658:  while (!frq[*im])
        -: 7659:    (*im)++;
        -: 7660:
        -: 7661:  int nf = 0;
        -: 7662:
        -: 7663:  for (int i = *im; i < HUF_ENCSIZE; i++) {
        -: 7664:    hlink[i] = i;
        -: 7665:
        -: 7666:    if (frq[i]) {
        -: 7667:      fHeap[nf] = &frq[i];
        -: 7668:      nf++;
        -: 7669:      *iM = i;
        -: 7670:    }
        -: 7671:  }
        -: 7672:
        -: 7673:  //
        -: 7674:  // Add a pseudo-symbol, with a frequency count of 1, to frq;
        -: 7675:  // adjust the fHeap and hlink array accordingly.  Function
        -: 7676:  // hufEncode() uses the pseudo-symbol for run-length encoding.
        -: 7677:  //
        -: 7678:
        -: 7679:  (*iM)++;
        -: 7680:  frq[*iM] = 1;
        -: 7681:  fHeap[nf] = &frq[*iM];
        -: 7682:  nf++;
        -: 7683:
        -: 7684:  //
        -: 7685:  // Build an array, scode, such that scode[i] contains the number
        -: 7686:  // of bits assigned to symbol i.  Conceptually this is done by
        -: 7687:  // constructing a tree whose leaves are the symbols with non-zero
        -: 7688:  // frequency:
        -: 7689:  //
        -: 7690:  //     Make a heap that contains all symbols with a non-zero frequency,
        -: 7691:  //     with the least frequent symbol on top.
        -: 7692:  //
        -: 7693:  //     Repeat until only one symbol is left on the heap:
        -: 7694:  //
        -: 7695:  //         Take the two least frequent symbols off the top of the heap.
        -: 7696:  //         Create a new node that has first two nodes as children, and
        -: 7697:  //         whose frequency is the sum of the frequencies of the first
        -: 7698:  //         two nodes.  Put the new node back into the heap.
        -: 7699:  //
        -: 7700:  // The last node left on the heap is the root of the tree.  For each
        -: 7701:  // leaf node, the distance between the root and the leaf is the length
        -: 7702:  // of the code for the corresponding symbol.
        -: 7703:  //
        -: 7704:  // The loop below doesn't actually build the tree; instead we compute
        -: 7705:  // the distances of the leaves from the root on the fly.  When a new
        -: 7706:  // node is added to the heap, then that node's descendants are linked
        -: 7707:  // into a single linear list that starts at the new node, and the code
        -: 7708:  // lengths of the descendants (that is, their distance from the root
        -: 7709:  // of the tree) are incremented by one.
        -: 7710:  //
        -: 7711:
        -: 7712:  std::make_heap(&fHeap[0], &fHeap[nf], FHeapCompare());
        -: 7713:
        -: 7714:  long long scode[HUF_ENCSIZE];
        -: 7715:  memset(scode, 0, sizeof(long long) * HUF_ENCSIZE);
        -: 7716:
        -: 7717:  while (nf > 1) {
        -: 7718:    //
        -: 7719:    // Find the indices, mm and m, of the two smallest non-zero frq
        -: 7720:    // values in fHeap, add the smallest frq to the second-smallest
        -: 7721:    // frq, and remove the smallest frq value from fHeap.
        -: 7722:    //
        -: 7723:
        -: 7724:    int mm = fHeap[0] - frq;
        -: 7725:    std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());
        -: 7726:    --nf;
        -: 7727:
        -: 7728:    int m = fHeap[0] - frq;
        -: 7729:    std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());
        -: 7730:
        -: 7731:    frq[m] += frq[mm];
        -: 7732:    std::push_heap(&fHeap[0], &fHeap[nf], FHeapCompare());
        -: 7733:
        -: 7734:    //
        -: 7735:    // The entries in scode are linked into lists with the
        -: 7736:    // entries in hlink serving as "next" pointers and with
        -: 7737:    // the end of a list marked by hlink[j] == j.
        -: 7738:    //
        -: 7739:    // Traverse the lists that start at scode[m] and scode[mm].
        -: 7740:    // For each element visited, increment the length of the
        -: 7741:    // corresponding code by one bit. (If we visit scode[j]
        -: 7742:    // during the traversal, then the code for symbol j becomes
        -: 7743:    // one bit longer.)
        -: 7744:    //
        -: 7745:    // Merge the lists that start at scode[m] and scode[mm]
        -: 7746:    // into a single list that starts at scode[m].
        -: 7747:    //
        -: 7748:
        -: 7749:    //
        -: 7750:    // Add a bit to all codes in the first list.
        -: 7751:    //
        -: 7752:
        -: 7753:    for (int j = m; true; j = hlink[j]) {
        -: 7754:      scode[j]++;
        -: 7755:
        -: 7756:      assert(scode[j] <= 58);
        -: 7757:
        -: 7758:      if (hlink[j] == j) {
        -: 7759:        //
        -: 7760:        // Merge the two lists.
        -: 7761:        //
        -: 7762:
        -: 7763:        hlink[j] = mm;
        -: 7764:        break;
        -: 7765:      }
        -: 7766:    }
        -: 7767:
        -: 7768:    //
        -: 7769:    // Add a bit to all codes in the second list
        -: 7770:    //
        -: 7771:
        -: 7772:    for (int j = mm; true; j = hlink[j]) {
        -: 7773:      scode[j]++;
        -: 7774:
        -: 7775:      assert(scode[j] <= 58);
        -: 7776:
        -: 7777:      if (hlink[j] == j)
        -: 7778:        break;
        -: 7779:    }
        -: 7780:  }
        -: 7781:
        -: 7782:  //
        -: 7783:  // Build a canonical Huffman code table, replacing the code
        -: 7784:  // lengths in scode with (code, code length) pairs.  Copy the
        -: 7785:  // code table from scode into frq.
        -: 7786:  //
        -: 7787:
        -: 7788:  hufCanonicalCodeTable(scode);
        -: 7789:  memcpy(frq, scode, sizeof(long long) * HUF_ENCSIZE);
        -: 7790:}
        -: 7791:#endif
        -: 7792:
        -: 7793://
        -: 7794:// Pack an encoding table:
        -: 7795://	- only code lengths, not actual codes, are stored
        -: 7796://	- runs of zeroes are compressed as follows:
        -: 7797://
        -: 7798://	  unpacked		packed
        -: 7799://	  --------------------------------
        -: 7800://	  1 zero		0	(6 bits)
        -: 7801://	  2 zeroes		59
        -: 7802://	  3 zeroes		60
        -: 7803://	  4 zeroes		61
        -: 7804://	  5 zeroes		62
        -: 7805://	  n zeroes (6 or more)	63 n-6	(6 + 8 bits)
        -: 7806://
        -: 7807:
        -: 7808:const int SHORT_ZEROCODE_RUN = 59;
        -: 7809:const int LONG_ZEROCODE_RUN = 63;
        -: 7810:const int SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
        -: 7811://const int LONGEST_LONG_RUN = 255 + SHORTEST_LONG_RUN;
        -: 7812:
        -: 7813:#if 0
        -: 7814:void hufPackEncTable(const long long *hcode, // i : encoding table [HUF_ENCSIZE]
        -: 7815:                     int im,                 // i : min hcode index
        -: 7816:                     int iM,                 // i : max hcode index
        -: 7817:                     char **pcode) //  o: ptr to packed table (updated)
        -: 7818:{
        -: 7819:  char *p = *pcode;
        -: 7820:  long long c = 0;
        -: 7821:  int lc = 0;
        -: 7822:
        -: 7823:  for (; im <= iM; im++) {
        -: 7824:    int l = hufLength(hcode[im]);
        -: 7825:
        -: 7826:    if (l == 0) {
        -: 7827:      int zerun = 1;
        -: 7828:
        -: 7829:      while ((im < iM) && (zerun < LONGEST_LONG_RUN)) {
        -: 7830:        if (hufLength(hcode[im + 1]) > 0)
        -: 7831:          break;
        -: 7832:        im++;
        -: 7833:        zerun++;
        -: 7834:      }
        -: 7835:
        -: 7836:      if (zerun >= 2) {
        -: 7837:        if (zerun >= SHORTEST_LONG_RUN) {
        -: 7838:          outputBits(6, LONG_ZEROCODE_RUN, c, lc, p);
        -: 7839:          outputBits(8, zerun - SHORTEST_LONG_RUN, c, lc, p);
        -: 7840:        } else {
        -: 7841:          outputBits(6, SHORT_ZEROCODE_RUN + zerun - 2, c, lc, p);
        -: 7842:        }
        -: 7843:        continue;
        -: 7844:      }
        -: 7845:    }
        -: 7846:
        -: 7847:    outputBits(6, l, c, lc, p);
        -: 7848:  }
        -: 7849:
        -: 7850:  if (lc > 0)
        -: 7851:    *p++ = (unsigned char)(c << (8 - lc));
        -: 7852:
        -: 7853:  *pcode = p;
        -: 7854:}
        -: 7855:#endif
        -: 7856:
        -: 7857://
        -: 7858:// Unpack an encoding table packed by hufPackEncTable():
        -: 7859://
        -: 7860:
    #####: 7861:bool hufUnpackEncTable(const char **pcode, // io: ptr to packed table (updated)
        -: 7862:                       int ni,             // i : input size (in bytes)
        -: 7863:                       int im,             // i : min hcode index
        -: 7864:                       int iM,             // i : max hcode index
        -: 7865:                       long long *hcode)   //  o: encoding table [HUF_ENCSIZE]
        -: 7866:{
    #####: 7867:  memset(hcode, 0, sizeof(long long) * HUF_ENCSIZE);
    %%%%%: 7867-block  0
        -: 7868:
    #####: 7869:  const char *p = *pcode;
    #####: 7870:  long long c = 0;
    #####: 7871:  int lc = 0;
    %%%%%: 7871-block  0
        -: 7872:
    #####: 7873:  for (; im <= iM; im++) {
    %%%%%: 7873-block  0
    %%%%%: 7873-block  1
    #####: 7874:    if (p - *pcode > ni) {
    %%%%%: 7874-block  0
        -: 7875:      return false;
        -: 7876:    }
        -: 7877:
    #####: 7878:    long long l = hcode[im] = getBits(6, c, lc, p); // code length
    %%%%%: 7878-block  0
        -: 7879:
    #####: 7880:    if (l == (long long)LONG_ZEROCODE_RUN) {
    %%%%%: 7880-block  0
    #####: 7881:      if (p - *pcode > ni) {
    %%%%%: 7881-block  0
        -: 7882:        return false;
        -: 7883:      }
        -: 7884:
    #####: 7885:      int zerun = getBits(8, c, lc, p) + SHORTEST_LONG_RUN;
    %%%%%: 7885-block  0
        -: 7886:
    #####: 7887:      if (im + zerun > iM + 1) {
    %%%%%: 7887-block  0
        -: 7888:        return false;
        -: 7889:      }
        -: 7890:
    #####: 7891:      while (zerun--)
    %%%%%: 7891-block  0
    #####: 7892:        hcode[im++] = 0;
    %%%%%: 7892-block  0
        -: 7893:
    #####: 7894:      im--;
    %%%%%: 7894-block  0
    #####: 7895:    } else if (l >= (long long)SHORT_ZEROCODE_RUN) {
    %%%%%: 7895-block  0
    #####: 7896:      int zerun = l - SHORT_ZEROCODE_RUN + 2;
        -: 7897:
    #####: 7898:      if (im + zerun > iM + 1) {
    %%%%%: 7898-block  0
        -: 7899:        return false;
        -: 7900:      }
        -: 7901:
    #####: 7902:      while (zerun--)
    %%%%%: 7902-block  0
    #####: 7903:        hcode[im++] = 0;
    %%%%%: 7903-block  0
        -: 7904:
    #####: 7905:      im--;
    %%%%%: 7905-block  0
        -: 7906:    }
        -: 7907:  }
        -: 7908:
    #####: 7909:  *pcode = const_cast<char *>(p);
        -: 7910:
    #####: 7911:  hufCanonicalCodeTable(hcode);
        -: 7912:
    #####: 7913:  return true;
    %%%%%: 7913-block  0
        -: 7914:}
        -: 7915:
        -: 7916://
        -: 7917:// DECODING TABLE BUILDING
        -: 7918://
        -: 7919:
        -: 7920://
        -: 7921:// Clear a newly allocated decoding table so that it contains only zeroes.
        -: 7922://
        -: 7923:
        -: 7924:void hufClearDecTable(HufDec *hdecod) // io: (allocated by caller)
        -: 7925:                                      //     decoding table [HUF_DECSIZE]
        -: 7926:{
    #####: 7927:  for (int i = 0; i < HUF_DECSIZE; i++) {
    #####: 7928:    hdecod[i].len = 0;
    #####: 7929:    hdecod[i].lit = 0;
    #####: 7930:    hdecod[i].p = NULL;
    %%%%%: 7930-block  0
        -: 7931:  }
        -: 7932:  //memset(hdecod, 0, sizeof(HufDec) * HUF_DECSIZE);
        -: 7933:}
        -: 7934:
        -: 7935://
        -: 7936:// Build a decoding hash table based on the encoding table hcode:
        -: 7937://	- short codes (<= HUF_DECBITS) are resolved with a single table access;
        -: 7938://	- long code entry allocations are not optimized, because long codes are
        -: 7939://	  unfrequent;
        -: 7940://	- decoding tables are used by hufDecode();
        -: 7941://
        -: 7942:
    #####: 7943:bool hufBuildDecTable(const long long *hcode, // i : encoding table
    %%%%%: 7943-block  0
        -: 7944:                      int im,                 // i : min index in hcode
        -: 7945:                      int iM,                 // i : max index in hcode
        -: 7946:                      HufDec *hdecod)         //  o: (allocated by caller)
        -: 7947://     decoding table [HUF_DECSIZE]
        -: 7948:{
        -: 7949:  //
        -: 7950:  // Init hashtable & loop on all codes.
        -: 7951:  // Assumes that hufClearDecTable(hdecod) has already been called.
        -: 7952:  //
        -: 7953:
    #####: 7954:  for (; im <= iM; im++) {
    %%%%%: 7954-block  0
    %%%%%: 7954-block  1
    #####: 7955:    long long c = hufCode(hcode[im]);
    #####: 7956:    int l = hufLength(hcode[im]);
        -: 7957:
    #####: 7958:    if (c >> l) {
    %%%%%: 7958-block  0
        -: 7959:      //
        -: 7960:      // Error: c is supposed to be an l-bit code,
        -: 7961:      // but c contains a value that is greater
        -: 7962:      // than the largest l-bit number.
        -: 7963:      //
        -: 7964:
        -: 7965:      // invalidTableEntry();
        -: 7966:      return false;
        -: 7967:    }
        -: 7968:
    #####: 7969:    if (l > HUF_DECBITS) {
    %%%%%: 7969-block  0
        -: 7970:      //
        -: 7971:      // Long code: add a secondary entry
        -: 7972:      //
        -: 7973:
    #####: 7974:      HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));
        -: 7975:
    #####: 7976:      if (pl->len) {
    %%%%%: 7976-block  0
        -: 7977:        //
        -: 7978:        // Error: a short code has already
        -: 7979:        // been stored in table entry *pl.
        -: 7980:        //
        -: 7981:
        -: 7982:        // invalidTableEntry();
        -: 7983:        return false;
        -: 7984:      }
        -: 7985:
    #####: 7986:      pl->lit++;
        -: 7987:
    #####: 7988:      if (pl->p) {
    %%%%%: 7988-block  0
    #####: 7989:        int *p = pl->p;
    #####: 7990:        pl->p = new int[pl->lit];
    %%%%%: 7990-block  0
    %%%%%: 7990-block  1
    %%%%%: 7990-block  2
        -: 7991:
    #####: 7992:        for (int i = 0; i < pl->lit - 1; ++i)
    %%%%%: 7992-block  0
    #####: 7993:          pl->p[i] = p[i];
    %%%%%: 7993-block  0
        -: 7994:
    #####: 7995:        delete[] p;
    %%%%%: 7995-block  0
        -: 7996:      } else {
    #####: 7997:        pl->p = new int[1];
    %%%%%: 7997-block  0
        -: 7998:      }
        -: 7999:
    #####: 8000:      pl->p[pl->lit - 1] = im;
    %%%%%: 8000-block  0
    #####: 8001:    } else if (l) {
    %%%%%: 8001-block  0
        -: 8002:      //
        -: 8003:      // Short code: init all primary entries
        -: 8004:      //
        -: 8005:
    #####: 8006:      HufDec *pl = hdecod + (c << (HUF_DECBITS - l));
        -: 8007:
    #####: 8008:      for (long long i = 1 << (HUF_DECBITS - l); i > 0; i--, pl++) {
    %%%%%: 8008-block  0
    %%%%%: 8008-block  1
    #####: 8009:        if (pl->len || pl->p) {
    %%%%%: 8009-block  0
    %%%%%: 8009-block  1
        -: 8010:          //
        -: 8011:          // Error: a short code or a long code has
        -: 8012:          // already been stored in table entry *pl.
        -: 8013:          //
        -: 8014:
        -: 8015:          // invalidTableEntry();
        -: 8016:          return false;
        -: 8017:        }
        -: 8018:
    #####: 8019:        pl->len = l;
    #####: 8020:        pl->lit = im;
    %%%%%: 8020-block  0
        -: 8021:      }
        -: 8022:    }
        -: 8023:  }
        -: 8024:
        -: 8025:  return true;
        -: 8026:}
        -: 8027:
        -: 8028://
        -: 8029:// Free the long code entries of a decoding table built by hufBuildDecTable()
        -: 8030://
        -: 8031:
    #####: 8032:void hufFreeDecTable(HufDec *hdecod) // io: Decoding table
        -: 8033:{
    #####: 8034:  for (int i = 0; i < HUF_DECSIZE; i++) {
    %%%%%: 8034-block  0
    %%%%%: 8034-block  1
    %%%%%: 8034-block  2
    #####: 8035:    if (hdecod[i].p) {
    %%%%%: 8035-block  0
    #####: 8036:      delete[] hdecod[i].p;
    %%%%%: 8036-block  0
    #####: 8037:      hdecod[i].p = 0;
        -: 8038:    }
        -: 8039:  }
    #####: 8040:}
        -: 8041:
        -: 8042://
        -: 8043:// ENCODING
        -: 8044://
        -: 8045:
        -: 8046:#if 0 // @todo
        -: 8047:inline void outputCode(long long code, long long &c, int &lc, char *&out) {
        -: 8048:  outputBits(hufLength(code), hufCode(code), c, lc, out);
        -: 8049:}
        -: 8050:
        -: 8051:inline void sendCode(long long sCode, int runCount, long long runCode,
        -: 8052:                     long long &c, int &lc, char *&out) {
        -: 8053:  //
        -: 8054:  // Output a run of runCount instances of the symbol sCount.
        -: 8055:  // Output the symbols explicitly, or if that is shorter, output
        -: 8056:  // the sCode symbol once followed by a runCode symbol and runCount
        -: 8057:  // expressed as an 8-bit number.
        -: 8058:  //
        -: 8059:
        -: 8060:  if (hufLength(sCode) + hufLength(runCode) + 8 < hufLength(sCode) * runCount) {
        -: 8061:    outputCode(sCode, c, lc, out);
        -: 8062:    outputCode(runCode, c, lc, out);
        -: 8063:    outputBits(8, runCount, c, lc, out);
        -: 8064:  } else {
        -: 8065:    while (runCount-- >= 0)
        -: 8066:      outputCode(sCode, c, lc, out);
        -: 8067:  }
        -: 8068:}
        -: 8069:
        -: 8070://
        -: 8071:// Encode (compress) ni values based on the Huffman encoding table hcode:
        -: 8072://
        -: 8073:
        -: 8074:int hufEncode                  // return: output size (in bits)
        -: 8075:    (const long long *hcode,   // i : encoding table
        -: 8076:     const unsigned short *in, // i : uncompressed input buffer
        -: 8077:     const int ni,             // i : input buffer size (in bytes)
        -: 8078:     int rlc,                  // i : rl code
        -: 8079:     char *out)                //  o: compressed output buffer
        -: 8080:{
        -: 8081:  char *outStart = out;
        -: 8082:  long long c = 0; // bits not yet written to out
        -: 8083:  int lc = 0;      // number of valid bits in c (LSB)
        -: 8084:  int s = in[0];
        -: 8085:  int cs = 0;
        -: 8086:
        -: 8087:  //
        -: 8088:  // Loop on input values
        -: 8089:  //
        -: 8090:
        -: 8091:  for (int i = 1; i < ni; i++) {
        -: 8092:    //
        -: 8093:    // Count same values or send code
        -: 8094:    //
        -: 8095:
        -: 8096:    if (s == in[i] && cs < 255) {
        -: 8097:      cs++;
        -: 8098:    } else {
        -: 8099:      sendCode(hcode[s], cs, hcode[rlc], c, lc, out);
        -: 8100:      cs = 0;
        -: 8101:    }
        -: 8102:
        -: 8103:    s = in[i];
        -: 8104:  }
        -: 8105:
        -: 8106:  //
        -: 8107:  // Send remaining code
        -: 8108:  //
        -: 8109:
        -: 8110:  sendCode(hcode[s], cs, hcode[rlc], c, lc, out);
        -: 8111:
        -: 8112:  if (lc)
        -: 8113:    *out = (c << (8 - lc)) & 0xff;
        -: 8114:
        -: 8115:  return (out - outStart) * 8 + lc;
        -: 8116:}
        -: 8117:#endif
        -: 8118:
        -: 8119://
        -: 8120:// DECODING
        -: 8121://
        -: 8122:
        -: 8123://
        -: 8124:// In order to force the compiler to inline them,
        -: 8125:// tiny_exr_getChar() and getCode() are implemented as macros
        -: 8126:// instead of "inline" functions.
        -: 8127://
        -: 8128:
        -: 8129:#define tiny_exr_getChar(c, lc, in)                                                     \
        -: 8130:  {                                                                            \
        -: 8131:    c = (c << 8) | *(unsigned char *)(in++);                                   \
        -: 8132:    lc += 8;                                                                   \
        -: 8133:  }
        -: 8134:
        -: 8135:#define getCode(po, rlc, c, lc, in, out, oe)                                   \
        -: 8136:  {                                                                            \
        -: 8137:    if (po == rlc) {                                                           \
        -: 8138:      if (lc < 8)                                                              \
        -: 8139:        tiny_exr_getChar(c, lc, in);                                                    \
        -: 8140:                                                                               \
        -: 8141:      lc -= 8;                                                                 \
        -: 8142:                                                                               \
        -: 8143:      unsigned char cs = (c >> lc);                                            \
        -: 8144:                                                                               \
        -: 8145:      if (out + cs > oe)                                                       \
        -: 8146:        return false;                                                          \
        -: 8147:                                                                               \
        -: 8148:      unsigned short s = out[-1];                                              \
        -: 8149:                                                                               \
        -: 8150:      while (cs-- > 0)                                                         \
        -: 8151:        *out++ = s;                                                            \
        -: 8152:    } else if (out < oe) {                                                     \
        -: 8153:      *out++ = po;                                                             \
        -: 8154:    } else {                                                                   \
        -: 8155:      return false;                                                            \
        -: 8156:    }                                                                          \
        -: 8157:  }
        -: 8158:
        -: 8159://
        -: 8160:// Decode (uncompress) ni bits based on encoding & decoding tables:
        -: 8161://
        -: 8162:
    #####: 8163:bool hufDecode(const long long *hcode, // i : encoding table
        -: 8164:               const HufDec *hdecod,   // i : decoding table
        -: 8165:               const char *in,         // i : compressed input buffer
        -: 8166:               int ni,                 // i : input size (in bits)
        -: 8167:               int rlc,                // i : run-length code
        -: 8168:               int no,                 // i : expected output size (in bytes)
        -: 8169:               unsigned short *out)    //  o: uncompressed output buffer
        -: 8170:{
    #####: 8171:  long long c = 0;
    #####: 8172:  int lc = 0;
    #####: 8173:  unsigned short *outb = out;
    #####: 8174:  unsigned short *oe = out + no;
    #####: 8175:  const char *ie = in + (ni + 7) / 8; // input byte size
    %%%%%: 8175-block  0
        -: 8176:
        -: 8177:  //
        -: 8178:  // Loop on input bytes
        -: 8179:  //
        -: 8180:
    #####: 8181:  while (in < ie) {
    %%%%%: 8181-block  0
    #####: 8182:    tiny_exr_getChar(c, lc, in);
    %%%%%: 8182-block  0
        -: 8183:
        -: 8184:    //
        -: 8185:    // Access decoding table
        -: 8186:    //
        -: 8187:
    #####: 8188:    while (lc >= HUF_DECBITS) {
    %%%%%: 8188-block  0
    #####: 8189:      const HufDec pl = hdecod[(c >> (lc - HUF_DECBITS)) & HUF_DECMASK];
        -: 8190:
    #####: 8191:      if (pl.len) {
    %%%%%: 8191-block  0
        -: 8192:        //
        -: 8193:        // Get short code
        -: 8194:        //
        -: 8195:
    #####: 8196:        lc -= pl.len;
    #####: 8197:        getCode(pl.lit, rlc, c, lc, in, out, oe);
    %%%%%: 8197-block  0
    %%%%%: 8197-block  1
    %%%%%: 8197-block  2
    %%%%%: 8197-block  3
    %%%%%: 8197-block  4
    %%%%%: 8197-block  5
    %%%%%: 8197-block  6
    %%%%%: 8197-block  7
    %%%%%: 8197-block  8
    %%%%%: 8197-block  9
        -: 8198:      } else {
    #####: 8199:        if (!pl.p) {
    %%%%%: 8199-block  0
        -: 8200:          return false;
        -: 8201:        }
        -: 8202:        // invalidCode(); // wrong code
        -: 8203:
        -: 8204:        //
        -: 8205:        // Search long code
        -: 8206:        //
        -: 8207:
        -: 8208:        int j;
        -: 8209:
    #####: 8210:        for (j = 0; j < pl.lit; j++) {
    %%%%%: 8210-block  0
    %%%%%: 8210-block  1
    #####: 8211:          int l = hufLength(hcode[pl.p[j]]);
    %%%%%: 8211-block  0
        -: 8212:
    #####: 8213:          while (lc < l && in < ie) // get more bits
    %%%%%: 8213-block  0
    #####: 8214:            tiny_exr_getChar(c, lc, in);
    %%%%%: 8214-block  0
        -: 8215:
    #####: 8216:          if (lc >= l) {
    %%%%%: 8216-block  0
    #####: 8217:            if (hufCode(hcode[pl.p[j]]) ==
    #####: 8218:                ((c >> (lc - l)) & (((long long)(1) << l) - 1))) {
    %%%%%: 8218-block  0
        -: 8219:              //
        -: 8220:              // Found : get long code
        -: 8221:              //
        -: 8222:
    #####: 8223:              lc -= l;
    #####: 8224:              getCode(pl.p[j], rlc, c, lc, in, out, oe);
    %%%%%: 8224-block  0
    %%%%%: 8224-block  1
    %%%%%: 8224-block  2
    %%%%%: 8224-block  3
    %%%%%: 8224-block  4
    %%%%%: 8224-block  5
    %%%%%: 8224-block  6
    %%%%%: 8224-block  7
    %%%%%: 8224-block  8
        -: 8225:              break;
        -: 8226:            }
        -: 8227:          }
        -: 8228:        }
        -: 8229:
    #####: 8230:        if (j == pl.lit) {
    %%%%%: 8230-block  0
        -: 8231:          return false;
        -: 8232:          // invalidCode(); // Not found
        -: 8233:        }
        -: 8234:      }
        -: 8235:    }
        -: 8236:  }
        -: 8237:
        -: 8238:  //
        -: 8239:  // Get remaining (short) codes
        -: 8240:  //
        -: 8241:
    #####: 8242:  int i = (8 - ni) & 7;
    #####: 8243:  c >>= i;
    #####: 8244:  lc -= i;
    %%%%%: 8244-block  0
        -: 8245:
    #####: 8246:  while (lc > 0) {
    %%%%%: 8246-block  0
    #####: 8247:    const HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];
        -: 8248:
    #####: 8249:    if (pl.len) {
    %%%%%: 8249-block  0
    #####: 8250:      lc -= pl.len;
    #####: 8251:      getCode(pl.lit, rlc, c, lc, in, out, oe);
    %%%%%: 8251-block  0
    %%%%%: 8251-block  1
    %%%%%: 8251-block  2
    %%%%%: 8251-block  3
    %%%%%: 8251-block  4
    %%%%%: 8251-block  5
    %%%%%: 8251-block  6
    %%%%%: 8251-block  7
    %%%%%: 8251-block  8
    %%%%%: 8251-block  9
    %%%%%: 8251-block 10
        -: 8252:    } else {
        -: 8253:      return false;
        -: 8254:      // invalidCode(); // wrong (long) code
        -: 8255:    }
        -: 8256:  }
        -: 8257:
    #####: 8258:  if (out - outb != no) {
    %%%%%: 8258-block  0
    #####: 8259:    return false;
    %%%%%: 8259-block  0
        -: 8260:  }
        -: 8261:  // notEnoughData ();
        -: 8262:
        -: 8263:  return true;
        -: 8264:}
        -: 8265:
        -: 8266:#if 0 // @todo
        -: 8267:void countFrequencies(long long freq[HUF_ENCSIZE],
        -: 8268:                      const unsigned short data[/*n*/], int n) {
        -: 8269:  for (int i = 0; i < HUF_ENCSIZE; ++i)
        -: 8270:    freq[i] = 0;
        -: 8271:
        -: 8272:  for (int i = 0; i < n; ++i)
        -: 8273:    ++freq[data[i]];
        -: 8274:}
        -: 8275:
        -: 8276:void writeUInt(char buf[4], unsigned int i) {
        -: 8277:  unsigned char *b = (unsigned char *)buf;
        -: 8278:
        -: 8279:  b[0] = i;
        -: 8280:  b[1] = i >> 8;
        -: 8281:  b[2] = i >> 16;
        -: 8282:  b[3] = i >> 24;
        -: 8283:}
        -: 8284:#endif
        -: 8285:
    #####: 8286:unsigned int readUInt(const char buf[4]) {
    #####: 8287:  const unsigned char *b = (const unsigned char *)buf;
        -: 8288:
    #####: 8289:  return (b[0] & 0x000000ff) | ((b[1] << 8) & 0x0000ff00) |
    #####: 8290:         ((b[2] << 16) & 0x00ff0000) | ((b[3] << 24) & 0xff000000);
        -: 8291:}
        -: 8292:
        -: 8293://
        -: 8294:// EXTERNAL INTERFACE
        -: 8295://
        -: 8296:
        -: 8297:#if 0 // @todo
        -: 8298:int hufCompress(const unsigned short raw[], int nRaw, char compressed[]) {
        -: 8299:  if (nRaw == 0)
        -: 8300:    return 0;
        -: 8301:
        -: 8302:  long long freq[HUF_ENCSIZE];
        -: 8303:
        -: 8304:  countFrequencies(freq, raw, nRaw);
        -: 8305:
        -: 8306:  int im = 0;
        -: 8307:  int iM = 0;
        -: 8308:  hufBuildEncTable(freq, &im, &iM);
        -: 8309:
        -: 8310:  char *tableStart = compressed + 20;
        -: 8311:  char *tableEnd = tableStart;
        -: 8312:  hufPackEncTable(freq, im, iM, &tableEnd);
        -: 8313:  int tableLength = tableEnd - tableStart;
        -: 8314:
        -: 8315:  char *dataStart = tableEnd;
        -: 8316:  int nBits = hufEncode(freq, raw, nRaw, iM, dataStart);
        -: 8317:  int dataLength = (nBits + 7) / 8;
        -: 8318:
        -: 8319:  writeUInt(compressed, im);
        -: 8320:  writeUInt(compressed + 4, iM);
        -: 8321:  writeUInt(compressed + 8, tableLength);
        -: 8322:  writeUInt(compressed + 12, nBits);
        -: 8323:  writeUInt(compressed + 16, 0); // room for future extensions
        -: 8324:
        -: 8325:  return dataStart + dataLength - compressed;
        -: 8326:}
        -: 8327:#endif
        -: 8328:
    #####: 8329:bool hufUncompress(const char compressed[], int nCompressed,
        -: 8330:                   unsigned short raw[], int nRaw) {
    #####: 8331:  if (nCompressed == 0) {
    %%%%%: 8331-block  0
        -: 8332:    if (nRaw != 0)
        -: 8333:      return false;
        -: 8334:
        -: 8335:    return false;
        -: 8336:  }
        -: 8337:
    #####: 8338:  int im = readUInt(compressed);
    #####: 8339:  int iM = readUInt(compressed + 4);
        -: 8340:  // int tableLength = readUInt (compressed + 8);
    #####: 8341:  int nBits = readUInt(compressed + 12);
        -: 8342:
    #####: 8343:  if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
    %%%%%: 8343-block  0
    %%%%%: 8343-block  1
        -: 8344:    return false;
        -: 8345:
    #####: 8346:  const char *ptr = compressed + 20;
        -: 8347:
        -: 8348:  //
        -: 8349:  // Fast decoder needs at least 2x64-bits of compressed data, and
        -: 8350:  // needs to be run-able on this platform. Otherwise, fall back
        -: 8351:  // to the original decoder
        -: 8352:  //
        -: 8353:
        -: 8354:  // if (FastHufDecoder::enabled() && nBits > 128)
        -: 8355:  //{
        -: 8356:  //    FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);
        -: 8357:  //    fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);
        -: 8358:  //}
        -: 8359:  // else
    #####: 8360:  {
    #####: 8361:    std::vector<long long> freq(HUF_ENCSIZE);
    %%%%%: 8361-block  0
    $$$$$: 8361-block  1
    #####: 8362:    std::vector<HufDec> hdec(HUF_DECSIZE);
    %%%%%: 8362-block  0
    %%%%%: 8362-block  1
    $$$$$: 8362-block  2
        -: 8363:
    #####: 8364:    hufClearDecTable(&hdec.at(0));
    %%%%%: 8364-block  0
    %%%%%: 8364-block  1
        -: 8365:
    #####: 8366:    hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM, &freq.at(0));
    %%%%%: 8366-block  0
    %%%%%: 8366-block  1
        -: 8367:
    #####: 8368:    {
    #####: 8369:      if (nBits > 8 * (nCompressed - (ptr - compressed))) {
    #####: 8370:        return false;
    %%%%%: 8370-block  0
    %%%%%: 8370-block  1
        -: 8371:      }
        -: 8372:
    #####: 8373:      hufBuildDecTable(&freq.at(0), im, iM, &hdec.at(0));
    %%%%%: 8373-block  0
    %%%%%: 8373-block  1
    %%%%%: 8373-block  2
    #####: 8374:      hufDecode(&freq.at(0), &hdec.at(0), ptr, nBits, iM, nRaw, raw);
    %%%%%: 8374-block  0
    %%%%%: 8374-block  1
    %%%%%: 8374-block  2
        -: 8375:    }
        -: 8376:    // catch (...)
        -: 8377:    //{
        -: 8378:    //    hufFreeDecTable (hdec);
        -: 8379:    //    throw;
        -: 8380:    //}
        -: 8381:
    #####: 8382:    hufFreeDecTable(&hdec.at(0));
    %%%%%: 8382-block  0
        -: 8383:  }
        -: 8384:
    #####: 8385:  return true;
    %%%%%: 8385-block  0
        -: 8386:}
        -: 8387:
        -: 8388://
        -: 8389:// Functions to compress the range of values in the pixel data
        -: 8390://
        -: 8391:
        -: 8392:const int USHORT_RANGE = (1 << 16);
        -: 8393:const int BITMAP_SIZE = (USHORT_RANGE >> 3);
        -: 8394:
        -: 8395:#if 0 // @todo
        -: 8396:
        -: 8397:void bitmapFromData(const unsigned short data[/*nData*/], int nData,
        -: 8398:                    unsigned char bitmap[BITMAP_SIZE],
        -: 8399:                    unsigned short &minNonZero, unsigned short &maxNonZero) {
        -: 8400:  for (int i = 0; i < BITMAP_SIZE; ++i)
        -: 8401:    bitmap[i] = 0;
        -: 8402:
        -: 8403:  for (int i = 0; i < nData; ++i)
        -: 8404:    bitmap[data[i] >> 3] |= (1 << (data[i] & 7));
        -: 8405:
        -: 8406:  bitmap[0] &= ~1; // zero is not explicitly stored in
        -: 8407:                   // the bitmap; we assume that the
        -: 8408:                   // data always contain zeroes
        -: 8409:  minNonZero = BITMAP_SIZE - 1;
        -: 8410:  maxNonZero = 0;
        -: 8411:
        -: 8412:  for (int i = 0; i < BITMAP_SIZE; ++i) {
        -: 8413:    if (bitmap[i]) {
        -: 8414:      if (minNonZero > i)
        -: 8415:        minNonZero = i;
        -: 8416:      if (maxNonZero < i)
        -: 8417:        maxNonZero = i;
        -: 8418:    }
        -: 8419:  }
        -: 8420:}
        -: 8421:
        -: 8422:unsigned short forwardLutFromBitmap(const unsigned char bitmap[BITMAP_SIZE],
        -: 8423:                                    unsigned short lut[USHORT_RANGE]) {
        -: 8424:  int k = 0;
        -: 8425:
        -: 8426:  for (int i = 0; i < USHORT_RANGE; ++i) {
        -: 8427:    if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))
        -: 8428:      lut[i] = k++;
        -: 8429:    else
        -: 8430:      lut[i] = 0;
        -: 8431:  }
        -: 8432:
        -: 8433:  return k - 1; // maximum value stored in lut[],
        -: 8434:} // i.e. number of ones in bitmap minus 1
        -: 8435:#endif
        -: 8436:
    #####: 8437:unsigned short reverseLutFromBitmap(const unsigned char bitmap[BITMAP_SIZE],
        -: 8438:                                    unsigned short lut[USHORT_RANGE]) {
    #####: 8439:  int k = 0;
        -: 8440:
    #####: 8441:  for (int i = 0; i < USHORT_RANGE; ++i) {
    %%%%%: 8441-block  0
    %%%%%: 8441-block  1
    %%%%%: 8441-block  2
    #####: 8442:    if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))
    %%%%%: 8442-block  0
    %%%%%: 8442-block  1
    #####: 8443:      lut[k++] = i;
    %%%%%: 8443-block  0
        -: 8444:  }
        -: 8445:
    #####: 8446:  int n = k - 1;
    %%%%%: 8446-block  0
        -: 8447:
    #####: 8448:  while (k < USHORT_RANGE)
    %%%%%: 8448-block  0
    #####: 8449:    lut[k++] = 0;
    %%%%%: 8449-block  0
        -: 8450:
    #####: 8451:  return n; // maximum k where lut[k] is non-zero,
        -: 8452:} // i.e. number of ones in bitmap minus 1
        -: 8453:
        -: 8454:void applyLut(const unsigned short lut[USHORT_RANGE],
        -: 8455:              unsigned short data[/*nData*/], int nData) {
        -: 8456:  for (int i = 0; i < nData; ++i)
        -: 8457:    data[i] = lut[data[i]];
        -: 8458:}
        -: 8459:
        -: 8460:#if 0 // @todo
        -: 8461:bool CompressPiz(unsigned char *outPtr, unsigned int &outSize) {
        -: 8462:  unsigned char bitmap[BITMAP_SIZE];
        -: 8463:  unsigned short minNonZero;
        -: 8464:  unsigned short maxNonZero;
        -: 8465:
        -: 8466:  if (IsBigEndian()) {
        -: 8467:    // @todo { PIZ compression on BigEndian architecture. }
        -: 8468:    assert(0);
        -: 8469:    return false;
        -: 8470:  }
        -: 8471:
        -: 8472:  std::vector<unsigned short> tmpBuffer;
        -: 8473:  int nData = tmpBuffer.size();
        -: 8474:
        -: 8475:  bitmapFromData(&tmpBuffer.at(0), nData, bitmap, minNonZero, maxNonZero);
        -: 8476:
        -: 8477:  unsigned short lut[USHORT_RANGE];
        -: 8478:  //unsigned short maxValue = forwardLutFromBitmap(bitmap, lut);
        -: 8479:  applyLut(lut, &tmpBuffer.at(0), nData);
        -: 8480:
        -: 8481:  //
        -: 8482:  // Store range compression info in _outBuffer
        -: 8483:  //
        -: 8484:
        -: 8485:  char *buf = reinterpret_cast<char *>(outPtr);
        -: 8486:
        -: 8487:  memcpy(buf, &minNonZero, sizeof(unsigned short));
        -: 8488:  buf += sizeof(unsigned short);
        -: 8489:  memcpy(buf, &maxNonZero, sizeof(unsigned short));
        -: 8490:  buf += sizeof(unsigned short);
        -: 8491:
        -: 8492:  if (minNonZero <= maxNonZero) {
        -: 8493:    memcpy(buf, (char *)&bitmap[0] + minNonZero, maxNonZero - minNonZero + 1);
        -: 8494:    buf += maxNonZero - minNonZero + 1;
        -: 8495:  }
        -: 8496:
        -: 8497:#if 0 // @todo
        -: 8498:    //
        -: 8499:    // Apply wavelet encoding
        -: 8500:    //
        -: 8501:
        -: 8502:    for (int i = 0; i < channels; ++i)
        -: 8503:    {
        -: 8504:      ChannelData &cd = _channelData[i];
        -: 8505:
        -: 8506:      for (int j = 0; j < cd.size; ++j)
        -: 8507:      {
        -: 8508:          wav2Encode (cd.start + j,
        -: 8509:              cd.nx, cd.size,
        -: 8510:              cd.ny, cd.nx * cd.size,
        -: 8511:              maxValue);
        -: 8512:      }
        -: 8513:    }
        -: 8514:
        -: 8515:    //
        -: 8516:    // Apply Huffman encoding; append the result to _outBuffer
        -: 8517:    //
        -: 8518:
        -: 8519:    char *lengthPtr = buf;
        -: 8520:    int zero = 0;
        -: 8521:    memcpy(buf, &zero, sizeof(int)); buf += sizeof(int);
        -: 8522:
        -: 8523:    int length = hufCompress (_tmpBuffer, tmpBufferEnd - _tmpBuffer, buf);
        -: 8524:    memcpy(lengthPtr, tmpBuffer, length);
        -: 8525:    //Xdr::write <CharPtrIO> (lengthPtr, length);
        -: 8526:
        -: 8527:    outPtr = _outBuffer;
        -: 8528:    return buf - _outBuffer + length;
        -: 8529:#endif
        -: 8530:  assert(0);
        -: 8531:
        -: 8532:  return true;
        -: 8533:}
        -: 8534:#endif
        -: 8535:
        -: 8536:bool DecompressPiz(unsigned char *outPtr, unsigned int &outSize,
        -: 8537:                   const unsigned char *inPtr, size_t tmpBufSize,
        -: 8538:                   const std::vector<ChannelInfo> &channelInfo, int dataWidth,
        -: 8539:                   int numLines) {
        -: 8540:  unsigned char bitmap[BITMAP_SIZE];
        -: 8541:  unsigned short minNonZero;
        -: 8542:  unsigned short maxNonZero;
        -: 8543:
        -: 8544:  if (IsBigEndian()) {
        -: 8545:    // @todo { PIZ compression on BigEndian architecture. }
        -: 8546:    assert(0);
        -: 8547:    return false;
        -: 8548:  }
        -: 8549:
        -: 8550:  memset(bitmap, 0, BITMAP_SIZE);
        -: 8551:
        -: 8552:  const unsigned char *ptr = inPtr;
        -: 8553:  minNonZero = *(reinterpret_cast<const unsigned short *>(ptr));
        -: 8554:  maxNonZero = *(reinterpret_cast<const unsigned short *>(ptr + 2));
        -: 8555:  ptr += 4;
        -: 8556:
        -: 8557:  if (maxNonZero >= BITMAP_SIZE) {
        -: 8558:    return false;
        -: 8559:  }
        -: 8560:
        -: 8561:  if (minNonZero <= maxNonZero) {
        -: 8562:    memcpy((char *)&bitmap[0] + minNonZero, ptr, maxNonZero - minNonZero + 1);
        -: 8563:    ptr += maxNonZero - minNonZero + 1;
        -: 8564:  }
        -: 8565:
        -: 8566:  unsigned short lut[USHORT_RANGE];
        -: 8567:  memset(lut, 0, sizeof(unsigned short) * USHORT_RANGE);
        -: 8568:  unsigned short maxValue = reverseLutFromBitmap(bitmap, lut);
        -: 8569:
        -: 8570:  //
        -: 8571:  // Huffman decoding
        -: 8572:  //
        -: 8573:
        -: 8574:  int length;
        -: 8575:
        -: 8576:  length = *(reinterpret_cast<const int *>(ptr));
        -: 8577:  ptr += sizeof(int);
        -: 8578:
        -: 8579:  std::vector<unsigned short> tmpBuffer(tmpBufSize);
        -: 8580:  hufUncompress(reinterpret_cast<const char *>(ptr), length, &tmpBuffer.at(0),
        -: 8581:                tmpBufSize);
        -: 8582:
        -: 8583:  //
        -: 8584:  // Wavelet decoding
        -: 8585:  //
        -: 8586:
        -: 8587:  std::vector<PIZChannelData> channelData(channelInfo.size());
        -: 8588:
        -: 8589:  unsigned short *tmpBufferEnd = &tmpBuffer.at(0);
        -: 8590:
        -: 8591:  for (size_t i = 0; i < channelInfo.size(); ++i) {
        -: 8592:    const ChannelInfo &chan = channelInfo[i];
        -: 8593:
        -: 8594:    int pixelSize = sizeof(int); // UINT and FLOAT
        -: 8595:    if (chan.pixelType == TINYEXR_PIXELTYPE_HALF) {
        -: 8596:      pixelSize = sizeof(short);
        -: 8597:    }
        -: 8598:
        -: 8599:    channelData[i].start = tmpBufferEnd;
        -: 8600:    channelData[i].end = channelData[i].start;
        -: 8601:    channelData[i].nx = dataWidth;
        -: 8602:    channelData[i].ny = numLines;
        -: 8603:    // channelData[i].ys = 1;
        -: 8604:    channelData[i].size = pixelSize / sizeof(short);
        -: 8605:
        -: 8606:    tmpBufferEnd += channelData[i].nx * channelData[i].ny * channelData[i].size;
        -: 8607:  }
        -: 8608:
        -: 8609:  for (size_t i = 0; i < channelData.size(); ++i) {
        -: 8610:    PIZChannelData &cd = channelData[i];
        -: 8611:
        -: 8612:    for (int j = 0; j < cd.size; ++j) {
        -: 8613:      wav2Decode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,
        -: 8614:                 maxValue);
        -: 8615:    }
        -: 8616:  }
        -: 8617:
        -: 8618:  //
        -: 8619:  // Expand the pixel data to their original range
        -: 8620:  //
        -: 8621:
        -: 8622:  applyLut(lut, &tmpBuffer.at(0), tmpBufSize);
        -: 8623:
        -: 8624:  // @todo { Xdr }
        -: 8625:
        -: 8626:  for (int y = 0; y < numLines; y++) {
        -: 8627:    for (size_t i = 0; i < channelData.size(); ++i) {
        -: 8628:      PIZChannelData &cd = channelData[i];
        -: 8629:
        -: 8630:      // if (modp (y, cd.ys) != 0)
        -: 8631:      //    continue;
        -: 8632:
        -: 8633:      int n = cd.nx * cd.size;
        -: 8634:      memcpy(outPtr, cd.end, n * sizeof(unsigned short));
        -: 8635:      outPtr += n * sizeof(unsigned short);
        -: 8636:      cd.end += n;
        -: 8637:    }
        -: 8638:  }
        -: 8639:
        -: 8640:  return true;
        -: 8641:}
        -: 8642://
        -: 8643:// -----------------------------------------------------------------
        -: 8644://
        -: 8645:
        -: 8646:} // namespace
        -: 8647:
        -: 8648:int LoadEXR(float **out_rgba, int *width, int *height, const char *filename,
        -: 8649:            const char **err) {
        -: 8650:
        -: 8651:  if (out_rgba == NULL) {
        -: 8652:    if (err) {
        -: 8653:      (*err) = "Invalid argument.\n";
        -: 8654:    }
        -: 8655:    return -1;
        -: 8656:  }
        -: 8657:
        -: 8658:  EXRImage exrImage;
        -: 8659:  InitEXRImage(&exrImage);
        -: 8660:
        -: 8661:  {
        -: 8662:    int ret = ParseMultiChannelEXRHeaderFromFile(&exrImage, filename, err);
        -: 8663:    if (ret != 0) {
        -: 8664:      return ret;
        -: 8665:    }
        -: 8666:  }
        -: 8667:
        -: 8668:  // Read HALF channel as FLOAT.
        -: 8669:  for (int i = 0; i < exrImage.num_channels; i++) {
        -: 8670:    if (exrImage.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {
        -: 8671:      exrImage.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;
        -: 8672:    }
        -: 8673:  }
        -: 8674:
        -: 8675:  {
        -: 8676:    int ret = LoadMultiChannelEXRFromFile(&exrImage, filename, err);
        -: 8677:    if (ret != 0) {
        -: 8678:      return ret;
        -: 8679:    }
        -: 8680:  }
        -: 8681:
        -: 8682:  // RGBA
        -: 8683:  int idxR = -1;
        -: 8684:  int idxG = -1;
        -: 8685:  int idxB = -1;
        -: 8686:  int idxA = -1;
        -: 8687:  for (int c = 0; c < exrImage.num_channels; c++) {
        -: 8688:    if (strcmp(exrImage.channel_names[c], "R") == 0) {
        -: 8689:      idxR = c;
        -: 8690:    } else if (strcmp(exrImage.channel_names[c], "G") == 0) {
        -: 8691:      idxG = c;
        -: 8692:    } else if (strcmp(exrImage.channel_names[c], "B") == 0) {
        -: 8693:      idxB = c;
        -: 8694:    } else if (strcmp(exrImage.channel_names[c], "A") == 0) {
        -: 8695:      idxA = c;
        -: 8696:    }
        -: 8697:  }
        -: 8698:
        -: 8699:  if (idxR == -1) {
        -: 8700:    if (err) {
        -: 8701:      (*err) = "R channel not found\n";
        -: 8702:    }
        -: 8703:
        -: 8704:    // @todo { free exrImage }
        -: 8705:    return -1;
        -: 8706:  }
        -: 8707:
        -: 8708:  if (idxG == -1) {
        -: 8709:    if (err) {
        -: 8710:      (*err) = "G channel not found\n";
        -: 8711:    }
        -: 8712:    // @todo { free exrImage }
        -: 8713:    return -1;
        -: 8714:  }
        -: 8715:
        -: 8716:  if (idxB == -1) {
        -: 8717:    if (err) {
        -: 8718:      (*err) = "B channel not found\n";
        -: 8719:    }
        -: 8720:    // @todo { free exrImage }
        -: 8721:    return -1;
        -: 8722:  }
        -: 8723:
        -: 8724:  (*out_rgba) =
        -: 8725:      (float *)malloc(4 * sizeof(float) * exrImage.width * exrImage.height);
        -: 8726:  for (int i = 0; i < exrImage.width * exrImage.height; i++) {
        -: 8727:    (*out_rgba)[4 * i + 0] =
        -: 8728:        reinterpret_cast<float **>(exrImage.images)[idxR][i];
        -: 8729:    (*out_rgba)[4 * i + 1] =
        -: 8730:        reinterpret_cast<float **>(exrImage.images)[idxG][i];
        -: 8731:    (*out_rgba)[4 * i + 2] =
        -: 8732:        reinterpret_cast<float **>(exrImage.images)[idxB][i];
        -: 8733:    if (idxA > 0) {
        -: 8734:      (*out_rgba)[4 * i + 3] =
        -: 8735:          reinterpret_cast<float **>(exrImage.images)[idxA][i];
        -: 8736:    } else {
        -: 8737:      (*out_rgba)[4 * i + 3] = 1.0;
        -: 8738:    }
        -: 8739:  }
        -: 8740:
        -: 8741:  (*width) = exrImage.width;
        -: 8742:  (*height) = exrImage.height;
        -: 8743:
        -: 8744:  // @todo { free exrImage }
        -: 8745:  return 0;
        -: 8746:}
        -: 8747:
        -: 8748:int ParseEXRHeaderFromMemory(EXRAttribute* customAttributes, int *numCustomAttributes, int *width, int *height,
        -: 8749:                             const unsigned char *memory) {
        -: 8750:
        -: 8751:  if (memory == NULL) {
        -: 8752:    // Invalid argument
        -: 8753:    return -1;
        -: 8754:  }
        -: 8755:
        -: 8756:  const char *buf = reinterpret_cast<const char *>(memory);
        -: 8757:
        -: 8758:  const char *marker = &buf[0];
        -: 8759:
        -: 8760:  // Header check.
        -: 8761:  {
        -: 8762:    const char header[] = {0x76, 0x2f, 0x31, 0x01};
        -: 8763:
        -: 8764:    if (memcmp(marker, header, 4) != 0) {
        -: 8765:      // if (err) {
        -: 8766:      //  (*err) = "Header mismatch.";
        -: 8767:      //}
        -: 8768:      return -3;
        -: 8769:    }
        -: 8770:    marker += 4;
        -: 8771:  }
        -: 8772:
        -: 8773:  // Version, scanline.
        -: 8774:  {
        -: 8775:    // must be [2, 0, 0, 0]
        -: 8776:    if (marker[0] != 2 || marker[1] != 0 || marker[2] != 0 || marker[3] != 0) {
        -: 8777:      // if (err) {
        -: 8778:      //  (*err) = "Unsupported version or scanline.";
        -: 8779:      //}
        -: 8780:      return -4;
        -: 8781:    }
        -: 8782:
        -: 8783:    marker += 4;
        -: 8784:  }
        -: 8785:
        -: 8786:  int dx = -1;
        -: 8787:  int dy = -1;
        -: 8788:  int dw = -1;
        -: 8789:  int dh = -1;
        -: 8790:  int lineOrder = 0; // @fixme
        -: 8791:  int displayWindow[4] = {-1, -1, -1, -1}; // @fixme
        -: 8792:  float screenWindowCenter[2] = {0.0f, 0.0f}; // @fixme
        -: 8793:  float screenWindowWidth = 1.0f; // @fixme
        -: 8794:  int numChannels = -1;
        -: 8795:  float pixelAspectRatio = 1.0f; // @fixme
        -: 8796:  std::vector<ChannelInfo> channels;
        -: 8797:  std::vector<EXRAttribute> attribs;
        -: 8798:
        -: 8799:  if (numCustomAttributes) {
        -: 8800:    (*numCustomAttributes) = 0;
        -: 8801:  }
        -: 8802:
        -: 8803:  // Read attributes
        -: 8804:  for (;;) {
        -: 8805:    std::string attrName;
        -: 8806:    std::string attrType;
        -: 8807:    std::vector<unsigned char> data;
        -: 8808:    const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
        -: 8809:    if (marker_next == NULL) {
        -: 8810:      marker++; // skip '\0'
        -: 8811:      break;
        -: 8812:    }
        -: 8813:
        -: 8814:    if (attrName.compare("compression") == 0) {
        -: 8815:      // must be 0:No compression, 1: RLE or 3: ZIP
        -: 8816:      //      if (data[0] != 0 && data[0] != 1 && data[0] != 3) {
        -: 8817:
        -: 8818:      //	mwkm
        -: 8819:      //	0 : NO_COMPRESSION
        -: 8820:      //	1 : RLE
        -: 8821:      //	2 : ZIPS (Single scanline)
        -: 8822:      //	3 : ZIP (16-line block)
        -: 8823:      //	4 : PIZ (32-line block)
        -: 8824:      if (data[0] > 4) {
        -: 8825:        // if (err) {
        -: 8826:        //  (*err) = "Unsupported compression type.";
        -: 8827:        //}
        -: 8828:        return -5;
        -: 8829:      }
        -: 8830:
        -: 8831:    } else if (attrName.compare("channels") == 0) {
        -: 8832:
        -: 8833:      // name: zero-terminated string, from 1 to 255 bytes long
        -: 8834:      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
        -: 8835:      // pLinear: unsigned char, possible values are 0 and 1
        -: 8836:      // reserved: three chars, should be zero
        -: 8837:      // xSampling: int
        -: 8838:      // ySampling: int
        -: 8839:
        -: 8840:      ReadChannelInfo(channels, data);
        -: 8841:
        -: 8842:      numChannels = channels.size();
        -: 8843:
        -: 8844:      if (numChannels < 1) {
        -: 8845:        // if (err) {
        -: 8846:        //  (*err) = "Invalid channels format.";
        -: 8847:        //}
        -: 8848:        return -6;
        -: 8849:      }
        -: 8850:
        -: 8851:    } else if (attrName.compare("dataWindow") == 0) {
        -: 8852:      memcpy(&dx, &data.at(0), sizeof(int));
        -: 8853:      memcpy(&dy, &data.at(4), sizeof(int));
        -: 8854:      memcpy(&dw, &data.at(8), sizeof(int));
        -: 8855:      memcpy(&dh, &data.at(12), sizeof(int));
        -: 8856:      if (IsBigEndian()) {
        -: 8857:        swap4(reinterpret_cast<unsigned int *>(&dx));
        -: 8858:        swap4(reinterpret_cast<unsigned int *>(&dy));
        -: 8859:        swap4(reinterpret_cast<unsigned int *>(&dw));
        -: 8860:        swap4(reinterpret_cast<unsigned int *>(&dh));
        -: 8861:      }
        -: 8862:    } else if (attrName.compare("displayWindow") == 0) {
        -: 8863:      memcpy(&displayWindow[0], &data.at(0), sizeof(int));
        -: 8864:      memcpy(&displayWindow[1], &data.at(4), sizeof(int));
        -: 8865:      memcpy(&displayWindow[2], &data.at(8), sizeof(int));
        -: 8866:      memcpy(&displayWindow[3], &data.at(12), sizeof(int));
        -: 8867:      if (IsBigEndian()) {
        -: 8868:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[0]));
        -: 8869:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[1]));
        -: 8870:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[2]));
        -: 8871:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[3]));
        -: 8872:      }
        -: 8873:    } else if (attrName.compare("lineOrder") == 0) {
        -: 8874:      memcpy(&lineOrder, &data.at(0), sizeof(float));
        -: 8875:      if (IsBigEndian()) {
        -: 8876:        swap4(reinterpret_cast<unsigned int *>(&lineOrder));
        -: 8877:      }
        -: 8878:    } else if (attrName.compare("pixelAspectRatio") == 0) {
        -: 8879:      memcpy(&pixelAspectRatio, &data.at(0), sizeof(float));
        -: 8880:      if (IsBigEndian()) {
        -: 8881:        swap4(reinterpret_cast<unsigned int *>(&pixelAspectRatio));
        -: 8882:      }
        -: 8883:    } else if (attrName.compare("screenWindowCenter") == 0) {
        -: 8884:      memcpy(&screenWindowCenter[0], &data.at(0), sizeof(float));
        -: 8885:      memcpy(&screenWindowCenter[1], &data.at(4), sizeof(float));
        -: 8886:      if (IsBigEndian()) {
        -: 8887:        swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[0]));
        -: 8888:        swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[1]));
        -: 8889:      }
        -: 8890:    } else if (attrName.compare("screenWindowWidth") == 0) {
        -: 8891:      memcpy(&screenWindowWidth, &data.at(0), sizeof(float));
        -: 8892:      if (IsBigEndian()) {
        -: 8893:        swap4(reinterpret_cast<unsigned int *>(&screenWindowWidth));
        -: 8894:      }
        -: 8895:      
        -: 8896:    } else {
        -: 8897:      // Custom attribute(up to TINYEXR_MAX_ATTRIBUTES)
        -: 8898:      if (numCustomAttributes && ((*numCustomAttributes) < TINYEXR_MAX_ATTRIBUTES)) {
        -: 8899:        printf("custom\n");
        -: 8900:        EXRAttribute attrib;
        -: 8901:        attrib.name = strdup(attrName.c_str());
        -: 8902:        attrib.type = strdup(attrType.c_str());
        -: 8903:        attrib.size = data.size();
        -: 8904:        attrib.value = (unsigned char*)malloc(data.size());
        -: 8905:        memcpy((char*)attrib.value, &data.at(0), data.size());
        -: 8906:        attribs.push_back(attrib);
        -: 8907:      }
        -: 8908:    }
        -: 8909:
        -: 8910:    marker = marker_next;
        -: 8911:  }
        -: 8912:
        -: 8913:  assert(dx >= 0);
        -: 8914:  assert(dy >= 0);
        -: 8915:  assert(dw >= 0);
        -: 8916:  assert(dh >= 0);
        -: 8917:  assert(numChannels >= 1);
        -: 8918:
        -: 8919:  int dataWidth = dw - dx + 1;
        -: 8920:  int dataHeight = dh - dy + 1;
        -: 8921:
        -: 8922:  (*width) = dataWidth;
        -: 8923:  (*height) = dataHeight;
        -: 8924:
        -: 8925:  if (numCustomAttributes) {
        -: 8926:    assert(attribs.size() < TINYEXR_MAX_ATTRIBUTES);
        -: 8927:    (*numCustomAttributes) = attribs.size();
        -: 8928:
        -: 8929:    // Assume the pointer to customAttributes has enough memory to store.
        -: 8930:    for (int i = 0; i < (int)attribs.size(); i++) {
        -: 8931:      customAttributes[i] = attribs[i];
        -: 8932:    }
        -: 8933:  } 
        -: 8934:
        -: 8935:  return 0;
        -: 8936:}
        -: 8937:
        -: 8938:int LoadEXRFromMemory(float *out_rgba, const unsigned char *memory,
        -: 8939:                      const char **err) {
        -: 8940:
        -: 8941:  if (out_rgba == NULL || memory == NULL) {
        -: 8942:    if (err) {
        -: 8943:      (*err) = "Invalid argument.\n";
        -: 8944:    }
        -: 8945:    return -1;
        -: 8946:  }
        -: 8947:
        -: 8948:  EXRImage exrImage;
        -: 8949:  InitEXRImage(&exrImage);
        -: 8950:  int ret = LoadMultiChannelEXRFromMemory(&exrImage, memory, err);
        -: 8951:  if (ret != 0) {
        -: 8952:    return ret;
        -: 8953:  }
        -: 8954:
        -: 8955:  // RGBA
        -: 8956:  int idxR = -1;
        -: 8957:  int idxG = -1;
        -: 8958:  int idxB = -1;
        -: 8959:  int idxA = -1;
        -: 8960:  for (int c = 0; c < exrImage.num_channels; c++) {
        -: 8961:    if (strcmp(exrImage.channel_names[c], "R") == 0) {
        -: 8962:      idxR = c;
        -: 8963:    } else if (strcmp(exrImage.channel_names[c], "G") == 0) {
        -: 8964:      idxG = c;
        -: 8965:    } else if (strcmp(exrImage.channel_names[c], "B") == 0) {
        -: 8966:      idxB = c;
        -: 8967:    } else if (strcmp(exrImage.channel_names[c], "A") == 0) {
        -: 8968:      idxA = c;
        -: 8969:    }
        -: 8970:  }
        -: 8971:
        -: 8972:  if (idxR == -1) {
        -: 8973:    if (err) {
        -: 8974:      (*err) = "R channel not found\n";
        -: 8975:    }
        -: 8976:
        -: 8977:    // @todo { free exrImage }
        -: 8978:    return -1;
        -: 8979:  }
        -: 8980:
        -: 8981:  if (idxG == -1) {
        -: 8982:    if (err) {
        -: 8983:      (*err) = "G channel not found\n";
        -: 8984:    }
        -: 8985:    // @todo { free exrImage }
        -: 8986:    return -1;
        -: 8987:  }
        -: 8988:
        -: 8989:  if (idxB == -1) {
        -: 8990:    if (err) {
        -: 8991:      (*err) = "B channel not found\n";
        -: 8992:    }
        -: 8993:    // @todo { free exrImage }
        -: 8994:    return -1;
        -: 8995:  }
        -: 8996:
        -: 8997:  // Assume `out_rgba` have enough memory allocated.
        -: 8998:  for (int i = 0; i < exrImage.width * exrImage.height; i++) {
        -: 8999:    out_rgba[4 * i + 0] = reinterpret_cast<float **>(exrImage.images)[idxR][i];
        -: 9000:    out_rgba[4 * i + 1] = reinterpret_cast<float **>(exrImage.images)[idxG][i];
        -: 9001:    out_rgba[4 * i + 2] = reinterpret_cast<float **>(exrImage.images)[idxB][i];
        -: 9002:    if (idxA > 0) {
        -: 9003:      out_rgba[4 * i + 3] =
        -: 9004:          reinterpret_cast<float **>(exrImage.images)[idxA][i];
        -: 9005:    } else {
        -: 9006:      out_rgba[4 * i + 3] = 1.0;
        -: 9007:    }
        -: 9008:  }
        -: 9009:
        -: 9010:  return 0;
        -: 9011:}
        -: 9012:
    #####: 9013:int LoadMultiChannelEXRFromFile(EXRImage *exrImage, const char *filename,
        -: 9014:                                const char **err) {
    #####: 9015:  if (exrImage == NULL) {
    %%%%%: 9015-block  0
    #####: 9016:    if (err) {
    %%%%%: 9016-block  0
    #####: 9017:      (*err) = "Invalid argument.";
    %%%%%: 9017-block  0
        -: 9018:    }
    #####: 9019:    return -1;
    %%%%%: 9019-block  0
        -: 9020:  }
        -: 9021:
    #####: 9022:  FILE *fp = fopen(filename, "rb");
    %%%%%: 9022-block  0
    #####: 9023:  if (!fp) {
    #####: 9024:    if (err) {
    %%%%%: 9024-block  0
    #####: 9025:      (*err) = "Cannot read file.";
    %%%%%: 9025-block  0
        -: 9026:    }
    #####: 9027:    return -1;
    %%%%%: 9027-block  0
        -: 9028:  }
        -: 9029:
    #####: 9030:  size_t filesize;
        -: 9031:  // Compute size
    #####: 9032:  fseek(fp, 0, SEEK_END);
    %%%%%: 9032-block  0
    #####: 9033:  filesize = ftell(fp);
    #####: 9034:  fseek(fp, 0, SEEK_SET);
        -: 9035:
    #####: 9036:  std::vector<unsigned char> buf(filesize); // @todo { use mmap }
    %%%%%: 9036-block  0
    #####: 9037:  {
    #####: 9038:    size_t ret;
    #####: 9039:    ret = fread(&buf[0], 1, filesize, fp);
    #####: 9040:    assert(ret == filesize);
    %%%%%: 9040-block  0
    %%%%%: 9040-block  1
    #####: 9041:    fclose(fp);
    %%%%%: 9041-block  0
    #####: 9042:    (void)ret;
        -: 9043:  }
        -: 9044:
    #####: 9045:  return LoadMultiChannelEXRFromMemory(exrImage, &buf.at(0), err);
    %%%%%: 9045-block  0
    %%%%%: 9045-block  1
    %%%%%: 9045-block  2
        -: 9046:}
        -: 9047:
    #####: 9048:int LoadMultiChannelEXRFromMemory(EXRImage *exrImage,
        -: 9049:                                  const unsigned char *memory,
        -: 9050:                                  const char **err) {
    #####: 9051:  if (exrImage == NULL || memory == NULL) {
    %%%%%: 9051-block  0
    #####: 9052:    if (err) {
    %%%%%: 9052-block  0
    #####: 9053:      (*err) = "Invalid argument.";
    %%%%%: 9053-block  0
        -: 9054:    }
    #####: 9055:    return -1;
    %%%%%: 9055-block  0
        -: 9056:  }
        -: 9057:
    #####: 9058:  const char *buf = reinterpret_cast<const char *>(memory);
        -: 9059:
    #####: 9060:  const char *head = &buf[0];
    #####: 9061:  const char *marker = &buf[0];
        -: 9062:
        -: 9063:  // Header check.
    #####: 9064:  {
    #####: 9065:    const char header[] = {0x76, 0x2f, 0x31, 0x01};
        -: 9066:
    #####: 9067:    if (memcmp(marker, header, 4) != 0) {
    %%%%%: 9067-block  0
    #####: 9068:      if (err) {
    %%%%%: 9068-block  0
    #####: 9069:        (*err) = "Header mismatch.";
    %%%%%: 9069-block  0
        -: 9070:      }
    #####: 9071:      return -3;
    %%%%%: 9071-block  0
        -: 9072:    }
    #####: 9073:    marker += 4;
        -: 9074:  }
        -: 9075:
        -: 9076:  // Version, scanline.
    #####: 9077:  {
        -: 9078:    // must be [2, 0, 0, 0]
    #####: 9079:    if (marker[0] != 2 || marker[1] != 0 || marker[2] != 0 || marker[3] != 0) {
    %%%%%: 9079-block  0
    %%%%%: 9079-block  1
    %%%%%: 9079-block  2
    %%%%%: 9079-block  3
    #####: 9080:      if (err) {
    %%%%%: 9080-block  0
    #####: 9081:        (*err) = "Unsupported version or scanline.";
    %%%%%: 9081-block  0
        -: 9082:      }
    #####: 9083:      return -4;
    %%%%%: 9083-block  0
        -: 9084:    }
        -: 9085:
    #####: 9086:    marker += 4;
        -: 9087:  }
        -: 9088:
    #####: 9089:  int dx = -1;
    #####: 9090:  int dy = -1;
    #####: 9091:  int dw = -1;
    #####: 9092:  int dh = -1;
    #####: 9093:  int numScanlineBlocks = 1; // 16 for ZIP compression.
    #####: 9094:  int compressionType = -1;
    #####: 9095:  int numChannels = -1;
    #####: 9096:  unsigned char lineOrder = 0; // 0 -> increasing y; 1 -> decreasing
    #####: 9097:  std::vector<ChannelInfo> channels;
    %%%%%: 9097-block  0
        -: 9098:
        -: 9099:  // Read attributes
    #####: 9100:  for (;;) {
    #####: 9101:    std::string attrName;
    %%%%%: 9101-block  0
    %%%%%: 9101-block  1
    $$$$$: 9101-block  2
    #####: 9102:    std::string attrType;
    %%%%%: 9102-block  0
    $$$$$: 9102-block  1
    #####: 9103:    std::vector<unsigned char> data;
    %%%%%: 9103-block  0
    %%%%%: 9103-block  1
    $$$$$: 9103-block  2
    #####: 9104:    const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
    %%%%%: 9104-block  0
    #####: 9105:    if (marker_next == NULL) {
    %%%%%: 9105-block  0
    #####: 9106:      marker++; // skip '\0'
    #####: 9107:      break;
    %%%%%: 9107-block  0
    %%%%%: 9107-block  1
        -: 9108:    }
        -: 9109:
    #####: 9110:    if (attrName.compare("compression") == 0) {
    %%%%%: 9110-block  0
        -: 9111:      //	mwkm
        -: 9112:      //	0 : NO_COMPRESSION
        -: 9113:      //	1 : RLE
        -: 9114:      //	2 : ZIPS (Single scanline)
        -: 9115:      //	3 : ZIP (16-line block)
        -: 9116:      //	4 : PIZ (32-line block)
    #####: 9117:      if (data[0] != 0 && data[0] != 2 && data[0] != 3 && data[0] != 4) {
    %%%%%: 9117-block  0
    %%%%%: 9117-block  1
    %%%%%: 9117-block  2
    %%%%%: 9117-block  3
        -: 9118:
    #####: 9119:        if (err) {
    %%%%%: 9119-block  0
    #####: 9120:          (*err) = "Unsupported compression type.";
    %%%%%: 9120-block  0
        -: 9121:        }
    #####: 9122:        return -5;
    %%%%%: 9122-block  0
    %%%%%: 9122-block  1
        -: 9123:      }
        -: 9124:
    #####: 9125:      compressionType = data[0];
    %%%%%: 9125-block  0
        -: 9126:
    #####: 9127:      if (compressionType == 3) { // ZIP
    %%%%%: 9127-block  0
        -: 9128:        numScanlineBlocks = 16;
    #####: 9129:      } else if (compressionType == 4) { // PIZ
    %%%%%: 9129-block  0
    #####: 9130:        numScanlineBlocks = 32;
    %%%%%: 9130-block  0
        -: 9131:      }
        -: 9132:
    #####: 9133:    } else if (attrName.compare("channels") == 0) {
    %%%%%: 9133-block  0
        -: 9134:
        -: 9135:      // name: zero-terminated string, from 1 to 255 bytes long
        -: 9136:      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
        -: 9137:      // pLinear: unsigned char, possible values are 0 and 1
        -: 9138:      // reserved: three chars, should be zero
        -: 9139:      // xSampling: int
        -: 9140:      // ySampling: int
        -: 9141:
    #####: 9142:      ReadChannelInfo(channels, data);
    %%%%%: 9142-block  0
        -: 9143:
    #####: 9144:      numChannels = channels.size();
    %%%%%: 9144-block  0
        -: 9145:
    #####: 9146:      if (numChannels < 1) {
    %%%%%: 9146-block  0
    #####: 9147:        if (err) {
    %%%%%: 9147-block  0
    #####: 9148:          (*err) = "Invalid channels format.";
    %%%%%: 9148-block  0
        -: 9149:        }
    #####: 9150:        return -6;
    %%%%%: 9150-block  0
        -: 9151:      }
        -: 9152:
    #####: 9153:    } else if (attrName.compare("dataWindow") == 0) {
    %%%%%: 9153-block  0
    #####: 9154:      memcpy(&dx, &data.at(0), sizeof(int));
    %%%%%: 9154-block  0
    %%%%%: 9154-block  1
    #####: 9155:      memcpy(&dy, &data.at(4), sizeof(int));
    %%%%%: 9155-block  0
    %%%%%: 9155-block  1
    #####: 9156:      memcpy(&dw, &data.at(8), sizeof(int));
    %%%%%: 9156-block  0
    %%%%%: 9156-block  1
    #####: 9157:      memcpy(&dh, &data.at(12), sizeof(int));
    %%%%%: 9157-block  0
    %%%%%: 9157-block  1
    #####: 9158:      if (IsBigEndian()) {
    %%%%%: 9158-block  0
        -: 9159:        swap4(reinterpret_cast<unsigned int *>(&dx));
        -: 9160:        swap4(reinterpret_cast<unsigned int *>(&dy));
        -: 9161:        swap4(reinterpret_cast<unsigned int *>(&dw));
    #####: 9162:        swap4(reinterpret_cast<unsigned int *>(&dh));
        -: 9163:      }
    #####: 9164:    } else if (attrName.compare("displayWindow") == 0) {
    %%%%%: 9164-block  0
    #####: 9165:      int x, y, w, h;
    #####: 9166:      memcpy(&x, &data.at(0), sizeof(int));
    %%%%%: 9166-block  0
    %%%%%: 9166-block  1
    #####: 9167:      memcpy(&y, &data.at(4), sizeof(int));
    %%%%%: 9167-block  0
    %%%%%: 9167-block  1
    #####: 9168:      memcpy(&w, &data.at(8), sizeof(int));
    %%%%%: 9168-block  0
    %%%%%: 9168-block  1
    #####: 9169:      memcpy(&h, &data.at(12), sizeof(int));
    %%%%%: 9169-block  0
    %%%%%: 9169-block  1
    #####: 9170:      if (IsBigEndian()) {
        -: 9171:        swap4(reinterpret_cast<unsigned int *>(&x));
        -: 9172:        swap4(reinterpret_cast<unsigned int *>(&y));
        -: 9173:        swap4(reinterpret_cast<unsigned int *>(&w));
    #####: 9174:        swap4(reinterpret_cast<unsigned int *>(&h));
    %%%%%: 9174-block  0
        -: 9175:      }
    #####: 9176:    } else if (attrName.compare("lineOrder") == 0) {
    %%%%%: 9176-block  0
    #####: 9177:      memcpy(&lineOrder, &data.at(0), sizeof(lineOrder));
    %%%%%: 9177-block  0
    %%%%%: 9177-block  1
        -: 9178:    }
        -: 9179:
    #####: 9180:    marker = marker_next;
    %%%%%: 9180-block  0
        -: 9181:  }
        -: 9182:
    #####: 9183:  assert(dx >= 0);
    %%%%%: 9183-block  0
    %%%%%: 9183-block  1
    #####: 9184:  assert(dy >= 0);
    %%%%%: 9184-block  0
    %%%%%: 9184-block  1
    #####: 9185:  assert(dw >= 0);
    %%%%%: 9185-block  0
    %%%%%: 9185-block  1
    #####: 9186:  assert(dh >= 0);
    %%%%%: 9186-block  0
    %%%%%: 9186-block  1
    #####: 9187:  assert(numChannels >= 1);
    %%%%%: 9187-block  0
    %%%%%: 9187-block  1
        -: 9188:
    #####: 9189:  int dataWidth = dw - dx + 1;
    #####: 9190:  int dataHeight = dh - dy + 1;
        -: 9191:
        -: 9192:  // Read offset tables.
    #####: 9193:  int numBlocks = dataHeight / numScanlineBlocks;
    #####: 9194:  if (numBlocks * numScanlineBlocks < dataHeight) {
    %%%%%: 9194-block  0
    #####: 9195:    numBlocks++;
    %%%%%: 9195-block  0
        -: 9196:  }
        -: 9197:
    #####: 9198:  std::vector<long long> offsets(numBlocks);
    %%%%%: 9198-block  0
    %%%%%: 9198-block  1
    $$$$$: 9198-block  2
    $$$$$: 9198-block  3
        -: 9199:
    #####: 9200:  for (int y = 0; y < numBlocks; y++) {
    %%%%%: 9200-block  0
    %%%%%: 9200-block  1
    %%%%%: 9200-block  2
    #####: 9201:    long long offset;
    #####: 9202:    memcpy(&offset, marker, sizeof(long long));
    %%%%%: 9202-block  0
    #####: 9203:    if (IsBigEndian()) {
    #####: 9204:      swap8(reinterpret_cast<unsigned long long *>(&offset));
        -: 9205:    }
    #####: 9206:    marker += sizeof(long long); // = 8
    #####: 9207:    offsets[y] = offset;
    %%%%%: 9207-block  0
        -: 9208:  }
        -: 9209:
        -: 9210:  //	mwkm
        -: 9211:  //	Supported : 0, 2(ZIPS), 3(ZIP), 4(PIZ)
    #####: 9212:  if (compressionType != 0 && compressionType != 2 && compressionType != 3 &&
    %%%%%: 9212-block  0
    %%%%%: 9212-block  1
        -: 9213:      compressionType != 4) {
    #####: 9214:    if (err) {
    %%%%%: 9214-block  0
    #####: 9215:      (*err) = "Unsupported format.";
    %%%%%: 9215-block  0
        -: 9216:    }
    #####: 9217:    return -10;
    %%%%%: 9217-block  0
        -: 9218:  }
        -: 9219:
    #####: 9220:  exrImage->images = reinterpret_cast<unsigned char **>(
    #####: 9221:      (float **)malloc(sizeof(float *) * numChannels));
        -: 9222:
    #####: 9223:  std::vector<size_t> channelOffsetList(numChannels);
    %%%%%: 9223-block  0
    %%%%%: 9223-block  1
    $$$$$: 9223-block  2
    #####: 9224:  int pixelDataSize = 0;
    #####: 9225:  size_t channelOffset = 0;
    #####: 9226:  for (int c = 0; c < numChannels; c++) {
    %%%%%: 9226-block  0
    %%%%%: 9226-block  1
    %%%%%: 9226-block  2
    #####: 9227:    channelOffsetList[c] = channelOffset;
    %%%%%: 9227-block  0
    #####: 9228:    if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {
    %%%%%: 9228-block  0
    #####: 9229:      pixelDataSize += sizeof(unsigned short);
    #####: 9230:      channelOffset += sizeof(unsigned short);
        -: 9231:      // Alloc internal image for half type.
    #####: 9232:      if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
    %%%%%: 9232-block  0
    #####: 9233:        exrImage->images[c] =
    #####: 9234:            reinterpret_cast<unsigned char *>((unsigned short *)malloc(
    #####: 9235:                sizeof(unsigned short) * dataWidth * dataHeight));
    %%%%%: 9235-block  0
    #####: 9236:      } else if (exrImage->requested_pixel_types[c] ==
    %%%%%: 9236-block  0
        -: 9237:                 TINYEXR_PIXELTYPE_FLOAT) {
    #####: 9238:        exrImage->images[c] = reinterpret_cast<unsigned char *>(
    #####: 9239:            (float *)malloc(sizeof(float) * dataWidth * dataHeight));
    %%%%%: 9239-block  0
        -: 9240:      } else {
    #####: 9241:        assert(0);
    %%%%%: 9241-block  0
        -: 9242:      }
    #####: 9243:    } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {
    %%%%%: 9243-block  0
    #####: 9244:      pixelDataSize += sizeof(float);
    #####: 9245:      channelOffset += sizeof(float);
    #####: 9246:      exrImage->images[c] = reinterpret_cast<unsigned char *>(
    #####: 9247:          (float *)malloc(sizeof(float) * dataWidth * dataHeight));
    %%%%%: 9247-block  0
    #####: 9248:    } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {
    %%%%%: 9248-block  0
    #####: 9249:      pixelDataSize += sizeof(unsigned int);
    #####: 9250:      channelOffset += sizeof(unsigned int);
    #####: 9251:      exrImage->images[c] = reinterpret_cast<unsigned char *>((
    #####: 9252:          unsigned int *)malloc(sizeof(unsigned int) * dataWidth * dataHeight));
    %%%%%: 9252-block  0
        -: 9253:    } else {
    #####: 9254:      assert(0);
    %%%%%: 9254-block  0
        -: 9255:    }
        -: 9256:  }
        -: 9257:
        -: 9258:#ifdef _OPENMP
    #####: 9259:#pragma omp parallel for
        -: 9260:#endif
        -: 9261:  for (int y = 0; y < numBlocks; y++) {
        -: 9262:    const unsigned char *dataPtr =
        -: 9263:        reinterpret_cast<const unsigned char *>(head + offsets[y]);
        -: 9264:    // 4 byte: scan line
        -: 9265:    // 4 byte: data size
        -: 9266:    // ~     : pixel data(uncompressed or compressed)
        -: 9267:    int lineNo;
        -: 9268:    memcpy(&lineNo, dataPtr, sizeof(int));
        -: 9269:    int dataLen;
        -: 9270:    memcpy(&dataLen, dataPtr + 4, sizeof(int));
        -: 9271:    if (IsBigEndian()) {
        -: 9272:      swap4(reinterpret_cast<unsigned int *>(&lineNo));
        -: 9273:      swap4(reinterpret_cast<unsigned int *>(&dataLen));
        -: 9274:    }
        -: 9275:
        -: 9276:    int endLineNo = (std::min)(lineNo + numScanlineBlocks, dataHeight);
        -: 9277:
        -: 9278:    int numLines = endLineNo - lineNo;
        -: 9279:
        -: 9280:    if (compressionType == 4) { // PIZ
        -: 9281:      // Allocate original data size.
        -: 9282:      std::vector<unsigned char> outBuf(dataWidth * numLines * pixelDataSize);
        -: 9283:      unsigned int dstLen;
        -: 9284:      size_t tmpBufLen = dataWidth * numLines * pixelDataSize;
        -: 9285:
        -: 9286:      DecompressPiz(reinterpret_cast<unsigned char *>(&outBuf.at(0)), dstLen,
        -: 9287:                    dataPtr + 8, tmpBufLen, channels, dataWidth, numLines);
        -: 9288:
        -: 9289:      bool isBigEndian = IsBigEndian();
        -: 9290:
        -: 9291:      // For ZIP_COMPRESSION:
        -: 9292:      //   pixel sample data for channel 0 for scanline 0
        -: 9293:      //   pixel sample data for channel 1 for scanline 0
        -: 9294:      //   pixel sample data for channel ... for scanline 0
        -: 9295:      //   pixel sample data for channel n for scanline 0
        -: 9296:      //   pixel sample data for channel 0 for scanline 1
        -: 9297:      //   pixel sample data for channel 1 for scanline 1
        -: 9298:      //   pixel sample data for channel ... for scanline 1
        -: 9299:      //   pixel sample data for channel n for scanline 1
        -: 9300:      //   ...
        -: 9301:      for (int c = 0; c < numChannels; c++) {
        -: 9302:
        -: 9303:        if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {
        -: 9304:          for (int v = 0; v < numLines; v++) {
        -: 9305:            const unsigned short *linePtr = reinterpret_cast<unsigned short *>(
        -: 9306:                &outBuf.at(v * pixelDataSize * dataWidth +
        -: 9307:                           channelOffsetList[c] * dataWidth));
        -: 9308:            for (int u = 0; u < dataWidth; u++) {
        -: 9309:              FP16 hf;
        -: 9310:
        -: 9311:              hf.u = linePtr[u];
        -: 9312:
        -: 9313:              if (isBigEndian) {
        -: 9314:                swap2(reinterpret_cast<unsigned short *>(&hf.u));
        -: 9315:              }
        -: 9316:
        -: 9317:              if (exrImage->requested_pixel_types[c] ==
        -: 9318:                  TINYEXR_PIXELTYPE_HALF) {
        -: 9319:                unsigned short *image =
        -: 9320:                    reinterpret_cast<unsigned short **>(exrImage->images)[c];
        -: 9321:                if (lineOrder == 0) {
        -: 9322:                  image += (lineNo + v) * dataWidth + u;
        -: 9323:                } else {
        -: 9324:                  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9325:                }
        -: 9326:                *image = hf.u;
        -: 9327:              } else { // HALF -> FLOAT
        -: 9328:                FP32 f32 = half_to_float(hf);
        -: 9329:                float *image = reinterpret_cast<float **>(exrImage->images)[c];
        -: 9330:                if (lineOrder == 0) {
        -: 9331:                  image += (lineNo + v) * dataWidth + u;
        -: 9332:                } else {
        -: 9333:                  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9334:                }
        -: 9335:                *image = f32.f;
        -: 9336:              }
        -: 9337:            }
        -: 9338:          }
        -: 9339:        } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {
        -: 9340:
        -: 9341:          assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);
        -: 9342:
        -: 9343:          for (int v = 0; v < numLines; v++) {
        -: 9344:            const unsigned int *linePtr = reinterpret_cast<unsigned int *>(
        -: 9345:                &outBuf.at(v * pixelDataSize * dataWidth +
        -: 9346:                           channelOffsetList[c] * dataWidth));
        -: 9347:            for (int u = 0; u < dataWidth; u++) {
        -: 9348:
        -: 9349:              unsigned int val = linePtr[u];
        -: 9350:
        -: 9351:              if (isBigEndian) {
        -: 9352:                swap4(&val);
        -: 9353:              }
        -: 9354:
        -: 9355:              unsigned int *image =
        -: 9356:                  reinterpret_cast<unsigned int **>(exrImage->images)[c];
        -: 9357:              if (lineOrder == 0) {
        -: 9358:                image += (lineNo + v) * dataWidth + u;
        -: 9359:              } else {
        -: 9360:                image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9361:              }
        -: 9362:              *image = val;
        -: 9363:            }
        -: 9364:          }
        -: 9365:        } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {
        -: 9366:          assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);
        -: 9367:          for (int v = 0; v < numLines; v++) {
        -: 9368:            const float *linePtr = reinterpret_cast<float *>(
        -: 9369:                &outBuf.at(v * pixelDataSize * dataWidth +
        -: 9370:                           channelOffsetList[c] * dataWidth));
        -: 9371:            for (int u = 0; u < dataWidth; u++) {
        -: 9372:
        -: 9373:              float val = linePtr[u];
        -: 9374:
        -: 9375:              if (isBigEndian) {
        -: 9376:                swap4(reinterpret_cast<unsigned int *>(&val));
        -: 9377:              }
        -: 9378:
        -: 9379:              float *image = reinterpret_cast<float **>(exrImage->images)[c];
        -: 9380:              if (lineOrder == 0) {
        -: 9381:                image += (lineNo + v) * dataWidth + u;
        -: 9382:              } else {
        -: 9383:                image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9384:              }
        -: 9385:              *image = val;
        -: 9386:            }
        -: 9387:          }
        -: 9388:        } else {
        -: 9389:          assert(0);
        -: 9390:        }
        -: 9391:      }
        -: 9392:
        -: 9393:      //	mwkm, ZIPS or ZIP both good to go
        -: 9394:    } else if (compressionType == 2 || compressionType == 3) { // ZIP
        -: 9395:
        -: 9396:      // Allocate original data size.
        -: 9397:      std::vector<unsigned char> outBuf(dataWidth * numLines * pixelDataSize);
        -: 9398:
        -: 9399:      unsigned long dstLen = outBuf.size();
        -: 9400:      DecompressZip(reinterpret_cast<unsigned char *>(&outBuf.at(0)), dstLen,
        -: 9401:                    dataPtr + 8, dataLen);
        -: 9402:
        -: 9403:      bool isBigEndian = IsBigEndian();
        -: 9404:
        -: 9405:      // For ZIP_COMPRESSION:
        -: 9406:      //   pixel sample data for channel 0 for scanline 0
        -: 9407:      //   pixel sample data for channel 1 for scanline 0
        -: 9408:      //   pixel sample data for channel ... for scanline 0
        -: 9409:      //   pixel sample data for channel n for scanline 0
        -: 9410:      //   pixel sample data for channel 0 for scanline 1
        -: 9411:      //   pixel sample data for channel 1 for scanline 1
        -: 9412:      //   pixel sample data for channel ... for scanline 1
        -: 9413:      //   pixel sample data for channel n for scanline 1
        -: 9414:      //   ...
        -: 9415:      for (int c = 0; c < numChannels; c++) {
        -: 9416:
        -: 9417:        if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {
        -: 9418:          for (int v = 0; v < numLines; v++) {
        -: 9419:            const unsigned short *linePtr = reinterpret_cast<unsigned short *>(
        -: 9420:                &outBuf.at(v * pixelDataSize * dataWidth +
        -: 9421:                           channelOffsetList[c] * dataWidth));
        -: 9422:            for (int u = 0; u < dataWidth; u++) {
        -: 9423:              FP16 hf;
        -: 9424:
        -: 9425:              hf.u = linePtr[u];
        -: 9426:
        -: 9427:              if (isBigEndian) {
        -: 9428:                swap2(reinterpret_cast<unsigned short *>(&hf.u));
        -: 9429:              }
        -: 9430:
        -: 9431:              if (exrImage->requested_pixel_types[c] ==
        -: 9432:                  TINYEXR_PIXELTYPE_HALF) {
        -: 9433:                unsigned short *image =
        -: 9434:                    reinterpret_cast<unsigned short **>(exrImage->images)[c];
        -: 9435:                if (lineOrder == 0) {
        -: 9436:                  image += (lineNo + v) * dataWidth + u;
        -: 9437:                } else {
        -: 9438:                  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9439:                }
        -: 9440:                *image = hf.u;
        -: 9441:              } else { // HALF -> FLOAT
        -: 9442:                FP32 f32 = half_to_float(hf);
        -: 9443:                float *image = reinterpret_cast<float **>(exrImage->images)[c];
        -: 9444:                if (lineOrder == 0) {
        -: 9445:                  image += (lineNo + v) * dataWidth + u;
        -: 9446:                } else {
        -: 9447:                  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9448:                }
        -: 9449:                *image = f32.f;
        -: 9450:              }
        -: 9451:            }
        -: 9452:          }
        -: 9453:        } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {
        -: 9454:
        -: 9455:          assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);
        -: 9456:
        -: 9457:          for (int v = 0; v < numLines; v++) {
        -: 9458:            const unsigned int *linePtr = reinterpret_cast<unsigned int *>(
        -: 9459:                &outBuf.at(v * pixelDataSize * dataWidth +
        -: 9460:                           channelOffsetList[c] * dataWidth));
        -: 9461:            for (int u = 0; u < dataWidth; u++) {
        -: 9462:
        -: 9463:              unsigned int val = linePtr[u];
        -: 9464:
        -: 9465:              if (isBigEndian) {
        -: 9466:                swap4(&val);
        -: 9467:              }
        -: 9468:
        -: 9469:              unsigned int *image =
        -: 9470:                  reinterpret_cast<unsigned int **>(exrImage->images)[c];
        -: 9471:              if (lineOrder == 0) {
        -: 9472:                image += (lineNo + v) * dataWidth + u;
        -: 9473:              } else {
        -: 9474:                image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9475:              }
        -: 9476:              *image = val;
        -: 9477:            }
        -: 9478:          }
        -: 9479:        } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {
        -: 9480:          assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);
        -: 9481:          for (int v = 0; v < numLines; v++) {
        -: 9482:            const float *linePtr = reinterpret_cast<float *>(
        -: 9483:                &outBuf.at(v * pixelDataSize * dataWidth +
        -: 9484:                           channelOffsetList[c] * dataWidth));
        -: 9485:            for (int u = 0; u < dataWidth; u++) {
        -: 9486:
        -: 9487:              float val = linePtr[u];
        -: 9488:
        -: 9489:              if (isBigEndian) {
        -: 9490:                swap4(reinterpret_cast<unsigned int *>(&val));
        -: 9491:              }
        -: 9492:
        -: 9493:              float *image = reinterpret_cast<float **>(exrImage->images)[c];
        -: 9494:              if (lineOrder == 0) {
        -: 9495:                image += (lineNo + v) * dataWidth + u;
        -: 9496:              } else {
        -: 9497:                image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
        -: 9498:              }
        -: 9499:              *image = val;
        -: 9500:            }
        -: 9501:          }
        -: 9502:        } else {
        -: 9503:          assert(0);
        -: 9504:        }
        -: 9505:      }
        -: 9506:
        -: 9507:    } else if (compressionType == 0) { // No compression
        -: 9508:
        -: 9509:      bool isBigEndian = IsBigEndian();
        -: 9510:
        -: 9511:      for (int c = 0; c < numChannels; c++) {
        -: 9512:
        -: 9513:        if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {
        -: 9514:
        -: 9515:          const unsigned short *linePtr =
        -: 9516:              reinterpret_cast<const unsigned short *>(
        -: 9517:                  dataPtr + 8 + c * dataWidth * sizeof(unsigned short));
        -: 9518:
        -: 9519:          if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
        -: 9520:            unsigned short *outLine =
        -: 9521:                reinterpret_cast<unsigned short *>(exrImage->images[c]);
        -: 9522:            if (lineOrder == 0) {
        -: 9523:              outLine += y * dataWidth;
        -: 9524:            } else {
        -: 9525:              outLine += (dataHeight - 1 - y) * dataWidth;
        -: 9526:            }
        -: 9527:
        -: 9528:            for (int u = 0; u < dataWidth; u++) {
        -: 9529:              FP16 hf;
        -: 9530:
        -: 9531:              hf.u = linePtr[u];
        -: 9532:
        -: 9533:              if (isBigEndian) {
        -: 9534:                swap2(reinterpret_cast<unsigned short *>(&hf.u));
        -: 9535:              }
        -: 9536:
        -: 9537:              outLine[u] = hf.u;
        -: 9538:            }
        -: 9539:          } else if (exrImage->requested_pixel_types[c] ==
        -: 9540:                     TINYEXR_PIXELTYPE_FLOAT) {
        -: 9541:            float *outLine = reinterpret_cast<float *>(exrImage->images[c]);
        -: 9542:            if (lineOrder == 0) {
        -: 9543:              outLine += y * dataWidth;
        -: 9544:            } else {
        -: 9545:              outLine += (dataHeight - 1 - y) * dataWidth;
        -: 9546:            }
        -: 9547:
        -: 9548:            for (int u = 0; u < dataWidth; u++) {
        -: 9549:              FP16 hf;
        -: 9550:
        -: 9551:              hf.u = linePtr[u];
        -: 9552:
        -: 9553:              if (isBigEndian) {
        -: 9554:                swap2(reinterpret_cast<unsigned short *>(&hf.u));
        -: 9555:              }
        -: 9556:
        -: 9557:              FP32 f32 = half_to_float(hf);
        -: 9558:
        -: 9559:              outLine[u] = f32.f;
        -: 9560:            }
        -: 9561:          } else {
        -: 9562:            assert(0);
        -: 9563:          }
        -: 9564:        } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {
        -: 9565:
        -: 9566:          const float *linePtr = reinterpret_cast<const float *>(
        -: 9567:              dataPtr + 8 + c * dataWidth * sizeof(float));
        -: 9568:
        -: 9569:          float *outLine = reinterpret_cast<float *>(exrImage->images[c]);
        -: 9570:          if (lineOrder == 0) {
        -: 9571:            outLine += y * dataWidth;
        -: 9572:          } else {
        -: 9573:            outLine += (dataHeight - 1 - y) * dataWidth;
        -: 9574:          }
        -: 9575:
        -: 9576:          for (int u = 0; u < dataWidth; u++) {
        -: 9577:            float val = linePtr[u];
        -: 9578:
        -: 9579:            if (isBigEndian) {
        -: 9580:              swap4(reinterpret_cast<unsigned int *>(&val));
        -: 9581:            }
        -: 9582:
        -: 9583:            outLine[u] = val;
        -: 9584:          }
        -: 9585:        } else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {
        -: 9586:
        -: 9587:          const unsigned int *linePtr = reinterpret_cast<const unsigned int *>(
        -: 9588:              dataPtr + 8 + c * dataWidth * sizeof(unsigned int));
        -: 9589:
        -: 9590:          unsigned int *outLine =
        -: 9591:              reinterpret_cast<unsigned int *>(exrImage->images[c]);
        -: 9592:          if (lineOrder == 0) {
        -: 9593:            outLine += y * dataWidth;
        -: 9594:          } else {
        -: 9595:            outLine += (dataHeight - 1 - y) * dataWidth;
        -: 9596:          }
        -: 9597:
        -: 9598:          for (int u = 0; u < dataWidth; u++) {
        -: 9599:            unsigned int val = linePtr[u];
        -: 9600:
        -: 9601:            if (isBigEndian) {
        -: 9602:              swap4(reinterpret_cast<unsigned int *>(&val));
        -: 9603:            }
        -: 9604:
        -: 9605:            outLine[u] = val;
        -: 9606:          }
        -: 9607:        }
        -: 9608:      }
        -: 9609:    }
        -: 9610:  } // omp parallel
        -: 9611:
    #####: 9612:  {
    #####: 9613:    exrImage->channel_names =
    #####: 9614:        (const char **)malloc(sizeof(const char *) * numChannels);
    #####: 9615:    for (int c = 0; c < numChannels; c++) {
    %%%%%: 9615-block  0
    %%%%%: 9615-block  1
    %%%%%: 9615-block  2
        -: 9616:#ifdef _WIN32
        -: 9617:      exrImage->channel_names[c] = _strdup(channels[c].name.c_str());
        -: 9618:#else
    #####: 9619:      exrImage->channel_names[c] = strdup(channels[c].name.c_str());
    %%%%%: 9619-block  0
        -: 9620:#endif
        -: 9621:    }
    #####: 9622:    exrImage->num_channels = numChannels;
        -: 9623:
    #####: 9624:    exrImage->width = dataWidth;
    #####: 9625:    exrImage->height = dataHeight;
        -: 9626:
        -: 9627:    // Fill with requested_pixel_types.
    #####: 9628:    exrImage->pixel_types = (int *)malloc(sizeof(int *) * numChannels);
    #####: 9629:    for (int c = 0; c < numChannels; c++) {
    %%%%%: 9629-block  0
    %%%%%: 9629-block  1
    #####: 9630:      exrImage->pixel_types[c] = exrImage->requested_pixel_types[c];
    %%%%%: 9630-block  0
        -: 9631:    }
        -: 9632:  }
        -: 9633:
    #####: 9634:  return 0; // OK
    %%%%%: 9634-block  0
        -: 9635:}
        -: 9636:
        -: 9637:// @deprecated
        -: 9638:#if 0
        -: 9639:int SaveEXR(const float *in_rgba, int width, int height, const char *filename,
        -: 9640:            const char **err) {
        -: 9641:  if (in_rgba == NULL || filename == NULL) {
        -: 9642:    if (err) {
        -: 9643:      (*err) = "Invalid argument.";
        -: 9644:    }
        -: 9645:    return -1;
        -: 9646:  }
        -: 9647:
        -: 9648:  FILE *fp = fopen(filename, "wb");
        -: 9649:  if (!fp) {
        -: 9650:    if (err) {
        -: 9651:      (*err) = "Cannot write a file.";
        -: 9652:    }
        -: 9653:    return -1;
        -: 9654:  }
        -: 9655:
        -: 9656:  // Header
        -: 9657:  {
        -: 9658:    const char header[] = {0x76, 0x2f, 0x31, 0x01};
        -: 9659:    size_t n = fwrite(header, 1, 4, fp);
        -: 9660:    assert(n == 4);
        -: 9661:  }
        -: 9662:
        -: 9663:  // Version, scanline.
        -: 9664:  {
        -: 9665:    const char marker[] = {2, 0, 0, 0};
        -: 9666:    size_t n = fwrite(marker, 1, 4, fp);
        -: 9667:    assert(n == 4);
        -: 9668:  }
        -: 9669:
        -: 9670:  int numScanlineBlocks = 16; // 16 for ZIP compression.
        -: 9671:
        -: 9672:  // Write attributes.
        -: 9673:  {
        -: 9674:    unsigned char data[] = {
        -: 9675:        'A', 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,   0,   'B',
        -: 9676:        0,   1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,   'G', 0,
        -: 9677:        1,   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 'R', 0,   1,
        -: 9678:        0,   0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0}; // last 0 =
        -: 9679:                                                           // terminator.
        -: 9680:
        -: 9681:    WriteAttribute(fp, "channels", "chlist", data, 18 * 4 + 1); // +1 = null
        -: 9682:  }
        -: 9683:
        -: 9684:  {
        -: 9685:    int compressionType = 3; // ZIP compression
        -: 9686:    WriteAttribute(fp, "compression", "compression",
        -: 9687:                   reinterpret_cast<const unsigned char *>(&compressionType),
        -: 9688:                   1);
        -: 9689:  }
        -: 9690:
        -: 9691:  {
        -: 9692:    int data[4] = {0, 0, width - 1, height - 1};
        -: 9693:    WriteAttribute(fp, "dataWindow", "box2i",
        -: 9694:                   reinterpret_cast<const unsigned char *>(data),
        -: 9695:                   sizeof(int) * 4);
        -: 9696:    WriteAttribute(fp, "displayWindow", "box2i",
        -: 9697:                   reinterpret_cast<const unsigned char *>(data),
        -: 9698:                   sizeof(int) * 4);
        -: 9699:  }
        -: 9700:
        -: 9701:  {
        -: 9702:    unsigned char lineOrder = 0; // increasingY
        -: 9703:    WriteAttribute(fp, "lineOrder", "lineOrder", &lineOrder, 1);
        -: 9704:  }
        -: 9705:
        -: 9706:  {
        -: 9707:    float aspectRatio = 1.0f;
        -: 9708:    WriteAttribute(fp, "pixelAspectRatio", "float",
        -: 9709:                   reinterpret_cast<const unsigned char *>(&aspectRatio),
        -: 9710:                   sizeof(float));
        -: 9711:  }
        -: 9712:
        -: 9713:  {
        -: 9714:    float center[2] = {0.0f, 0.0f};
        -: 9715:    WriteAttribute(fp, "screenWindowCenter", "v2f",
        -: 9716:                   reinterpret_cast<const unsigned char *>(center),
        -: 9717:                   2 * sizeof(float));
        -: 9718:  }
        -: 9719:
        -: 9720:  {
        -: 9721:    float w = (float)width;
        -: 9722:    WriteAttribute(fp, "screenWindowWidth", "float",
        -: 9723:                   reinterpret_cast<const unsigned char *>(&w), sizeof(float));
        -: 9724:  }
        -: 9725:
        -: 9726:  { // end of header
        -: 9727:    unsigned char e = 0;
        -: 9728:    fwrite(&e, 1, 1, fp);
        -: 9729:  }
        -: 9730:
        -: 9731:  int numBlocks = height / numScanlineBlocks;
        -: 9732:  if (numBlocks * numScanlineBlocks < height) {
        -: 9733:    numBlocks++;
        -: 9734:  }
        -: 9735:
        -: 9736:  std::vector<long long> offsets(numBlocks);
        -: 9737:
        -: 9738:  size_t headerSize = ftell(fp); // sizeof(header)
        -: 9739:  long long offset =
        -: 9740:      headerSize +
        -: 9741:      numBlocks * sizeof(long long); // sizeof(header) + sizeof(offsetTable)
        -: 9742:
        -: 9743:  std::vector<unsigned char> data;
        -: 9744:
        -: 9745:  for (int i = 0; i < numBlocks; i++) {
        -: 9746:    int startY = numScanlineBlocks * i;
        -: 9747:    int endY = (std::min)(numScanlineBlocks * (i + 1), height);
        -: 9748:    int h = endY - startY;
        -: 9749:
        -: 9750:    std::vector<unsigned short> buf(4 * width * h);
        -: 9751:
        -: 9752:    for (int y = 0; y < h; y++) {
        -: 9753:      for (int x = 0; x < width; x++) {
        -: 9754:        FP32 r, g, b, a;
        -: 9755:        r.f = in_rgba[4 * ((y + startY) * width + x) + 0];
        -: 9756:        g.f = in_rgba[4 * ((y + startY) * width + x) + 1];
        -: 9757:        b.f = in_rgba[4 * ((y + startY) * width + x) + 2];
        -: 9758:        a.f = in_rgba[4 * ((y + startY) * width + x) + 3];
        -: 9759:
        -: 9760:        FP16 hr, hg, hb, ha;
        -: 9761:        hr = float_to_half_full(r);
        -: 9762:        hg = float_to_half_full(g);
        -: 9763:        hb = float_to_half_full(b);
        -: 9764:        ha = float_to_half_full(a);
        -: 9765:
        -: 9766:        // Assume increasing Y
        -: 9767:        buf[4 * y * width + 3 * width + x] = hr.u;
        -: 9768:        buf[4 * y * width + 2 * width + x] = hg.u;
        -: 9769:        buf[4 * y * width + 1 * width + x] = hb.u;
        -: 9770:        buf[4 * y * width + 0 * width + x] = ha.u;
        -: 9771:      }
        -: 9772:    }
        -: 9773:
        -: 9774:    int bound = miniz::mz_compressBound(buf.size() * sizeof(unsigned short));
        -: 9775:
        -: 9776:    std::vector<unsigned char> block(
        -: 9777:        miniz::mz_compressBound(buf.size() * sizeof(unsigned short)));
        -: 9778:    unsigned long long outSize = block.size();
        -: 9779:
        -: 9780:    CompressZip(&block.at(0), outSize,
        -: 9781:                reinterpret_cast<const unsigned char *>(&buf.at(0)),
        -: 9782:                buf.size() * sizeof(unsigned short));
        -: 9783:
        -: 9784:    // 4 byte: scan line
        -: 9785:    // 4 byte: data size
        -: 9786:    // ~     : pixel data(compressed)
        -: 9787:    std::vector<unsigned char> header(8);
        -: 9788:    unsigned int dataLen = outSize; // truncate
        -: 9789:    memcpy(&header.at(0), &startY, sizeof(int));
        -: 9790:    memcpy(&header.at(4), &dataLen, sizeof(unsigned int));
        -: 9791:
        -: 9792:    data.insert(data.end(), header.begin(), header.end());
        -: 9793:    data.insert(data.end(), block.begin(), block.begin() + dataLen);
        -: 9794:
        -: 9795:    offsets[i] = offset;
        -: 9796:    offset += dataLen + 8; // 8 = sizeof(blockHeader)
        -: 9797:  }
        -: 9798:
        -: 9799:  fwrite(&offsets.at(0), 1, sizeof(unsigned long long) * numBlocks, fp);
        -: 9800:
        -: 9801:  fwrite(&data.at(0), 1, data.size(), fp);
        -: 9802:
        -: 9803:  fclose(fp);
        -: 9804:
        -: 9805:  return 0; // OK
        -: 9806:}
        -: 9807:#endif
        -: 9808:
    #####: 9809:size_t SaveMultiChannelEXRToMemory(const EXRImage *exrImage,
        -: 9810:                                   unsigned char **memory_out,
        -: 9811:                                   const char **err) {
    #####: 9812:  if (exrImage == NULL || memory_out == NULL) {
    %%%%%: 9812-block  0
    #####: 9813:    if (err) {
    %%%%%: 9813-block  0
    #####: 9814:      (*err) = "Invalid argument.";
    %%%%%: 9814-block  0
        -: 9815:    }
    #####: 9816:    return -1;
    %%%%%: 9816-block  0
        -: 9817:  }
        -: 9818:
    #####: 9819:  std::vector<unsigned char> memory;
    %%%%%: 9819-block  0
    %%%%%: 9819-block  1
        -: 9820:
        -: 9821:  // Header
    #####: 9822:  {
    #####: 9823:    const char header[] = {0x76, 0x2f, 0x31, 0x01};
    #####: 9824:    memory.insert(memory.end(), header, header + 4);
    %%%%%: 9824-block  0
        -: 9825:  }
        -: 9826:
        -: 9827:  // Version, scanline.
    #####: 9828:  {
    #####: 9829:    const char marker[] = {2, 0, 0, 0};
    #####: 9830:    memory.insert(memory.end(), marker, marker + 4);
    %%%%%: 9830-block  0
        -: 9831:  }
        -: 9832:
    #####: 9833:  int numScanlineBlocks =
        -: 9834:      16; // 1 for no compress & ZIPS, 16 for ZIP compression.
        -: 9835:
        -: 9836:  // Write attributes.
    #####: 9837:  {
    #####: 9838:    std::vector<unsigned char> data;
    %%%%%: 9838-block  0
    $$$$$: 9838-block  1
        -: 9839:
    #####: 9840:    std::vector<ChannelInfo> channels;
    %%%%%: 9840-block  0
    $$$$$: 9840-block  1
    #####: 9841:    for (int c = 0; c < exrImage->num_channels; c++) {
    %%%%%: 9841-block  0
    %%%%%: 9841-block  1
    #####: 9842:      ChannelInfo info;
    %%%%%: 9842-block  0
    %%%%%: 9842-block  1
    $$$$$: 9842-block  2
    #####: 9843:      info.pLinear = 0;
    #####: 9844:      info.pixelType = exrImage->requested_pixel_types[c];
    #####: 9845:      info.xSampling = 1;
    #####: 9846:      info.ySampling = 1;
    #####: 9847:      info.name = std::string(exrImage->channel_names[c]);
    %%%%%: 9847-block  0
    %%%%%: 9847-block  1
    #####: 9848:      channels.push_back(info);
    %%%%%: 9848-block  0
        -: 9849:    }
        -: 9850:
    #####: 9851:    WriteChannelInfo(data, channels);
    %%%%%: 9851-block  0
        -: 9852:
    #####: 9853:    WriteAttributeToMemory(memory, "channels", "chlist", &data.at(0),
    %%%%%: 9853-block  0
    #####: 9854:                           data.size()); // +1 = null
    %%%%%: 9854-block  0
        -: 9855:  }
        -: 9856:
    #####: 9857:  {
    #####: 9858:    int compressionType = 3; // ZIP compression
    #####: 9859:    if (IsBigEndian()) {
    #####: 9860:      swap4(reinterpret_cast<unsigned int *>(&compressionType));
        -: 9861:    }
    #####: 9862:    WriteAttributeToMemory(
    %%%%%: 9862-block  0
        -: 9863:        memory, "compression", "compression",
        -: 9864:        reinterpret_cast<const unsigned char *>(&compressionType), 1);
        -: 9865:  }
        -: 9866:
    #####: 9867:  {
    #####: 9868:    int data[4] = {0, 0, exrImage->width - 1, exrImage->height - 1};
    #####: 9869:    if (IsBigEndian()) {
        -: 9870:      swap4(reinterpret_cast<unsigned int *>(&data[0]));
        -: 9871:      swap4(reinterpret_cast<unsigned int *>(&data[1]));
        -: 9872:      swap4(reinterpret_cast<unsigned int *>(&data[2]));
    #####: 9873:      swap4(reinterpret_cast<unsigned int *>(&data[3]));
        -: 9874:    }
    #####: 9875:    WriteAttributeToMemory(memory, "dataWindow", "box2i",
    %%%%%: 9875-block  0
        -: 9876:                           reinterpret_cast<const unsigned char *>(data),
        -: 9877:                           sizeof(int) * 4);
    #####: 9878:    WriteAttributeToMemory(memory, "displayWindow", "box2i",
    %%%%%: 9878-block  0
        -: 9879:                           reinterpret_cast<const unsigned char *>(data),
        -: 9880:                           sizeof(int) * 4);
        -: 9881:  }
        -: 9882:
    #####: 9883:  {
    #####: 9884:    unsigned char lineOrder = 0; // increasingY
    #####: 9885:    WriteAttributeToMemory(memory, "lineOrder", "lineOrder", &lineOrder, 1);
    %%%%%: 9885-block  0
        -: 9886:  }
        -: 9887:
    #####: 9888:  {
    #####: 9889:    float aspectRatio = 1.0f;
    #####: 9890:    if (IsBigEndian()) {
    #####: 9891:      swap4(reinterpret_cast<unsigned int *>(&aspectRatio));
        -: 9892:    }
    #####: 9893:    WriteAttributeToMemory(
    %%%%%: 9893-block  0
        -: 9894:        memory, "pixelAspectRatio", "float",
        -: 9895:        reinterpret_cast<const unsigned char *>(&aspectRatio), sizeof(float));
        -: 9896:  }
        -: 9897:
    #####: 9898:  {
    #####: 9899:    float center[2] = {0.0f, 0.0f};
    #####: 9900:    if (IsBigEndian()) {
        -: 9901:      swap4(reinterpret_cast<unsigned int *>(&center[0]));
    #####: 9902:      swap4(reinterpret_cast<unsigned int *>(&center[1]));
        -: 9903:    }
    #####: 9904:    WriteAttributeToMemory(memory, "screenWindowCenter", "v2f",
    %%%%%: 9904-block  0
        -: 9905:                           reinterpret_cast<const unsigned char *>(center),
        -: 9906:                           2 * sizeof(float));
        -: 9907:  }
        -: 9908:
    #####: 9909:  {
    #####: 9910:    float w = (float)exrImage->width;
    #####: 9911:    if (IsBigEndian()) {
    #####: 9912:      swap4(reinterpret_cast<unsigned int *>(&w));
        -: 9913:    }
    #####: 9914:    WriteAttributeToMemory(memory, "screenWindowWidth", "float",
    %%%%%: 9914-block  0
        -: 9915:                           reinterpret_cast<const unsigned char *>(&w),
        -: 9916:                           sizeof(float));
        -: 9917:  }
        -: 9918:
        -: 9919:  // Custom attributes
    #####: 9920:  if (exrImage->num_custom_attributes > 0) {
    %%%%%: 9920-block  0
    #####: 9921:    printf("custom\n");
    %%%%%: 9921-block  0
        -: 9922:    // @todo { endian }
    #####: 9923:    for (int i = 0; i < exrImage->num_custom_attributes; i++) {
    %%%%%: 9923-block  0
    %%%%%: 9923-block  1
    #####: 9924:      WriteAttributeToMemory(memory, exrImage->custom_attributes[i].name, exrImage->custom_attributes[i].type,
    #####: 9925:                             reinterpret_cast<const unsigned char *>(&exrImage->custom_attributes[i].value),
    #####: 9926:                             exrImage->custom_attributes[i].size);
    %%%%%: 9926-block  0
        -: 9927:        
        -: 9928:    }
        -: 9929:  }
        -: 9930:
    #####: 9931:  { // end of header
    #####: 9932:    unsigned char e = 0;
    #####: 9933:    memory.push_back(e);
    %%%%%: 9933-block  0
        -: 9934:  }
        -: 9935:
    #####: 9936:  int numBlocks = exrImage->height / numScanlineBlocks;
    #####: 9937:  if (numBlocks * numScanlineBlocks < exrImage->height) {
    %%%%%: 9937-block  0
    #####: 9938:    numBlocks++;
    %%%%%: 9938-block  0
        -: 9939:  }
        -: 9940:
    #####: 9941:  std::vector<long long> offsets(numBlocks);
    %%%%%: 9941-block  0
    %%%%%: 9941-block  1
    $$$$$: 9941-block  2
    $$$$$: 9941-block  3
        -: 9942:
    #####: 9943:  size_t headerSize = memory.size();
    %%%%%: 9943-block  0
    #####: 9944:  long long offset =
    #####: 9945:      headerSize +
    #####: 9946:      numBlocks * sizeof(long long); // sizeof(header) + sizeof(offsetTable)
        -: 9947:
    #####: 9948:  std::vector<unsigned char> data;
    %%%%%: 9948-block  0
    %%%%%: 9948-block  1
    $$$$$: 9948-block  2
        -: 9949:
    #####: 9950:  bool isBigEndian = IsBigEndian();
        -: 9951:
    #####: 9952:  std::vector<std::vector<unsigned char> > dataList(numBlocks);
    %%%%%: 9952-block  0
    $$$$$: 9952-block  1
    #####: 9953:  std::vector<size_t> channelOffsetList(exrImage->num_channels);
    %%%%%: 9953-block  0
    %%%%%: 9953-block  1
    $$$$$: 9953-block  2
    $$$$$: 9953-block  3
        -: 9954:
    #####: 9955:  int pixelDataSize = 0;
    #####: 9956:  size_t channelOffset = 0;
    #####: 9957:  for (int c = 0; c < exrImage->num_channels; c++) {
    %%%%%: 9957-block  0
    %%%%%: 9957-block  1
    %%%%%: 9957-block  2
    #####: 9958:    channelOffsetList[c] = channelOffset;
    %%%%%: 9958-block  0
    #####: 9959:    if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
    %%%%%: 9959-block  0
    #####: 9960:      pixelDataSize += sizeof(unsigned short);
    #####: 9961:      channelOffset += sizeof(unsigned short);
    %%%%%: 9961-block  0
    #####: 9962:    } else if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {
    %%%%%: 9962-block  0
    #####: 9963:      pixelDataSize += sizeof(float);
    #####: 9964:      channelOffset += sizeof(float);
    %%%%%: 9964-block  0
    #####: 9965:    } else if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {
    %%%%%: 9965-block  0
    #####: 9966:      pixelDataSize += sizeof(unsigned int);
    #####: 9967:      channelOffset += sizeof(unsigned int);
    %%%%%: 9967-block  0
        -: 9968:    } else {
    #####: 9969:      assert(0);
    %%%%%: 9969-block  0
        -: 9970:    }
        -: 9971:  }
        -: 9972:
        -: 9973:#ifdef _OPENMP
    #####: 9974:#pragma omp parallel for
        -: 9975:#endif
        -: 9976:  for (int i = 0; i < numBlocks; i++) {
        -: 9977:    int startY = numScanlineBlocks * i;
        -: 9978:    int endY = (std::min)(numScanlineBlocks * (i + 1), exrImage->height);
        -: 9979:    int h = endY - startY;
        -: 9980:
        -: 9981:    std::vector<unsigned char> buf(exrImage->width * h * pixelDataSize);
        -: 9982:
        -: 9983:    for (int c = 0; c < exrImage->num_channels; c++) {
        -: 9984:      if (exrImage->pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
        -: 9985:
        -: 9986:        if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {
        -: 9987:          for (int y = 0; y < h; y++) {
        -: 9988:            for (int x = 0; x < exrImage->width; x++) {
        -: 9989:              FP16 h16;
        -: 9990:              h16.u = reinterpret_cast<unsigned short **>(
        -: 9991:                  exrImage->images)[c][(y + startY) * exrImage->width + x];
        -: 9992:
        -: 9993:              FP32 f32 = half_to_float(h16);
        -: 9994:
        -: 9995:              if (isBigEndian) {
        -: 9996:                swap4(reinterpret_cast<unsigned int *>(&f32.f));
        -: 9997:              }
        -: 9998:
        -: 9999:              // Assume increasing Y
        -:10000:              float *linePtr = reinterpret_cast<float *>(
        -:10001:                  &buf.at(pixelDataSize * y * exrImage->width +
        -:10002:                          channelOffsetList[c] * exrImage->width));
        -:10003:              linePtr[x] = f32.f;
        -:10004:            }
        -:10005:          }
        -:10006:        } else if (exrImage->requested_pixel_types[c] ==
        -:10007:                   TINYEXR_PIXELTYPE_HALF) {
        -:10008:          for (int y = 0; y < h; y++) {
        -:10009:            for (int x = 0; x < exrImage->width; x++) {
        -:10010:              unsigned short val = reinterpret_cast<unsigned short **>(
        -:10011:                  exrImage->images)[c][(y + startY) * exrImage->width + x];
        -:10012:
        -:10013:              if (isBigEndian) {
        -:10014:                swap2(&val);
        -:10015:              }
        -:10016:
        -:10017:              // Assume increasing Y
        -:10018:              unsigned short *linePtr = reinterpret_cast<unsigned short *>(
        -:10019:                  &buf.at(pixelDataSize * y * exrImage->width +
        -:10020:                          channelOffsetList[c] * exrImage->width));
        -:10021:              linePtr[x] = val;
        -:10022:            }
        -:10023:          }
        -:10024:        } else {
        -:10025:          assert(0);
        -:10026:        }
        -:10027:
        -:10028:      } else if (exrImage->pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {
        -:10029:
        -:10030:        if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
        -:10031:          for (int y = 0; y < h; y++) {
        -:10032:            for (int x = 0; x < exrImage->width; x++) {
        -:10033:              FP32 f32;
        -:10034:              f32.f = reinterpret_cast<float **>(
        -:10035:                  exrImage->images)[c][(y + startY) * exrImage->width + x];
        -:10036:
        -:10037:              FP16 h16;
        -:10038:              h16 = float_to_half_full(f32);
        -:10039:
        -:10040:              if (isBigEndian) {
        -:10041:                swap2(reinterpret_cast<unsigned short *>(&h16.u));
        -:10042:              }
        -:10043:
        -:10044:              // Assume increasing Y
        -:10045:              unsigned short *linePtr = reinterpret_cast<unsigned short *>(
        -:10046:                  &buf.at(pixelDataSize * y * exrImage->width +
        -:10047:                          channelOffsetList[c] * exrImage->width));
        -:10048:              linePtr[x] = h16.u;
        -:10049:            }
        -:10050:          }
        -:10051:        } else if (exrImage->requested_pixel_types[c] ==
        -:10052:                   TINYEXR_PIXELTYPE_FLOAT) {
        -:10053:          for (int y = 0; y < h; y++) {
        -:10054:            for (int x = 0; x < exrImage->width; x++) {
        -:10055:              float val = reinterpret_cast<float **>(
        -:10056:                  exrImage->images)[c][(y + startY) * exrImage->width + x];
        -:10057:
        -:10058:              if (isBigEndian) {
        -:10059:                swap4(reinterpret_cast<unsigned int *>(&val));
        -:10060:              }
        -:10061:
        -:10062:              // Assume increasing Y
        -:10063:              float *linePtr = reinterpret_cast<float *>(
        -:10064:                  &buf.at(pixelDataSize * y * exrImage->width +
        -:10065:                          channelOffsetList[c] * exrImage->width));
        -:10066:              linePtr[x] = val;
        -:10067:            }
        -:10068:          }
        -:10069:        } else {
        -:10070:          assert(0);
        -:10071:        }
        -:10072:      } else if (exrImage->pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {
        -:10073:
        -:10074:        for (int y = 0; y < h; y++) {
        -:10075:          for (int x = 0; x < exrImage->width; x++) {
        -:10076:            unsigned int val = reinterpret_cast<unsigned int **>(
        -:10077:                exrImage->images)[c][(y + startY) * exrImage->width + x];
        -:10078:
        -:10079:            if (isBigEndian) {
        -:10080:              swap4(&val);
        -:10081:            }
        -:10082:
        -:10083:            // Assume increasing Y
        -:10084:            unsigned int *linePtr = reinterpret_cast<unsigned int *>(
        -:10085:                &buf.at(pixelDataSize * y * exrImage->width +
        -:10086:                        channelOffsetList[c] * exrImage->width));
        -:10087:            linePtr[x] = val;
        -:10088:          }
        -:10089:        }
        -:10090:      }
        -:10091:    }
        -:10092:
        -:10093:    std::vector<unsigned char> block(miniz::mz_compressBound(buf.size()));
        -:10094:    unsigned long long outSize = block.size();
        -:10095:
        -:10096:    CompressZip(&block.at(0), outSize,
        -:10097:                reinterpret_cast<const unsigned char *>(&buf.at(0)),
        -:10098:                buf.size());
        -:10099:
        -:10100:    // 4 byte: scan line
        -:10101:    // 4 byte: data size
        -:10102:    // ~     : pixel data(compressed)
        -:10103:    std::vector<unsigned char> header(8);
        -:10104:    unsigned int dataLen = outSize; // truncate
        -:10105:    memcpy(&header.at(0), &startY, sizeof(int));
        -:10106:    memcpy(&header.at(4), &dataLen, sizeof(unsigned int));
        -:10107:
        -:10108:    if (IsBigEndian()) {
        -:10109:      swap4(reinterpret_cast<unsigned int *>(&header.at(0)));
        -:10110:      swap4(reinterpret_cast<unsigned int *>(&header.at(4)));
        -:10111:    }
        -:10112:
        -:10113:    dataList[i].insert(dataList[i].end(), header.begin(), header.end());
        -:10114:    dataList[i].insert(dataList[i].end(), block.begin(),
        -:10115:                       block.begin() + dataLen);
        -:10116:
        -:10117:    // data.insert(data.end(), header.begin(), header.end());
        -:10118:    // data.insert(data.end(), block.begin(), block.begin() + dataLen);
        -:10119:
        -:10120:    // offsets[i] = offset;
        -:10121:    // if (IsBigEndian()) {
        -:10122:    //  swap8(reinterpret_cast<unsigned long long*>(&offsets[i]));
        -:10123:    //}
        -:10124:    // offset += dataLen + 8; // 8 = sizeof(blockHeader)
        -:10125:  } // omp parallel
        -:10126:
    #####:10127:  for (int i = 0; i < numBlocks; i++) {
    %%%%%:10127-block  0
    %%%%%:10127-block  1
    %%%%%:10127-block  2
        -:10128:
    #####:10129:    data.insert(data.end(), dataList[i].begin(), dataList[i].end());
    %%%%%:10129-block  0
        -:10130:
    #####:10131:    offsets[i] = offset;
    %%%%%:10131-block  0
    #####:10132:    if (IsBigEndian()) {
    #####:10133:      swap8(reinterpret_cast<unsigned long long *>(&offsets[i]));
        -:10134:    }
    #####:10135:    offset += dataList[i].size();
    %%%%%:10135-block  0
        -:10136:  }
        -:10137:
    #####:10138:  {
    #####:10139:    memory.insert(memory.end(),
    %%%%%:10139-block  0
    %%%%%:10139-block  1
    #####:10140:                  reinterpret_cast<unsigned char *>(&offsets.at(0)),
    %%%%%:10140-block  0
    #####:10141:                  reinterpret_cast<unsigned char *>(&offsets.at(0)) +
    #####:10142:                      sizeof(unsigned long long) * numBlocks);
    %%%%%:10142-block  0
        -:10143:  }
        -:10144:
    #####:10145:  { memory.insert(memory.end(), data.begin(), data.end()); }
    %%%%%:10145-block  0
    $$$$$:10145-block  1
        -:10146:
    #####:10147:  assert(memory.size() > 0);
    %%%%%:10147-block  0
    %%%%%:10147-block  1
        -:10148:
    #####:10149:  (*memory_out) = (unsigned char *)malloc(memory.size());
    %%%%%:10149-block  0
    #####:10150:  memcpy((*memory_out), &memory.at(0), memory.size());
    %%%%%:10150-block  0
    %%%%%:10150-block  1
        -:10151:
    #####:10152:  return memory.size(); // OK
    %%%%%:10152-block  0
        -:10153:}
        -:10154:
    #####:10155:int SaveMultiChannelEXRToFile(const EXRImage *exrImage, const char *filename,
        -:10156:                              const char **err) {
    #####:10157:  if (exrImage == NULL || filename == NULL) {
    %%%%%:10157-block  0
    #####:10158:    if (err) {
    %%%%%:10158-block  0
    #####:10159:      (*err) = "Invalid argument.";
    %%%%%:10159-block  0
        -:10160:    }
    #####:10161:    return -1;
    %%%%%:10161-block  0
        -:10162:  }
        -:10163:
    #####:10164:  FILE *fp = fopen(filename, "wb");
    %%%%%:10164-block  0
    #####:10165:  if (!fp) {
    #####:10166:    if (err) {
    %%%%%:10166-block  0
    #####:10167:      (*err) = "Cannot write a file.";
    %%%%%:10167-block  0
        -:10168:    }
    #####:10169:    return -1;
    %%%%%:10169-block  0
        -:10170:  }
        -:10171:
    #####:10172:  unsigned char *mem = NULL;
    #####:10173:  size_t mem_size = SaveMultiChannelEXRToMemory(exrImage, &mem, err);
    %%%%%:10173-block  0
        -:10174:
    #####:10175:  if ((mem_size > 0) && mem) {
    %%%%%:10175-block  0
        -:10176:
    #####:10177:    fwrite(mem, 1, mem_size, fp);
    %%%%%:10177-block  0
        -:10178:  }
    #####:10179:  free(mem);
        -:10180:
    #####:10181:  fclose(fp);
    %%%%%:10181-block  0
        -:10182:
        -:10183:  return 0; // OK
        -:10184:}
        -:10185:
        -:10186:int LoadDeepEXR(DeepImage *deepImage, const char *filename, const char **err) {
        -:10187:  if (deepImage == NULL) {
        -:10188:    if (err) {
        -:10189:      (*err) = "Invalid argument.";
        -:10190:    }
        -:10191:    return -1;
        -:10192:  }
        -:10193:
        -:10194:  FILE *fp = fopen(filename, "rb");
        -:10195:  if (!fp) {
        -:10196:    if (err) {
        -:10197:      (*err) = "Cannot read file.";
        -:10198:    }
        -:10199:    return -1;
        -:10200:  }
        -:10201:
        -:10202:  size_t filesize;
        -:10203:  // Compute size
        -:10204:  fseek(fp, 0, SEEK_END);
        -:10205:  filesize = ftell(fp);
        -:10206:  fseek(fp, 0, SEEK_SET);
        -:10207:
        -:10208:  if (filesize == 0) {
        -:10209:    fclose(fp);
        -:10210:    if (err) {
        -:10211:      (*err) = "File size is zero.";
        -:10212:    }
        -:10213:    return -1;
        -:10214:  }
        -:10215:
        -:10216:  std::vector<char> buf(filesize); // @todo { use mmap }
        -:10217:  {
        -:10218:    size_t ret;
        -:10219:    ret = fread(&buf[0], 1, filesize, fp);
        -:10220:    assert(ret == filesize);
        -:10221:    (void)ret;
        -:10222:  }
        -:10223:  fclose(fp);
        -:10224:
        -:10225:  const char *head = &buf[0];
        -:10226:  const char *marker = &buf[0];
        -:10227:
        -:10228:  // Header check.
        -:10229:  {
        -:10230:    const char header[] = {0x76, 0x2f, 0x31, 0x01};
        -:10231:
        -:10232:    if (memcmp(marker, header, 4) != 0) {
        -:10233:      if (err) {
        -:10234:        (*err) = "Header mismatch.";
        -:10235:      }
        -:10236:      return -3;
        -:10237:    }
        -:10238:    marker += 4;
        -:10239:  }
        -:10240:
        -:10241:  // Version, scanline.
        -:10242:  {
        -:10243:    // ver 2.0, scanline, deep bit on(0x800)
        -:10244:    // must be [2, 0, 0, 0]
        -:10245:    if (marker[0] != 2 || marker[1] != 8 || marker[2] != 0 || marker[3] != 0) {
        -:10246:      if (err) {
        -:10247:        (*err) = "Unsupported version or scanline.";
        -:10248:      }
        -:10249:      return -4;
        -:10250:    }
        -:10251:
        -:10252:    marker += 4;
        -:10253:  }
        -:10254:
        -:10255:  int dx = -1;
        -:10256:  int dy = -1;
        -:10257:  int dw = -1;
        -:10258:  int dh = -1;
        -:10259:  int numScanlineBlocks = 1; // 16 for ZIP compression.
        -:10260:  int compressionType = -1;
        -:10261:  int numChannels = -1;
        -:10262:  std::vector<ChannelInfo> channels;
        -:10263:
        -:10264:  // Read attributes
        -:10265:  for (;;) {
        -:10266:    std::string attrName;
        -:10267:    std::string attrType;
        -:10268:    std::vector<unsigned char> data;
        -:10269:    const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
        -:10270:    if (marker_next == NULL) {
        -:10271:      marker++; // skip '\0'
        -:10272:      break;
        -:10273:    }
        -:10274:
        -:10275:    if (attrName.compare("compression") == 0) {
        -:10276:      // must be 0:No compression, 1: RLE, 2: ZIPs or 3: ZIP
        -:10277:      if (data[0] > 3) {
        -:10278:        if (err) {
        -:10279:          (*err) = "Unsupported compression type.";
        -:10280:        }
        -:10281:        return -5;
        -:10282:      }
        -:10283:
        -:10284:      compressionType = data[0];
        -:10285:
        -:10286:      if (compressionType == 3) { // ZIP
        -:10287:        numScanlineBlocks = 16;
        -:10288:      }
        -:10289:
        -:10290:    } else if (attrName.compare("channels") == 0) {
        -:10291:
        -:10292:      // name: zero-terminated string, from 1 to 255 bytes long
        -:10293:      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
        -:10294:      // pLinear: unsigned char, possible values are 0 and 1
        -:10295:      // reserved: three chars, should be zero
        -:10296:      // xSampling: int
        -:10297:      // ySampling: int
        -:10298:
        -:10299:      ReadChannelInfo(channels, data);
        -:10300:
        -:10301:      numChannels = channels.size();
        -:10302:
        -:10303:      if (numChannels < 1) {
        -:10304:        if (err) {
        -:10305:          (*err) = "Invalid channels format.";
        -:10306:        }
        -:10307:        return -6;
        -:10308:      }
        -:10309:
        -:10310:    } else if (attrName.compare("dataWindow") == 0) {
        -:10311:      memcpy(&dx, &data.at(0), sizeof(int));
        -:10312:      memcpy(&dy, &data.at(4), sizeof(int));
        -:10313:      memcpy(&dw, &data.at(8), sizeof(int));
        -:10314:      memcpy(&dh, &data.at(12), sizeof(int));
        -:10315:      if (IsBigEndian()) {
        -:10316:        swap4(reinterpret_cast<unsigned int *>(&dx));
        -:10317:        swap4(reinterpret_cast<unsigned int *>(&dy));
        -:10318:        swap4(reinterpret_cast<unsigned int *>(&dw));
        -:10319:        swap4(reinterpret_cast<unsigned int *>(&dh));
        -:10320:      }
        -:10321:
        -:10322:    } else if (attrName.compare("displayWindow") == 0) {
        -:10323:      int x;
        -:10324:      int y;
        -:10325:      int w;
        -:10326:      int h;
        -:10327:      memcpy(&x, &data.at(0), sizeof(int));
        -:10328:      memcpy(&y, &data.at(4), sizeof(int));
        -:10329:      memcpy(&w, &data.at(8), sizeof(int));
        -:10330:      memcpy(&h, &data.at(12), sizeof(int));
        -:10331:      if (IsBigEndian()) {
        -:10332:        swap4(reinterpret_cast<unsigned int *>(&x));
        -:10333:        swap4(reinterpret_cast<unsigned int *>(&y));
        -:10334:        swap4(reinterpret_cast<unsigned int *>(&w));
        -:10335:        swap4(reinterpret_cast<unsigned int *>(&h));
        -:10336:      }
        -:10337:    }
        -:10338:
        -:10339:    marker = marker_next;
        -:10340:  }
        -:10341:
        -:10342:  assert(dx >= 0);
        -:10343:  assert(dy >= 0);
        -:10344:  assert(dw >= 0);
        -:10345:  assert(dh >= 0);
        -:10346:  assert(numChannels >= 1);
        -:10347:
        -:10348:  int dataWidth = dw - dx + 1;
        -:10349:  int dataHeight = dh - dy + 1;
        -:10350:
        -:10351:  std::vector<float> image(dataWidth * dataHeight * 4); // 4 = RGBA
        -:10352:
        -:10353:  // Read offset tables.
        -:10354:  int numBlocks = dataHeight / numScanlineBlocks;
        -:10355:  if (numBlocks * numScanlineBlocks < dataHeight) {
        -:10356:    numBlocks++;
        -:10357:  }
        -:10358:
        -:10359:  std::vector<long long> offsets(numBlocks);
        -:10360:
        -:10361:  for (int y = 0; y < numBlocks; y++) {
        -:10362:    long long offset;
        -:10363:    memcpy(&offset, marker, sizeof(long long));
        -:10364:    if (IsBigEndian()) {
        -:10365:      swap8(reinterpret_cast<unsigned long long *>(&offset));
        -:10366:    }
        -:10367:    marker += sizeof(long long); // = 8
        -:10368:    offsets[y] = offset;
        -:10369:  }
        -:10370:
        -:10371:  if (compressionType != 0 && compressionType != 2 && compressionType != 3) {
        -:10372:    if (err) {
        -:10373:      (*err) = "Unsupported format.";
        -:10374:    }
        -:10375:    return -10;
        -:10376:  }
        -:10377:
        -:10378:  deepImage->image = (float ***)malloc(sizeof(float **) * numChannels);
        -:10379:  for (int c = 0; c < numChannels; c++) {
        -:10380:    deepImage->image[c] = (float **)malloc(sizeof(float *) * dataHeight);
        -:10381:    for (int y = 0; y < dataHeight; y++) {
        -:10382:    }
        -:10383:  }
        -:10384:
        -:10385:  deepImage->offset_table = (int **)malloc(sizeof(int *) * dataHeight);
        -:10386:  for (int y = 0; y < dataHeight; y++) {
        -:10387:    deepImage->offset_table[y] = (int *)malloc(sizeof(int) * dataWidth);
        -:10388:  }
        -:10389:
        -:10390:  for (int y = 0; y < numBlocks; y++) {
        -:10391:    const unsigned char *dataPtr =
        -:10392:        reinterpret_cast<const unsigned char *>(head + offsets[y]);
        -:10393:
        -:10394:    // int: y coordinate
        -:10395:    // int64: packed size of pixel offset table
        -:10396:    // int64: packed size of sample data
        -:10397:    // int64: unpacked size of sample data
        -:10398:    // compressed pixel offset table
        -:10399:    // compressed sample data
        -:10400:    int lineNo;
        -:10401:    long long packedOffsetTableSize;
        -:10402:    long long packedSampleDataSize;
        -:10403:    long long unpackedSampleDataSize;
        -:10404:    memcpy(&lineNo, dataPtr, sizeof(int));
        -:10405:    memcpy(&packedOffsetTableSize, dataPtr + 4, sizeof(long long));
        -:10406:    memcpy(&packedSampleDataSize, dataPtr + 12, sizeof(long long));
        -:10407:    memcpy(&unpackedSampleDataSize, dataPtr + 20, sizeof(long long));
        -:10408:
        -:10409:    if (IsBigEndian()) {
        -:10410:      swap4(reinterpret_cast<unsigned int *>(&lineNo));
        -:10411:      swap8(reinterpret_cast<unsigned long long *>(&packedOffsetTableSize));
        -:10412:      swap8(reinterpret_cast<unsigned long long *>(&packedSampleDataSize));
        -:10413:      swap8(reinterpret_cast<unsigned long long *>(&unpackedSampleDataSize));
        -:10414:    }
        -:10415:
        -:10416:    std::vector<int> pixelOffsetTable(dataWidth);
        -:10417:
        -:10418:    // decode pixel offset table.
        -:10419:    {
        -:10420:      unsigned long dstLen = pixelOffsetTable.size() * sizeof(int);
        -:10421:      DecompressZip(reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),
        -:10422:                    dstLen, dataPtr + 28, packedOffsetTableSize);
        -:10423:
        -:10424:      assert(dstLen == pixelOffsetTable.size() * sizeof(int));
        -:10425:      for (int i = 0; i < dataWidth; i++) {
        -:10426:        deepImage->offset_table[y][i] = pixelOffsetTable[i];
        -:10427:      }
        -:10428:    }
        -:10429:
        -:10430:    std::vector<unsigned char> sampleData(unpackedSampleDataSize);
        -:10431:
        -:10432:    // decode sample data.
        -:10433:    {
        -:10434:      unsigned long dstLen = unpackedSampleDataSize;
        -:10435:      DecompressZip(reinterpret_cast<unsigned char *>(&sampleData.at(0)),
        -:10436:                    dstLen, dataPtr + 28 + packedOffsetTableSize,
        -:10437:                    packedSampleDataSize);
        -:10438:      assert(dstLen == (unsigned long)unpackedSampleDataSize);
        -:10439:    }
        -:10440:
        -:10441:    // decode sample
        -:10442:    int sampleSize = -1;
        -:10443:    std::vector<int> channelOffsetList(numChannels);
        -:10444:    {
        -:10445:      int channelOffset = 0;
        -:10446:      for (int i = 0; i < numChannels; i++) {
        -:10447:        channelOffsetList[i] = channelOffset;
        -:10448:        if (channels[i].pixelType == TINYEXR_PIXELTYPE_UINT) { // UINT
        -:10449:          channelOffset += 4;
        -:10450:        } else if (channels[i].pixelType == TINYEXR_PIXELTYPE_HALF) { // half
        -:10451:          channelOffset += 2;
        -:10452:        } else if (channels[i].pixelType == TINYEXR_PIXELTYPE_FLOAT) { // float
        -:10453:          channelOffset += 4;
        -:10454:        } else {
        -:10455:          assert(0);
        -:10456:        }
        -:10457:      }
        -:10458:      sampleSize = channelOffset;
        -:10459:    }
        -:10460:    assert(sampleSize >= 2);
        -:10461:
        -:10462:    assert((size_t)(pixelOffsetTable[dataWidth - 1] * sampleSize) == sampleData.size());
        -:10463:    int samplesPerLine = sampleData.size() / sampleSize;
        -:10464:
        -:10465:    //
        -:10466:    // Alloc memory
        -:10467:    //
        -:10468:
        -:10469:    //
        -:10470:    // pixel data is stored as image[channels][pixel_samples]
        -:10471:    //
        -:10472:    {
        -:10473:      unsigned long long dataOffset = 0;
        -:10474:      for (int c = 0; c < numChannels; c++) {
        -:10475:
        -:10476:        deepImage->image[c][y] =
        -:10477:            (float *)malloc(sizeof(float) * samplesPerLine);
        -:10478:
        -:10479:        if (channels[c].pixelType == 0) { // UINT
        -:10480:          for (int x = 0; x < samplesPerLine; x++) {
        -:10481:            unsigned int ui = *reinterpret_cast<unsigned int *>(
        -:10482:                                  &sampleData.at(dataOffset + x * sizeof(int)));
        -:10483:            deepImage->image[c][y][x] = (float)ui; // @fixme
        -:10484:          }
        -:10485:          dataOffset += sizeof(unsigned int) * samplesPerLine;
        -:10486:        } else if (channels[c].pixelType == 1) { // half
        -:10487:          for (int x = 0; x < samplesPerLine; x++) {
        -:10488:            FP16 f16;
        -:10489:            f16.u = *reinterpret_cast<unsigned short *>(
        -:10490:                        &sampleData.at(dataOffset + x * sizeof(short)));
        -:10491:            FP32 f32 = half_to_float(f16);
        -:10492:            deepImage->image[c][y][x] = f32.f;
        -:10493:          }
        -:10494:          dataOffset += sizeof(short) * samplesPerLine;
        -:10495:        } else { // float
        -:10496:          for (int x = 0; x < samplesPerLine; x++) {
        -:10497:            float f = *reinterpret_cast<float *>(
        -:10498:                          &sampleData.at(dataOffset + x * sizeof(float)));
        -:10499:            deepImage->image[c][y][x] = f;
        -:10500:          }
        -:10501:          dataOffset += sizeof(float) * samplesPerLine;
        -:10502:        }
        -:10503:      }
        -:10504:    }
        -:10505:
        -:10506:  } // y
        -:10507:
        -:10508:  deepImage->width = dataWidth;
        -:10509:  deepImage->height = dataHeight;
        -:10510:
        -:10511:  deepImage->channel_names =
        -:10512:      (const char **)malloc(sizeof(const char *) * numChannels);
        -:10513:  for (int c = 0; c < numChannels; c++) {
        -:10514:#ifdef _WIN32
        -:10515:    deepImage->channel_names[c] = _strdup(channels[c].name.c_str());
        -:10516:#else
        -:10517:    deepImage->channel_names[c] = strdup(channels[c].name.c_str());
        -:10518:#endif
        -:10519:  }
        -:10520:  deepImage->num_channels = numChannels;
        -:10521:
        -:10522:  return 0; // OK
        -:10523:}
        -:10524:
        -:10525:inline int SaveDeepEXR(const DeepImage *deepImage, const char *filename,
        -:10526:                const char **err) {
        -:10527:  if (deepImage == NULL || filename == NULL) {
        -:10528:    if (err) {
        -:10529:      (*err) = "Invalid argument.";
        -:10530:    }
        -:10531:    return -1;
        -:10532:  }
        -:10533:
        -:10534:  FILE *fp = fopen(filename, "rb");
        -:10535:  if (!fp) {
        -:10536:    if (err) {
        -:10537:      (*err) = "Cannot write file.";
        -:10538:    }
        -:10539:    return -1;
        -:10540:  }
        -:10541:
        -:10542:  // Write header check.
        -:10543:  {
        -:10544:    const char header[] = {0x76, 0x2f, 0x31, 0x01};
        -:10545:    size_t n = fwrite(header, 1, 4, fp);
        -:10546:    if (n != 4) {
        -:10547:      if (err) {
        -:10548:        (*err) = "Header write failed.";
        -:10549:      }
        -:10550:      fclose(fp);
        -:10551:      return -3;
        -:10552:    }
        -:10553:  }
        -:10554:
        -:10555:  // Version, scanline.
        -:10556:  {
        -:10557:    // ver 2.0, scanline, deep bit on(0x800)
        -:10558:    const char data[] = {2, 8, 0, 0};
        -:10559:    size_t n = fwrite(data, 1, 4, fp);
        -:10560:    if (n != 4) {
        -:10561:      if (err) {
        -:10562:        (*err) = "Flag write failed.";
        -:10563:      }
        -:10564:      fclose(fp);
        -:10565:      return -3;
        -:10566:    }
        -:10567:  }
        -:10568:
        -:10569:  // Write attributes.
        -:10570:  {
        -:10571:    int data = 2; // ZIPS
        -:10572:    WriteAttribute(fp, "compression", "compression",
        -:10573:                   reinterpret_cast<const unsigned char *>(&data), sizeof(int));
        -:10574:  }
        -:10575:
        -:10576:  {
        -:10577:    int data[4] = {0, 0, deepImage->width - 1, deepImage->height - 1};
        -:10578:    WriteAttribute(fp, "dataWindow", "box2i",
        -:10579:                   reinterpret_cast<const unsigned char *>(data),
        -:10580:                   sizeof(int) * 4);
        -:10581:    WriteAttribute(fp, "displayWindow", "box2i",
        -:10582:                   reinterpret_cast<const unsigned char *>(data),
        -:10583:                   sizeof(int) * 4);
        -:10584:  }
        -:10585:
        -:10586:  int numScanlineBlocks = 1;
        -:10587:  // Write offset tables.
        -:10588:  int numBlocks = deepImage->height / numScanlineBlocks;
        -:10589:  if (numBlocks * numScanlineBlocks < deepImage->height) {
        -:10590:    numBlocks++;
        -:10591:  }
        -:10592:
        -:10593:#if 0 // @todo
        -:10594:  std::vector<long long> offsets(numBlocks);
        -:10595:
        -:10596:  //std::vector<int> pixelOffsetTable(dataWidth);
        -:10597:
        -:10598:  // compress pixel offset table.
        -:10599:  {
        -:10600:      unsigned long dstLen = pixelOffsetTable.size() * sizeof(int);
        -:10601:      Compresses(reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),
        -:10602:                    dstLen, dataPtr + 28, packedOffsetTableSize);
        -:10603:
        -:10604:      assert(dstLen == pixelOffsetTable.size() * sizeof(int));
        -:10605:      //      int ret =
        -:10606:      //          miniz::mz_uncompress(reinterpret_cast<unsigned char
        -:10607:      //          *>(&pixelOffsetTable.at(0)), &dstLen, dataPtr + 28,
        -:10608:      //          packedOffsetTableSize);
        -:10609:      //      printf("ret = %d, dstLen = %d\n", ret, (int)dstLen);
        -:10610:      //
        -:10611:      for (int i = 0; i < dataWidth; i++) {
        -:10612:        // printf("offt[%d] = %d\n", i, pixelOffsetTable[i]);
        -:10613:        deepImage->offset_table[y][i] = pixelOffsetTable[i];
        -:10614:      }
        -:10615:    }
        -:10616:
        -:10617:
        -:10618:  for (int y = 0; y < numBlocks; y++) {
        -:10619:    //long long offset = *(reinterpret_cast<const long long *>(marker));
        -:10620:    // printf("offset[%d] = %lld\n", y, offset);
        -:10621:    //marker += sizeof(long long); // = 8
        -:10622:    offsets[y] = offset;
        -:10623:  }
        -:10624:
        -:10625:  // Write offset table.
        -:10626:  fwrite(&offsets.at(0), sizeof(long long), numBlocks, fp);
        -:10627:
        -:10628:  for (int y = 0; y < numBlocks; y++) {
        -:10629:    const unsigned char *dataPtr =
        -:10630:        reinterpret_cast<const unsigned char *>(head + offsets[y]);
        -:10631:
        -:10632:    // int: y coordinate
        -:10633:    // int64: packed size of pixel offset table
        -:10634:    // int64: packed size of sample data
        -:10635:    // int64: unpacked size of sample data
        -:10636:    // compressed pixel offset table
        -:10637:    // compressed sample data
        -:10638:    int lineNo = *reinterpret_cast<const int *>(dataPtr);
        -:10639:    long long packedOffsetTableSize =
        -:10640:        *reinterpret_cast<const long long *>(dataPtr + 4);
        -:10641:    long long packedSampleDataSize =
        -:10642:        *reinterpret_cast<const long long *>(dataPtr + 12);
        -:10643:    long long unpackedSampleDataSize =
        -:10644:        *reinterpret_cast<const long long *>(dataPtr + 20);
        -:10645:    // printf("line: %d, %lld/%lld/%lld\n", lineNo, packedOffsetTableSize,
        -:10646:    // packedSampleDataSize, unpackedSampleDataSize);
        -:10647:
        -:10648:    int endLineNo = (std::min)(lineNo + numScanlineBlocks, dataHeight);
        -:10649:
        -:10650:    int numLines = endLineNo - lineNo;
        -:10651:    // printf("numLines: %d\n", numLines);
        -:10652:
        -:10653:    std::vector<int> pixelOffsetTable(dataWidth);
        -:10654:
        -:10655:    // decode pixel offset table.
        -:10656:    {
        -:10657:      unsigned long dstLen = pixelOffsetTable.size() * sizeof(int);
        -:10658:      DecompressZip(reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),
        -:10659:                    dstLen, dataPtr + 28, packedOffsetTableSize);
        -:10660:
        -:10661:      assert(dstLen == pixelOffsetTable.size() * sizeof(int));
        -:10662:      //      int ret =
        -:10663:      //          miniz::mz_uncompress(reinterpret_cast<unsigned char
        -:10664:      //          *>(&pixelOffsetTable.at(0)), &dstLen, dataPtr + 28,
        -:10665:      //          packedOffsetTableSize);
        -:10666:      //      printf("ret = %d, dstLen = %d\n", ret, (int)dstLen);
        -:10667:      //
        -:10668:      for (int i = 0; i < dataWidth; i++) {
        -:10669:        // printf("offt[%d] = %d\n", i, pixelOffsetTable[i]);
        -:10670:        deepImage->offset_table[y][i] = pixelOffsetTable[i];
        -:10671:      }
        -:10672:    }
        -:10673:
        -:10674:    std::vector<unsigned char> sampleData(unpackedSampleDataSize);
        -:10675:
        -:10676:    // decode sample data.
        -:10677:    {
        -:10678:      unsigned long dstLen = unpackedSampleDataSize;
        -:10679:      // printf("dstLen = %d\n", dstLen);
        -:10680:      // printf("srcLen = %d\n", packedSampleDataSize);
        -:10681:      DecompressZip(reinterpret_cast<unsigned char *>(&sampleData.at(0)),
        -:10682:                    dstLen, dataPtr + 28 + packedOffsetTableSize,
        -:10683:                    packedSampleDataSize);
        -:10684:      assert(dstLen == unpackedSampleDataSize);
        -:10685:    }
        -:10686:
        -:10687:    // decode sample
        -:10688:    int sampleSize = -1;
        -:10689:    std::vector<int> channelOffsetList(numChannels);
        -:10690:    {
        -:10691:      int channelOffset = 0;
        -:10692:      for (int i = 0; i < numChannels; i++) {
        -:10693:        // printf("offt[%d] = %d\n", i, channelOffset);
        -:10694:        channelOffsetList[i] = channelOffset;
        -:10695:        if (channels[i].pixelType == 0) { // UINT
        -:10696:          channelOffset += 4;
        -:10697:        } else if (channels[i].pixelType == 1) { // half
        -:10698:          channelOffset += 2;
        -:10699:        } else if (channels[i].pixelType == 2) { // float
        -:10700:          channelOffset += 4;
        -:10701:        } else {
        -:10702:          assert(0);
        -:10703:        }
        -:10704:      }
        -:10705:      sampleSize = channelOffset;
        -:10706:    }
        -:10707:    assert(sampleSize >= 2);
        -:10708:
        -:10709:    assert(pixelOffsetTable[dataWidth - 1] * sampleSize == sampleData.size());
        -:10710:    int samplesPerLine = sampleData.size() / sampleSize;
        -:10711:
        -:10712:    //
        -:10713:    // Alloc memory
        -:10714:    //
        -:10715:
        -:10716:    //
        -:10717:    // pixel data is stored as image[channels][pixel_samples]
        -:10718:    //
        -:10719:    {
        -:10720:      unsigned long long dataOffset = 0;
        -:10721:      for (int c = 0; c < numChannels; c++) {
        -:10722:
        -:10723:        deepImage->image[c][y] =
        -:10724:            (float *)malloc(sizeof(float) * samplesPerLine);
        -:10725:
        -:10726:        // unsigned int channelOffset = channelOffsetList[c];
        -:10727:        // unsigned int i = channelOffset;
        -:10728:        // printf("channel = %d. name = %s. ty = %d\n", c,
        -:10729:        // channels[c].name.c_str(), channels[c].pixelType);
        -:10730:
        -:10731:        // printf("dataOffset = %d\n", (int)dataOffset);
        -:10732:
        -:10733:        if (channels[c].pixelType == 0) { // UINT
        -:10734:          for (int x = 0; x < samplesPerLine; x++) {
        -:10735:            unsigned int ui = *reinterpret_cast<unsigned int *>(
        -:10736:                                  &sampleData.at(dataOffset + x * sizeof(int)));
        -:10737:            deepImage->image[c][y][x] = (float)ui; // @fixme
        -:10738:          }
        -:10739:          dataOffset += sizeof(unsigned int) * samplesPerLine;
        -:10740:        } else if (channels[c].pixelType == 1) { // half
        -:10741:          for (int x = 0; x < samplesPerLine; x++) {
        -:10742:            FP16 f16;
        -:10743:            f16.u = *reinterpret_cast<unsigned short *>(
        -:10744:                        &sampleData.at(dataOffset + x * sizeof(short)));
        -:10745:            FP32 f32 = half_to_float(f16);
        -:10746:            deepImage->image[c][y][x] = f32.f;
        -:10747:            // printf("c[%d]  f(half) = %f (0x%08x)\n", c, f32.f, f16.u);
        -:10748:          }
        -:10749:          dataOffset += sizeof(short) * samplesPerLine;
        -:10750:        } else { // float
        -:10751:          for (int x = 0; x < samplesPerLine; x++) {
        -:10752:            float f = *reinterpret_cast<float *>(
        -:10753:                          &sampleData.at(dataOffset + x * sizeof(float)));
        -:10754:            // printf("  f = %f(0x%08x)\n", f, *((unsigned int *)&f));
        -:10755:            deepImage->image[c][y][x] = f;
        -:10756:          }
        -:10757:          dataOffset += sizeof(float) * samplesPerLine;
        -:10758:        }
        -:10759:      }
        -:10760:      // printf("total: %d\n", dataOffset);
        -:10761:    }
        -:10762:
        -:10763:  } // y
        -:10764:#endif
        -:10765:  fclose(fp);
        -:10766:
        -:10767:  return 0; // OK
        -:10768:}
        -:10769:
    #####:10770:void InitEXRImage(EXRImage *exrImage) {
    #####:10771:  if (exrImage == NULL) {
        -:10772:    return;
        -:10773:  }
        -:10774:
    #####:10775:  exrImage->num_custom_attributes = 0;
    #####:10776:  exrImage->num_channels = 0;
    #####:10777:  exrImage->channel_names = NULL;
    #####:10778:  exrImage->images = NULL;
    #####:10779:  exrImage->pixel_types = NULL;
    #####:10780:  exrImage->requested_pixel_types = NULL;
    %%%%%:10780-block  0
    %%%%%:10780-block  1
        -:10781:}
        -:10782:
    #####:10783:int FreeEXRImage(EXRImage *exrImage) {
        -:10784:
    #####:10785:  if (exrImage == NULL) {
    %%%%%:10785-block  0
        -:10786:    return -1; // Err
        -:10787:  }
        -:10788:
    #####:10789:  for (int i = 0; i < exrImage->num_channels; i++) {
    %%%%%:10789-block  0
    %%%%%:10789-block  1
        -:10790:
    #####:10791:    if (exrImage->channel_names && exrImage->channel_names[i]) {
    %%%%%:10791-block  0
    %%%%%:10791-block  1
    #####:10792:      free((char *)exrImage->channel_names[i]); // remove const
    %%%%%:10792-block  0
        -:10793:    }
        -:10794:
    #####:10795:    if (exrImage->images && exrImage->images[i]) {
    %%%%%:10795-block  0
    %%%%%:10795-block  1
    #####:10796:      free(exrImage->images[i]);
    %%%%%:10796-block  0
        -:10797:    }
        -:10798:  }
        -:10799:
    #####:10800:  if (exrImage->channel_names) {
    %%%%%:10800-block  0
    #####:10801:    free(exrImage->channel_names);
    %%%%%:10801-block  0
        -:10802:  }
        -:10803:
    #####:10804:  if (exrImage->images) {
    %%%%%:10804-block  0
    #####:10805:    free(exrImage->images);
    %%%%%:10805-block  0
        -:10806:  }
        -:10807:
    #####:10808:  if (exrImage->pixel_types) {
    %%%%%:10808-block  0
    #####:10809:    free(exrImage->pixel_types);
    %%%%%:10809-block  0
        -:10810:  }
        -:10811:
    #####:10812:  if (exrImage->requested_pixel_types) {
    %%%%%:10812-block  0
    #####:10813:    free(exrImage->requested_pixel_types);
    %%%%%:10813-block  0
        -:10814:  }
        -:10815:
    #####:10816:  for (int i = 0; i < exrImage->num_custom_attributes; i++) {
    %%%%%:10816-block  0
    %%%%%:10816-block  1
    #####:10817:    if (exrImage->custom_attributes[i].name) {
    %%%%%:10817-block  0
    #####:10818:      free(exrImage->custom_attributes[i].name);
    %%%%%:10818-block  0
        -:10819:    }
    #####:10820:    if (exrImage->custom_attributes[i].type) {
    %%%%%:10820-block  0
    #####:10821:      free(exrImage->custom_attributes[i].type);
    %%%%%:10821-block  0
        -:10822:    }
    #####:10823:    if (exrImage->custom_attributes[i].value) {
    %%%%%:10823-block  0
    #####:10824:      free(exrImage->custom_attributes[i].value);
    %%%%%:10824-block  0
        -:10825:    }
        -:10826:  }
        -:10827:
        -:10828:  return 0;
        -:10829:}
        -:10830:
    #####:10831:inline int ParseMultiChannelEXRHeaderFromFile(EXRImage *exrImage, const char *filename,
        -:10832:                                       const char **err) {
    #####:10833:  if (exrImage == NULL) {
    %%%%%:10833-block  0
    #####:10834:    if (err) {
    %%%%%:10834-block  0
    #####:10835:      (*err) = "Invalid argument.";
    %%%%%:10835-block  0
        -:10836:    }
    #####:10837:    return -1;
    %%%%%:10837-block  0
        -:10838:  }
        -:10839:
    #####:10840:  FILE *fp = fopen(filename, "rb");
    %%%%%:10840-block  0
    #####:10841:  if (!fp) {
    #####:10842:    if (err) {
    %%%%%:10842-block  0
    #####:10843:      (*err) = "Cannot read file.";
    %%%%%:10843-block  0
        -:10844:    }
    #####:10845:    return -1;
    %%%%%:10845-block  0
        -:10846:  }
        -:10847:
    #####:10848:  size_t filesize;
        -:10849:  // Compute size
    #####:10850:  fseek(fp, 0, SEEK_END);
    %%%%%:10850-block  0
    #####:10851:  filesize = ftell(fp);
    #####:10852:  fseek(fp, 0, SEEK_SET);
        -:10853:
    #####:10854:  std::vector<unsigned char> buf(filesize); // @todo { use mmap }
    %%%%%:10854-block  0
    #####:10855:  {
    #####:10856:    size_t ret;
    #####:10857:    ret = fread(&buf[0], 1, filesize, fp);
    #####:10858:    assert(ret == filesize);
    %%%%%:10858-block  0
    %%%%%:10858-block  1
    #####:10859:    fclose(fp);
    %%%%%:10859-block  0
    #####:10860:    (void)ret;
        -:10861:  }
        -:10862:
    #####:10863:  return ParseMultiChannelEXRHeaderFromMemory(exrImage, &buf.at(0), err);
    %%%%%:10863-block  0
    %%%%%:10863-block  1
    %%%%%:10863-block  2
        -:10864:}
        -:10865:
    #####:10866:int ParseMultiChannelEXRHeaderFromMemory(EXRImage *exrImage,
        -:10867:                                         const unsigned char *memory,
        -:10868:                                         const char **err) {
    #####:10869:  if (exrImage == NULL || memory == NULL) {
    %%%%%:10869-block  0
    #####:10870:    if (err) {
    %%%%%:10870-block  0
    #####:10871:      (*err) = "Invalid argument.";
    %%%%%:10871-block  0
        -:10872:    }
    #####:10873:    return -1;
    %%%%%:10873-block  0
        -:10874:  }
        -:10875:
    #####:10876:  const char *buf = reinterpret_cast<const char *>(memory);
        -:10877:
    #####:10878:  const char *marker = &buf[0];
        -:10879:
        -:10880:  // Header check.
    #####:10881:  {
    #####:10882:    const char header[] = {0x76, 0x2f, 0x31, 0x01};
        -:10883:
    #####:10884:    if (memcmp(marker, header, 4) != 0) {
    %%%%%:10884-block  0
    #####:10885:      if (err) {
    %%%%%:10885-block  0
    #####:10886:        (*err) = "Header mismatch.";
    %%%%%:10886-block  0
        -:10887:      }
    #####:10888:      return -3;
    %%%%%:10888-block  0
        -:10889:    }
    #####:10890:    marker += 4;
        -:10891:  }
        -:10892:
        -:10893:  // Version, scanline.
    #####:10894:  {
        -:10895:    // must be [2, 0, 0, 0]
    #####:10896:    if (marker[0] != 2 || marker[1] != 0 || marker[2] != 0 || marker[3] != 0) {
    %%%%%:10896-block  0
    %%%%%:10896-block  1
    %%%%%:10896-block  2
    %%%%%:10896-block  3
    #####:10897:      if (err) {
    %%%%%:10897-block  0
    #####:10898:        (*err) = "Unsupported version or scanline.";
    %%%%%:10898-block  0
        -:10899:      }
    #####:10900:      return -4;
    %%%%%:10900-block  0
        -:10901:    }
        -:10902:
    #####:10903:    marker += 4;
        -:10904:  }
        -:10905:
    #####:10906:  int dx = -1;
    #####:10907:  int dy = -1;
    #####:10908:  int dw = -1;
    #####:10909:  int dh = -1;
    #####:10910:  int numChannels = -1;
    #####:10911:  int displayWindow[4] = {-1, -1, -1, -1}; // @fixme.
    #####:10912:  float screenWindowCenter[2] = {0.0f, 0.0f}; // @fixme
    #####:10913:  float screenWindowWidth = 1.0f; // @fixme
    #####:10914:  float pixelAspectRatio = 1.0f;
    #####:10915:  unsigned char lineOrder = 0; // 0 -> increasing y; 1 -> decreasing
    #####:10916:  std::vector<ChannelInfo> channels;
    %%%%%:10916-block  0
    $$$$$:10916-block  1
        -:10917:
    #####:10918:  int numCustomAttributes = 0;
    #####:10919:  std::vector<EXRAttribute> customAttribs;
    %%%%%:10919-block  0
    %%%%%:10919-block  1
    $$$$$:10919-block  2
        -:10920:
        -:10921:  // Read attributes
    #####:10922:  for (;;) {
    #####:10923:    std::string attrName;
    %%%%%:10923-block  0
    %%%%%:10923-block  1
    $$$$$:10923-block  2
    #####:10924:    std::string attrType;
    %%%%%:10924-block  0
    $$$$$:10924-block  1
    #####:10925:    std::vector<unsigned char> data;
    %%%%%:10925-block  0
    %%%%%:10925-block  1
    $$$$$:10925-block  2
    #####:10926:    const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
    %%%%%:10926-block  0
    #####:10927:    if (marker_next == NULL) {
    %%%%%:10927-block  0
    #####:10928:      marker++; // skip '\0'
    #####:10929:      break;
    %%%%%:10929-block  0
    %%%%%:10929-block  1
        -:10930:    }
        -:10931:
    #####:10932:    if (attrName.compare("compression") == 0) {
    %%%%%:10932-block  0
        -:10933:      // must be 0:No compression, 1: RLE, 2: ZIPs, 3: ZIP or 4: PIZ
    #####:10934:      if (data[0] > 4) {
    %%%%%:10934-block  0
    #####:10935:        if (err) {
    %%%%%:10935-block  0
    #####:10936:          (*err) = "Unsupported compression type.";
    %%%%%:10936-block  0
        -:10937:        }
    #####:10938:        return -5;
    %%%%%:10938-block  0
    %%%%%:10938-block  1
        -:10939:      }
        -:10940:
    #####:10941:    } else if (attrName.compare("channels") == 0) {
    %%%%%:10941-block  0
        -:10942:
        -:10943:      // name: zero-terminated string, from 1 to 255 bytes long
        -:10944:      // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
        -:10945:      // pLinear: unsigned char, possible values are 0 and 1
        -:10946:      // reserved: three chars, should be zero
        -:10947:      // xSampling: int
        -:10948:      // ySampling: int
        -:10949:
    #####:10950:      ReadChannelInfo(channels, data);
    %%%%%:10950-block  0
        -:10951:
    #####:10952:      numChannels = channels.size();
    %%%%%:10952-block  0
        -:10953:
    #####:10954:      if (numChannels < 1) {
    %%%%%:10954-block  0
    #####:10955:        if (err) {
    %%%%%:10955-block  0
    #####:10956:          (*err) = "Invalid channels format.";
    %%%%%:10956-block  0
        -:10957:        }
    #####:10958:        return -6;
    %%%%%:10958-block  0
        -:10959:      }
        -:10960:
    #####:10961:    } else if (attrName.compare("dataWindow") == 0) {
    %%%%%:10961-block  0
    #####:10962:      memcpy(&dx, &data.at(0), sizeof(int));
    %%%%%:10962-block  0
    %%%%%:10962-block  1
    #####:10963:      memcpy(&dy, &data.at(4), sizeof(int));
    %%%%%:10963-block  0
    %%%%%:10963-block  1
    #####:10964:      memcpy(&dw, &data.at(8), sizeof(int));
    %%%%%:10964-block  0
    %%%%%:10964-block  1
    #####:10965:      memcpy(&dh, &data.at(12), sizeof(int));
    %%%%%:10965-block  0
    %%%%%:10965-block  1
    #####:10966:      if (IsBigEndian()) {
    %%%%%:10966-block  0
        -:10967:        swap4(reinterpret_cast<unsigned int *>(&dx));
        -:10968:        swap4(reinterpret_cast<unsigned int *>(&dy));
        -:10969:        swap4(reinterpret_cast<unsigned int *>(&dw));
    #####:10970:        swap4(reinterpret_cast<unsigned int *>(&dh));
        -:10971:      }
    #####:10972:    } else if (attrName.compare("displayWindow") == 0) {
    %%%%%:10972-block  0
    #####:10973:      memcpy(&displayWindow[0], &data.at(0), sizeof(int));
    %%%%%:10973-block  0
    %%%%%:10973-block  1
    #####:10974:      memcpy(&displayWindow[1], &data.at(4), sizeof(int));
    %%%%%:10974-block  0
    %%%%%:10974-block  1
    #####:10975:      memcpy(&displayWindow[2], &data.at(8), sizeof(int));
    %%%%%:10975-block  0
    %%%%%:10975-block  1
    #####:10976:      memcpy(&displayWindow[3], &data.at(12), sizeof(int));
    %%%%%:10976-block  0
    %%%%%:10976-block  1
    #####:10977:      if (IsBigEndian()) {
    %%%%%:10977-block  0
        -:10978:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[0]));
        -:10979:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[1]));
        -:10980:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[2]));
    #####:10981:        swap4(reinterpret_cast<unsigned int *>(&displayWindow[3]));
        -:10982:      }
    #####:10983:    } else if (attrName.compare("lineOrder") == 0) {
    %%%%%:10983-block  0
    #####:10984:      memcpy(&lineOrder, &data.at(0), sizeof(lineOrder));
    %%%%%:10984-block  0
    %%%%%:10984-block  1
    #####:10985:      if (IsBigEndian()) {
    %%%%%:10985-block  0
    #####:10986:        swap4(reinterpret_cast<unsigned int *>(&lineOrder));
        -:10987:      }
    #####:10988:    } else if (attrName.compare("pixelAspectRatio") == 0) {
    %%%%%:10988-block  0
    #####:10989:      memcpy(&pixelAspectRatio, &data.at(0), sizeof(float));
    %%%%%:10989-block  0
    %%%%%:10989-block  1
    #####:10990:      if (IsBigEndian()) {
    %%%%%:10990-block  0
    #####:10991:        swap4(reinterpret_cast<unsigned int *>(&pixelAspectRatio));
        -:10992:      }
    #####:10993:    } else if (attrName.compare("screenWindowCenter") == 0) {
    %%%%%:10993-block  0
    #####:10994:      memcpy(&screenWindowCenter[0], &data.at(0), sizeof(float));
    %%%%%:10994-block  0
    %%%%%:10994-block  1
    #####:10995:      memcpy(&screenWindowCenter[1], &data.at(4), sizeof(float));
    %%%%%:10995-block  0
    %%%%%:10995-block  1
    #####:10996:      if (IsBigEndian()) {
    %%%%%:10996-block  0
        -:10997:        swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[0]));
    #####:10998:        swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[1]));
        -:10999:      }
    #####:11000:    } else if (attrName.compare("screenWindowWidth") == 0) {
    %%%%%:11000-block  0
    #####:11001:      memcpy(&screenWindowWidth, &data.at(0), sizeof(float));
    %%%%%:11001-block  0
    %%%%%:11001-block  1
    #####:11002:      if (IsBigEndian()) {
    %%%%%:11002-block  0
    #####:11003:        swap4(reinterpret_cast<unsigned int *>(&screenWindowWidth));
        -:11004:      }
        -:11005:    } else {
        -:11006:      // Custom attribute(up to TINYEXR_MAX_ATTRIBUTES)
    #####:11007:      if (numCustomAttributes < TINYEXR_MAX_ATTRIBUTES) {
    #####:11008:        EXRAttribute attrib;
    #####:11009:        attrib.name = strdup(attrName.c_str());
    %%%%%:11009-block  0
    #####:11010:        attrib.type = strdup(attrType.c_str());
    #####:11011:        attrib.size = data.size();
    %%%%%:11011-block  0
    #####:11012:        attrib.value = (unsigned char*)malloc(data.size());
    #####:11013:        memcpy((char*)attrib.value, &data.at(0), data.size());
    %%%%%:11013-block  0
    %%%%%:11013-block  1
    #####:11014:        customAttribs.push_back(attrib);
    %%%%%:11014-block  0
        -:11015:      }
        -:11016:    }
        -:11017:
    #####:11018:    marker = marker_next;
    %%%%%:11018-block  0
        -:11019:  }
        -:11020:
    #####:11021:  assert(dx >= 0);
    %%%%%:11021-block  0
    %%%%%:11021-block  1
    #####:11022:  assert(dy >= 0);
    %%%%%:11022-block  0
    %%%%%:11022-block  1
    #####:11023:  assert(dw >= 0);
    %%%%%:11023-block  0
    %%%%%:11023-block  1
    #####:11024:  assert(dh >= 0);
    %%%%%:11024-block  0
    %%%%%:11024-block  1
    #####:11025:  assert(numChannels >= 1);
    %%%%%:11025-block  0
    %%%%%:11025-block  1
        -:11026:
    #####:11027:  int dataWidth = dw - dx + 1;
    #####:11028:  int dataHeight = dh - dy + 1;
        -:11029:
    #####:11030:  {
    #####:11031:    exrImage->channel_names =
    #####:11032:        (const char **)malloc(sizeof(const char *) * numChannels);
    #####:11033:    for (int c = 0; c < numChannels; c++) {
    %%%%%:11033-block  0
    %%%%%:11033-block  1
    %%%%%:11033-block  2
        -:11034:#ifdef _WIN32
        -:11035:      exrImage->channel_names[c] = _strdup(channels[c].name.c_str());
        -:11036:#else
    #####:11037:      exrImage->channel_names[c] = strdup(channels[c].name.c_str());
    %%%%%:11037-block  0
        -:11038:#endif
        -:11039:    }
    #####:11040:    exrImage->num_channels = numChannels;
        -:11041:
    #####:11042:    exrImage->width = dataWidth;
    #####:11043:    exrImage->height = dataHeight;
    #####:11044:    exrImage->pixel_aspect_ratio = pixelAspectRatio;
    #####:11045:    exrImage->screen_window_center[0] = screenWindowCenter[0];
    #####:11046:    exrImage->screen_window_center[1] = screenWindowCenter[1];
    #####:11047:    exrImage->screen_window_width = screenWindowWidth;
    #####:11048:    exrImage->display_window[0] = displayWindow[0];
    #####:11049:    exrImage->display_window[1] = displayWindow[1];
    #####:11050:    exrImage->display_window[2] = displayWindow[2];
    #####:11051:    exrImage->display_window[3] = displayWindow[3];
    #####:11052:    exrImage->data_window[0] = dx;
    #####:11053:    exrImage->data_window[1] = dy;
    #####:11054:    exrImage->data_window[2] = dw;
    #####:11055:    exrImage->data_window[3] = dh;
    #####:11056:    exrImage->line_order = lineOrder;
        -:11057:
    #####:11058:    exrImage->pixel_types = (int *)malloc(sizeof(int) * numChannels);
    #####:11059:    for (int c = 0; c < numChannels; c++) {
    %%%%%:11059-block  0
    %%%%%:11059-block  1
    %%%%%:11059-block  2
    #####:11060:      exrImage->pixel_types[c] = channels[c].pixelType;
    %%%%%:11060-block  0
        -:11061:    }
        -:11062:
        -:11063:    // Initially fill with values of `pixel-types`
    #####:11064:    exrImage->requested_pixel_types = (int *)malloc(sizeof(int) * numChannels);
    #####:11065:    for (int c = 0; c < numChannels; c++) {
    %%%%%:11065-block  0
    %%%%%:11065-block  1
    %%%%%:11065-block  2
    #####:11066:      exrImage->requested_pixel_types[c] = channels[c].pixelType;
    %%%%%:11066-block  0
        -:11067:    }
        -:11068:  }
        -:11069:
        -:11070:  if (numCustomAttributes > 0) {
        -:11071:    assert(customAttribs.size() < TINYEXR_MAX_ATTRIBUTES);
        -:11072:    exrImage->num_custom_attributes = numCustomAttributes;
        -:11073:
        -:11074:    for (int i = 0; i < (int)customAttribs.size(); i++) {
        -:11075:      exrImage->custom_attributes[i] = customAttribs[i];
        -:11076:    }
        -:11077:  } 
        -:11078:
        -:11079:  return 0; // OK
        -:11080:}
        -:11081:
        -:11082:#endif
        -:11083:
        -:11084:#endif // __TINYEXR_H__

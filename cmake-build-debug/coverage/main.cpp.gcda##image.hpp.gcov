        -:    0:Source:/home/edd993/CLionProjects/hdr_generator/include/image.hpp
        -:    0:Graph:/home/edd993/CLionProjects/hdr_generator/cmake-build-debug/CMakeFiles/hdr_generator.dir/main.cpp.gcno
        -:    0:Data:/home/edd993/CLionProjects/hdr_generator/cmake-build-debug/CMakeFiles/hdr_generator.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2:
        -:    3:PICCANTE
        -:    4:The hottest HDR imaging library!
        -:    5:http://vcg.isti.cnr.it/piccante
        -:    6:
        -:    7:Copyright (C) 2014
        -:    8:Visual Computing Laboratory - ISTI CNR
        -:    9:http://vcg.isti.cnr.it
        -:   10:First author: Francesco Banterle
        -:   11:
        -:   12:This Source Code Form is subject to the terms of the Mozilla Public
        -:   13:License, v. 2.0. If a copy of the MPL was not distributed with this
        -:   14:file, You can obtain one at http://mozilla.org/MPL/2.0/.
        -:   15:
        -:   16:*/
        -:   17:
        -:   18:#ifndef PIC_IMAGE_HPP
        -:   19:#define PIC_IMAGE_HPP
        -:   20:
        -:   21:#include <string>
        -:   22:#include <vector>
        -:   23:#include <algorithm>
        -:   24:#include <random>
        -:   25:#include <math.h>
        -:   26:#include <float.h>
        -:   27:#include <limits>
        -:   28:#include <string>
        -:   29:
        -:   30:#include "base.hpp"
        -:   31:#include "util/compability.hpp"
        -:   32:#include "util/bbox.hpp"
        -:   33:#include "util/buffer.hpp"
        -:   34:#include "util/dynamic_range.hpp"
        -:   35:#include "util/math.hpp"
        -:   36:#include "util/array.hpp"
        -:   37:#include "util/indexed_array.hpp"
        -:   38:#include "util/std_util.hpp"
        -:   39:
        -:   40://IO formats
        -:   41:#include "io/bmp.hpp"
        -:   42:#include "io/exr.hpp"
        -:   43:#include "io/exr_tiny.hpp"
        -:   44:#include "io/hdr.hpp"
        -:   45:#include "io/pfm.hpp"
        -:   46:#include "io/ppm.hpp"
        -:   47:#include "io/pgm.hpp"
        -:   48:#include "io/tmp.hpp"
        -:   49:#include "io/tga.hpp"
        -:   50:#include "io/vol.hpp"
        -:   51:#include "io/stb.hpp"
        -:   52:#include "io/exif.hpp"
        -:   53:#include "util/io.hpp"
        -:   54:
        -:   55:namespace pic {
        -:   56:
        -:   57:/**
        -:   58: * @brief The Image class stores an image as buffer of float.
        -:   59: */
        -:   60:class Image
        -:   61:{
        -:   62:protected:
        -:   63:
        -:   64:    /**
        -:   65:     * @brief setNULL sets buffers values to NULL.
        -:   66:     */
        -:   67:    void setNULL();
        -:   68:
        -:   69:    //applied rendering values
        -:   70:    bool flippedEXR;
        -:   71:    int  readerCounter;
        -:   72:    bool notOwned;
        -:   73:
        -:   74:    BBox fullBox;
        -:   75:
        -:   76:    LDR_type typeLoad;
        -:   77:
        -:   78:public:
        -:   79:    float exposure;
        -:   80:    int width, height, channels, frames, depth, alpha;
        -:   81:
        -:   82:    int tstride, ystride, xstride;
        -:   83:
        -:   84:    float widthf, width1f, heightf, height1f, channelsf, framesf, frames1f;
        -:   85:
        -:   86:    std::string nameFile;
        -:   87:
        -:   88:    /**
        -:   89:     * @brief data is the main buffer where pixel values are stored.
        -:   90:     */
        -:   91:    float *data;
        -:   92:
        -:   93:    /**
        -:   94:     * @brief dataUC is a buffer for rendering 8-bit images.
        -:   95:     */
        -:   96:    unsigned char *dataUC;
        -:   97:
        -:   98:    /**
        -:   99:     * @brief dataRGBE is a buffer for rendering RGBE encoded images.
        -:  100:     */
        -:  101:    unsigned char *dataRGBE;
        -:  102:
        -:  103:    //Half-precision encoding
        -:  104:#ifdef PIC_ENABLE_OPEN_EXR
        -:  105:    Imf::Rgba *dataEXR;
        -:  106:#endif
        -:  107:
        -:  108:    /**
        -:  109:     * @brief the basic construct of an Image
        -:  110:     */
        -:  111:    Image();
        -:  112:
        -:  113:    /**
        -:  114:     * @brief Image embeds an existing image in the new image.
        -:  115:     * @param imgIn is the input image to embed.
        -:  116:     * @param deepCopy enables a deep copy of img into this.
        -:  117:     */
        -:  118:    Image(Image *imgIn, bool deepCopy);
        -:  119:
        -:  120:    /**
        -:  121:    * @brief Image loads an Image from a file on the disk.
        -:  122:    * @param nameFile is the file name.
        -:  123:    * @param typeLoad is an option for LDR images only:
        -:  124:    * LT_NOR means that the input image values will be normalized in [0,1].
        -:  125:    * LT_NOR_GAMMA means that the input image values will be normalized in [0,1], and
        -:  126:    * gamma correction 2.2 will be removed.
        -:  127:    * LT_NONE means that image values are not modified during the loading.
        -:  128:    *
        -:  129:    * The default value is LT_NOR_GAMMA assuming that
        -:  130:    * we are storing normalized and linearized values in Image.
        -:  131:    */
        -:  132:    Image(std::string nameFile, LDR_type typeLoad);
        -:  133:
        -:  134:    /**
        -:  135:    * @brief Image creates an Image with a given size.
        -:  136:    * @param width is the horizontal size in pixels.
        -:  137:    * @param height is the vertical size in pixels.
        -:  138:    * @param channels is the number of color channels.
        -:  139:    */
        -:  140:    Image(int width, int height, int channels);
        -:  141:
        -:  142:   /**
        -:  143:   * @brief Image embeds an array of float inside an Image.
        -:  144:   * @param color is the pointer to an array of float values.
        -:  145:   * @param channels is the color's number of elements.
        -:  146:   */
        -:  147:    Image(float *color, int channels);
        -:  148:
        -:  149:    /**
        -:  150:     * @brief Image is a constructor which initializes an image defined by
        -:  151:     * the input properties.
        -:  152:     * @param frames is the number of temporal pixels.
        -:  153:     * @param width is the number of horizontal pixels.
        -:  154:     * @param height is the number of vertical pixels.
        -:  155:     * @param channels is the number of color channels.
        -:  156:     * @param data is a buffer of size frames * width * height * channels.
        -:  157:     * If it is empty (set to NULL) a new buffer will be created.
        -:  158:     */
        -:  159:    Image(int frames, int width, int height, int channels, float *data);
        -:  160:
        -:  161:    /**
        -:  162:    * @brief Image destructor. This deallocates: data, dataUC, and dataRGBE
        -:  163:    */
        -:  164:    ~Image();
        -:  165:
        -:  166:    /**
        -:  167:     * @brief allocate allocates memory for the pixel buffer.
        -:  168:     * @param width is the number of horizontal pixels.
        -:  169:     * @param height is the number of vertical pixels.
        -:  170:     * @param channels is the number of color channels.
        -:  171:     * @param frames is the number of temporal pixels.
        -:  172:     */
        -:  173:    void allocate(int width, int height, int channels, int frames);
        -:  174:
        -:  175:    /**
        -:  176:     * @brief allocateAux computes extra information after allocation;
        -:  177:     * e.g. strides.
        -:  178:     */
        -:  179:    void allocateAux();
        -:  180:
        -:  181:    /**
        -:  182:     * @brief release frees allocated buffers.
        -:  183:     */
        -:  184:    void release();
        -:  185:
        -:  186:    /**
        -:  187:     * @brief copySubImage copies imgIn in the current image.
        -:  188:     * The current image is written from (startX, startY).
        -:  189:     * @param imgIn the image to be copied.
        -:  190:     * @param startX is the horizontal coordinate in pixels.
        -:  191:     * @param startY is the vertical coordinate in pixels.
        -:  192:     */
        -:  193:    void copySubImage(Image *imgIn, int startX, int startY);
        -:  194:
        -:  195:    /**
        -:  196:     * @brief scaleCosine multiplies the current image by the vertical cosine
        -:  197:     * assuming a longitude-latitude image.
        -:  198:     */
        -:  199:    void scaleCosine();
        -:  200:
        -:  201:    /**
        -:  202:     * @brief FlipH flips horizontally the current image.
        -:  203:     */
        -:  204:    void flipH()
        -:  205:    {
        -:  206:        Buffer<float>::flipH(data, width, height, channels, frames);
        -:  207:    }
        -:  208:
        -:  209:    /**
        -:  210:     * @brief FlipV flips vertically the current image.
        -:  211:     */
        -:  212:    void flipV()
        -:  213:    {
        -:  214:        Buffer<float>::flipV(data, width, height, channels, frames);
        -:  215:    }
        -:  216:
        -:  217:    /**
        -:  218:     * @brief flipHV flips horizontally and vertically the current image.
        -:  219:     */
    #####:  220:    void flipHV()
        -:  221:    {
    #####:  222:        Buffer<float>::flipH(data, width, height, channels, frames);
    #####:  223:        Buffer<float>::flipV(data, width, height, channels, frames);
    #####:  224:    }
        -:  225:
        -:  226:    /**
        -:  227:     * @brief flipVH flips vertically and horizontally the current image.
        -:  228:     */
        -:  229:    void flipVH()
        -:  230:    {
        -:  231:        Buffer<float>::flipV(data, width, height, channels, frames);
        -:  232:        Buffer<float>::flipH(data, width, height, channels, frames);
        -:  233:    }
        -:  234:
        -:  235:    /**
        -:  236:     * @brief rotate90CCW rotates 90 degrees counter-clockwise the current image.
        -:  237:     */
        -:  238:    void rotate90CCW()
        -:  239:    {
        -:  240:        Buffer<float>::rotate90CCW(data, width, height, channels);
        -:  241:        allocateAux();
        -:  242:    }
        -:  243:
        -:  244:    /**
        -:  245:     * @brief rotate90CW rotates 90 degrees clockwise the current image.
        -:  246:     */
        -:  247:    void rotate90CW()
        -:  248:    {
        -:  249:        Buffer<float>::rotate90CW(data, width, height, channels);
        -:  250:        allocateAux();
        -:  251:    }
        -:  252:
        -:  253:    /**
        -:  254:     * @brief getDiagonalSize
        -:  255:     * @return
        -:  256:     */
        -:  257:    float getDiagonalSize()
        -:  258:    {
        -:  259:        return sqrtf(widthf * widthf + heightf * heightf);
        -:  260:    }
        -:  261:
        -:  262:    /**
        -:  263:     * @brief setZero sets data to 0.0f.
        -:  264:     */
        -:  265:    void setZero();
        -:  266:
        -:  267:    /**
        -:  268:     * @brief setRand
        -:  269:     * @param seed
        -:  270:     */
        -:  271:    void setRand(unsigned int seed);
        -:  272:
        -:  273:    /**
        -:  274:     * @brief isValid checks if the current image is valid, which means if they
        -:  275:     * have an allocated buffer or not.
        -:  276:     * @return This function return true if the current Image is allocated,
        -:  277:     * otherwise false.
        -:  278:     */
        -:  279:    bool isValid();
        -:  280:
        -:  281:    /**
        -:  282:     * @brief isSimilarType checks if the current image is similar to img;
        -:  283:     * i.e. if they have the same width, height, frames, and channels.
        -:  284:     * @param img is an input image
        -:  285:     * @return This function returns true if the two images are similar,
        -:  286:     * otherwise false.
        -:  287:     */
        -:  288:    bool isSimilarType(const Image *img);    
        -:  289:
        -:  290:    /**
        -:  291:     * @brief assign
        -:  292:     * @param imgIn
        -:  293:     */
        -:  294:    void assign(const Image *imgIn);
        -:  295:
        -:  296:    /**
        -:  297:     * @brief blend
        -:  298:     * @param img
        -:  299:     * @param weight
        -:  300:     */
        -:  301:    void blend(Image *img, Image *weight);
        -:  302:
        -:  303:    /**
        -:  304:     * @brief minimum is the minimum operator for Image.
        -:  305:     * @param img is a and Image and the operand. This
        -:  306:     * and the current Image need to have the same width,
        -:  307:     * height, and color channels.
        -:  308:     */
        -:  309:    void minimum(Image *img);
        -:  310:
        -:  311:    /**
        -:  312:     * @brief maximum is the maximum operator for Image.
        -:  313:     * @param img is a and Image and the operand. This
        -:  314:     * and the current Image need to have the same width,
        -:  315:     * height, and color channels.
        -:  316:     */
        -:  317:    void maximum(Image *img);
        -:  318:
        -:  319:    /**
        -:  320:     * @brief applyFunction is an operator that applies
        -:  321:     * an input function to all values in data.
        -:  322:     */
        -:  323:    void applyFunction(float(*func)(float));
        -:  324:
        -:  325:    /**
        -:  326:     * @brief applyFunctionParam
        -:  327:     * @param param
        -:  328:     */
        -:  329:    void applyFunctionParam(float(*func)(float, std::vector<float>&), std::vector<float> &param);
        -:  330:
        -:  331:    /**
        -:  332:     * @brief getFullBox computes a full BBox for this image.
        -:  333:     * @return This function returns a full BBox for this image.
        -:  334:     */
        -:  335:    BBox getFullBox();
        -:  336:
        -:  337:    /**
        -:  338:     * @brief getMaxVal computes the maximum value for the current Image.
        -:  339:     * @param box is the bounding box where to compute the function. If it
        -:  340:     * is set to NULL the function will be computed on the entire image.
        -:  341:     * @param ret is an array where the function computations are stored. If it
        -:  342:     * is set to NULL an array will be allocated.
        -:  343:     * @return This function returns an array where the function computations
        -:  344:     * are stored.
        -:  345:     */
        -:  346:    float *getMaxVal(BBox *box, float *ret);
        -:  347:
        -:  348:    /**
        -:  349:     * @brief getMinVal computes the minimum value for the current Image.
        -:  350:     * @param box is the bounding box where to compute the function. If it
        -:  351:     * is set to NULL the function will be computed on the entire image.
        -:  352:     * @param ret is an array where the function computations are stored. If it
        -:  353:     * is set to NULL an array will be allocated.
        -:  354:     * @return This function returns an array where the function computations
        -:  355:     * are stored.
        -:  356:     */
        -:  357:    float *getMinVal(BBox *box, float *ret);
        -:  358:
        -:  359:    /**
        -:  360:     * @brief getLogMeanVal computes the log mean for the current Image.
        -:  361:     * @param box is the bounding box where to compute the function. If it
        -:  362:     * is set to NULL the function will be computed on the entire image.
        -:  363:     * @param ret is an array where the function computations are stored. If it
        -:  364:     * is set to NULL an array will be allocated.
        -:  365:     * @return This function returns an array where the function computations
        -:  366:     * are stored.
        -:  367:     */
        -:  368:    float *getLogMeanVal(BBox *box, float *ret);
        -:  369:
        -:  370:    /**
        -:  371:     * @brief getSumVal sums values for the current Image.
        -:  372:     * @param box is the bounding box where to compute the function. If it
        -:  373:     * is set to NULL the function will be computed on the entire image.
        -:  374:     * @param ret is an array where the function computations are stored. If it
        -:  375:     * is set to NULL an array will be allocated.
        -:  376:     * @return This function returns an array where the function computations
        -:  377:     * are stored.
        -:  378:     */
        -:  379:    float *getSumVal(BBox *box, float *ret);
        -:  380:
        -:  381:    /**
        -:  382:     * @brief getMeanVal computes the mean for the current Image.
        -:  383:     * @param box is the bounding box where to compute the function. If it
        -:  384:     * is set to NULL the function will be computed on the entire image.
        -:  385:     * @param ret is an array where the function computations are stored. If it
        -:  386:     * is set to NULL an array will be allocated.
        -:  387:     * @return This function returns an array where the function computations
        -:  388:     * are stored.
        -:  389:     */
        -:  390:    float *getMeanVal(BBox *box, float *ret);
        -:  391:
        -:  392:    /**
        -:  393:     * @brief getMomentsVal computes the moments at pixel (x0, y0).
        -:  394:     * @param x0 is the horizontal coordinate.
        -:  395:     * @param y0 is the vertical coordinate.
        -:  396:     * @param radius is the radius of the patch.
        -:  397:     * @param ret is an array where the function computations are stored. If it
        -:  398:     * is set to NULL an array will be allocated.
        -:  399:     * @return This function returns an array where the function computations
        -:  400:     * are stored.
        -:  401:     */
        -:  402:    float *getMomentsVal(int x0, int y0, int radius, float *ret);
        -:  403:
        -:  404:    /**
        -:  405:     * @brief getVarianceVal computes the variance for the current Image.
        -:  406:     * @param box is the bounding box where to compute the function. If it
        -:  407:     * is set to NULL the function will be computed on the entire image.
        -:  408:     * @param ret is an array where the function computations are stored. If it
        -:  409:     * is set to NULL an array will be allocated.
        -:  410:     * @return This function returns an array where the function computations
        -:  411:     * are stored.
        -:  412:     */
        -:  413:    float *getVarianceVal(float *meanVal, BBox *box, float *ret);
        -:  414:
        -:  415:    /**
        -:  416:     * @brief getCovMtxVal computes the convariance matrix for the current Image.
        -:  417:     * @param box is the bounding box where to compute the function. If it
        -:  418:     * is set to NULL the function will be computed on the entire image.
        -:  419:     * @param ret is an array where the function computations are stored. If it
        -:  420:     * is set to NULL an array will be allocated.
        -:  421:     * @return This function returns an array where the function computations
        -:  422:     * are stored.
        -:  423:     */
        -:  424:    float *getCovMtxVal(float *meanVal, BBox *box, float *ret);
        -:  425:
        -:  426:    /**
        -:  427:     * @brief getPercentileVal computes the n-th value given a percentile.
        -:  428:     * @param percentile is the percentile.
        -:  429:     * @param box is the bounding box where to compute the function. If it
        -:  430:     * is set to NULL the function will be computed on the entire image.
        -:  431:     * @param percentile is the percentile.
        -:  432:     * @param ret is an array where the function computations are stored. If it
        -:  433:     * is set to NULL an array will be allocated.
        -:  434:     * @return This function returns an array where the function computations
        -:  435:     * are stored.
        -:  436:     */
        -:  437:    float *getPercentileVal(float percentile, BBox *box, float *ret);
        -:  438:
        -:  439:
        -:  440:    /**
        -:  441:     * @brief getPercentileVal computes the median value value given a percentile.
        -:  442:     * @param box is the bounding box where to compute the function. If it
        -:  443:     * is set to NULL the function will be computed on the entire image.
        -:  444:     * @param percentile is the percentile.
        -:  445:     * @param ret is an array where the function computations are stored. If it
        -:  446:     * is set to NULL an array will be allocated.
        -:  447:     * @return This function returns an array where the function computations
        -:  448:     * are stored.
        -:  449:     */
        -:  450:    float *getMedVal( BBox *box, float *ret);
        -:  451:
        -:  452:    /**
        -:  453:     * @brief getDynamicRange computes the dynamic range of the image.
        -:  454:     * @param bRobust is a value that enables robust computation of the dynamic range using percentile.
        -:  455:     * @param percentile is the percentile value used when computing the dynamic range in a robust way.
        -:  456:     * @return
        -:  457:     */
        -:  458:    float getDynamicRange(bool bRobust, float percentile);
        -:  459:
        -:  460:    /**
        -:  461:     * @brief getdataUC
        -:  462:     * @return
        -:  463:     */
        -:  464:    unsigned char *getdataUC()
        -:  465:    {
        -:  466:        return dataUC;
        -:  467:    }
        -:  468:
        -:  469:    /**
        -:  470:     * @brief getColorSamples
        -:  471:     * @param samples
        -:  472:     * @param percentage
        -:  473:     * @return
        -:  474:     */
        -:  475:    float *getColorSamples(float *samples, int &nSamples, float percentage);
        -:  476:
        -:  477:    /**
        -:  478:     * @brief size computes the number of values.
        -:  479:     * @return This function returns the number of values of the entire image.
        -:  480:     */
       6*:  481:    int size() const
        -:  482:    {
    #####:  483:        return height * width * channels * frames;
    %%%%%:  483-block  0
    %%%%%:  483-block  1
    %%%%%:  483-block  2
        -:  484:    }
        -:  485:
        -:  486:    /**
        -:  487:     * @brief size computes the number of values.
        -:  488:     * @return This function returns the number of values of a frame.
        -:  489:     */
        8:  490:    int sizeFrame() const
        -:  491:    {
        8:  492:        return height * width * channels;
        -:  493:    }
        -:  494:
        -:  495:    /**
        -:  496:     * @brief nPixels computes the number of pixels.
        -:  497:     * @return This function returns the number of pixels.
        -:  498:     */
       4*:  499:    int nPixels() const
        -:  500:    {
    #####:  501:        return height * width * frames;
    %%%%%:  501-block  0
        -:  502:    }
        -:  503:
        -:  504:    /**
        -:  505:     * @brief checkCoordinates checks (x, y, z) coordinates) if they are valid or not.
        -:  506:     * @param x is the horizontal coordinate.
        -:  507:     * @param y is the vertical coordinate.
        -:  508:     * @param z is the temporal coordinate.
        -:  509:     * @return This function returns true if the coordinates are inside the bounding
        -:  510:     * box of the Image.
        -:  511:     */
        -:  512:    bool checkCoordinates(int x, int y, int z = 0)
        -:  513:    {
        -:  514:        return (x > -1) && (x < width) && (y > -1) && (y < height) &&
        -:  515:               (z > -1) && (z < frames);
        -:  516:    }
        -:  517:
        -:  518:    /**
        -:  519:     * @brief convertFromMask converts a boolean mask into an Image. true is mapped
        -:  520:     * to 1.0f, and false is mapped to 0.0f.
        -:  521:     * @param mask is a buffer of boolean values with (width * height) elements.
        -:  522:     * @param width is the horizontal number of pixels.
        -:  523:     * @param height is the vertical number of pixels.
        -:  524:     */
        -:  525:    void convertFromMask(bool *mask, int width, int height);
        -:  526:
        -:  527:    /**
        -:  528:     * @brief convertToMask converts an Image into a boolean mask.
        -:  529:     * @param color
        -:  530:     * @param threshold
        -:  531:     * @param cmp
        -:  532:     * @param mask
        -:  533:     * @return
        -:  534:     */
        -:  535:    bool *convertToMask(float *color, float threshold, bool cmp, bool *mask);
        -:  536:
        -:  537:    /**
        -:  538:     * @brief getFlippedEXR returns the flippedEXR flag.
        -:  539:     * @return This function returns the flippedEXR flag.
        -:  540:     */
        -:  541:    bool getFlippedEXR()
        -:  542:    {
        -:  543:        return flippedEXR;
        -:  544:    }
        -:  545:
        -:  546:    /**
        -:  547:     * @brief removeSpecials removes NaN and +/-Inf values and sets
        -:  548:     * them to 0.0f.
        -:  549:     */
        -:  550:    void removeSpecials();
        -:  551:
        -:  552:    /**
        -:  553:     * @brief clamp set data values in the range [a,b]
        -:  554:     * @param a the minimum value.
        -:  555:     * @param b the maximum value.
        -:  556:     */
        -:  557:    void clamp(float a, float b);
        -:  558:
        -:  559:    /**
        -:  560:     * @brief calculateStrides computes the strides values
        -:  561:     * for pixels, lines and frames.
        -:  562:     */
       11:  563:    void calculateStrides()
        -:  564:    {
       11:  565:        tstride = channels * height * width;
       11:  566:        ystride = width * channels;
       11:  567:        xstride = channels;
        -:  568:    }
        -:  569:
        -:  570:    /**
        -:  571:     * @brief operator () returns a pointer to a pixel at (x, y, t)
        -:  572:     * @param x is the horizontal coordinate in pixels
        -:  573:     * @param y is the vertical coordinate in pixels
        -:  574:     * @param t is the temporal coordinate in pixels
        -:  575:     * @return This function returns a pointer to data at location (x, y, t).
        -:  576:     */
  1093120:  577:    float *operator()(int x, int y, int t)
        -:  578:    {
 1093120*:  579:        return data + CLAMP(t, frames) * tstride +
  1093120:  579-block  0
    %%%%%:  579-block  1
  1093120:  579-block  2
 1093120*:  580:                      CLAMP(x, width)  * xstride +
  1093120:  580-block  0
    %%%%%:  580-block  1
  1093120:  580-block  2
 1093120*:  581:                      CLAMP(y, height) * ystride;
  1093120:  581-block  0
    %%%%%:  581-block  1
  1093120:  581-block  2
        -:  582:    }
        -:  583:
        -:  584:    /**
        -:  585:     * @brief operator () returns a pointer to a pixel at (x, y)
        -:  586:     * @param x is the horizontal coordinate in pixels
        -:  587:     * @param y is the vertical coordinate in pixels
        -:  588:     * @return This function returns a pointer to data at location (x, y).
        -:  589:     */
  819840*:  590:    float *operator()(int x, int y)
    %%%%%:  590-block  0
    %%%%%:  590-block  1
    %%%%%:  590-block  2
    %%%%%:  590-block  3
    %%%%%:  590-block  4
    %%%%%:  590-block  5
    %%%%%:  590-block  6
    %%%%%:  590-block  7
    %%%%%:  590-block  8
    %%%%%:  590-block  9
    %%%%%:  590-block 10
    %%%%%:  590-block 11
    %%%%%:  590-block 12
    %%%%%:  590-block 13
    %%%%%:  590-block 14
    %%%%%:  590-block 15
    %%%%%:  590-block 16
    %%%%%:  590-block 17
    %%%%%:  590-block 18
    %%%%%:  590-block 19
    %%%%%:  590-block 20
    %%%%%:  590-block 21
   273280:  590-block 22
   273280:  590-block 23
    %%%%%:  590-block 24
    %%%%%:  590-block 25
    %%%%%:  590-block 26
    %%%%%:  590-block 27
    %%%%%:  590-block 28
    %%%%%:  590-block 29
    %%%%%:  590-block 30
    %%%%%:  590-block 31
    %%%%%:  590-block 32
    %%%%%:  590-block 33
    %%%%%:  590-block 34
    %%%%%:  590-block 35
    %%%%%:  590-block 36
    %%%%%:  590-block 37
    %%%%%:  590-block 38
    %%%%%:  590-block 39
    %%%%%:  590-block 40
    %%%%%:  590-block 41
    %%%%%:  590-block 42
    %%%%%:  590-block 43
    %%%%%:  590-block 44
    %%%%%:  590-block 45
    %%%%%:  590-block 46
    %%%%%:  590-block 47
    %%%%%:  590-block 48
    %%%%%:  590-block 49
    %%%%%:  590-block 50
    %%%%%:  590-block 51
    %%%%%:  590-block 52
    %%%%%:  590-block 53
    %%%%%:  590-block 54
    %%%%%:  590-block 55
    %%%%%:  590-block 56
    %%%%%:  590-block 57
    %%%%%:  590-block 58
    %%%%%:  590-block 59
    %%%%%:  590-block 60
    %%%%%:  590-block 61
    %%%%%:  590-block 62
    %%%%%:  590-block 63
    %%%%%:  590-block 64
    %%%%%:  590-block 65
    %%%%%:  590-block 66
   273280:  590-block 67
        -:  591:    {
 1366400*:  592:        return data + CLAMP(x, width)  * xstride +
    %%%%%:  592-block  0
    %%%%%:  592-block  1
    %%%%%:  592-block  2
    %%%%%:  592-block  3
    %%%%%:  592-block  4
    %%%%%:  592-block  5
    %%%%%:  592-block  6
    %%%%%:  592-block  7
    %%%%%:  592-block  8
    %%%%%:  592-block  9
    %%%%%:  592-block 10
    %%%%%:  592-block 11
    %%%%%:  592-block 12
    %%%%%:  592-block 13
    %%%%%:  592-block 14
    %%%%%:  592-block 15
    %%%%%:  592-block 16
    %%%%%:  592-block 17
    %%%%%:  592-block 18
    %%%%%:  592-block 19
    %%%%%:  592-block 20
    %%%%%:  592-block 21
    %%%%%:  592-block 22
    %%%%%:  592-block 23
    %%%%%:  592-block 24
    %%%%%:  592-block 25
    %%%%%:  592-block 26
    %%%%%:  592-block 27
    %%%%%:  592-block 28
    %%%%%:  592-block 29
    %%%%%:  592-block 30
    %%%%%:  592-block 31
    %%%%%:  592-block 32
    %%%%%:  592-block 33
    %%%%%:  592-block 34
    %%%%%:  592-block 35
    %%%%%:  592-block 36
    %%%%%:  592-block 37
    %%%%%:  592-block 38
    %%%%%:  592-block 39
    %%%%%:  592-block 40
    %%%%%:  592-block 41
    %%%%%:  592-block 42
    %%%%%:  592-block 43
    %%%%%:  592-block 44
    %%%%%:  592-block 45
    %%%%%:  592-block 46
    %%%%%:  592-block 47
    %%%%%:  592-block 48
    %%%%%:  592-block 49
    %%%%%:  592-block 50
    %%%%%:  592-block 51
    %%%%%:  592-block 52
    %%%%%:  592-block 53
    %%%%%:  592-block 54
    %%%%%:  592-block 55
    %%%%%:  592-block 56
    %%%%%:  592-block 57
    %%%%%:  592-block 58
    %%%%%:  592-block 59
    %%%%%:  592-block 60
    %%%%%:  592-block 61
    %%%%%:  592-block 62
    %%%%%:  592-block 63
    %%%%%:  592-block 64
    %%%%%:  592-block 65
    %%%%%:  592-block 66
    %%%%%:  592-block 67
    %%%%%:  592-block 68
    %%%%%:  592-block 69
    %%%%%:  592-block 70
    %%%%%:  592-block 71
    %%%%%:  592-block 72
    %%%%%:  592-block 73
    %%%%%:  592-block 74
    %%%%%:  592-block 75
    %%%%%:  592-block 76
    %%%%%:  592-block 77
    %%%%%:  592-block 78
    %%%%%:  592-block 79
    %%%%%:  592-block 80
    %%%%%:  592-block 81
    %%%%%:  592-block 82
    %%%%%:  592-block 83
    %%%%%:  592-block 84
    %%%%%:  592-block 85
    %%%%%:  592-block 86
    %%%%%:  592-block 87
    %%%%%:  592-block 88
    %%%%%:  592-block 89
    %%%%%:  592-block 90
    %%%%%:  592-block 91
    %%%%%:  592-block 92
    %%%%%:  592-block 93
    %%%%%:  592-block 94
    %%%%%:  592-block 95
    %%%%%:  592-block 96
    %%%%%:  592-block 97
    %%%%%:  592-block 98
    %%%%%:  592-block 99
    %%%%%:  592-block 100
    %%%%%:  592-block 101
    %%%%%:  592-block 102
    %%%%%:  592-block 103
    %%%%%:  592-block 104
    %%%%%:  592-block 105
    %%%%%:  592-block 106
    %%%%%:  592-block 107
    %%%%%:  592-block 108
    %%%%%:  592-block 109
    %%%%%:  592-block 110
    %%%%%:  592-block 111
    %%%%%:  592-block 112
    %%%%%:  592-block 113
    %%%%%:  592-block 114
    %%%%%:  592-block 115
    %%%%%:  592-block 116
    %%%%%:  592-block 117
    %%%%%:  592-block 118
    %%%%%:  592-block 119
    %%%%%:  592-block 120
    %%%%%:  592-block 121
    %%%%%:  592-block 122
    %%%%%:  592-block 123
    %%%%%:  592-block 124
    %%%%%:  592-block 125
    %%%%%:  592-block 126
    %%%%%:  592-block 127
    %%%%%:  592-block 128
    %%%%%:  592-block 129
    %%%%%:  592-block 130
    %%%%%:  592-block 131
    %%%%%:  592-block 132
    %%%%%:  592-block 133
    %%%%%:  592-block 134
    %%%%%:  592-block 135
    %%%%%:  592-block 136
    %%%%%:  592-block 137
    %%%%%:  592-block 138
    %%%%%:  592-block 139
    %%%%%:  592-block 140
    %%%%%:  592-block 141
    %%%%%:  592-block 142
    %%%%%:  592-block 143
    %%%%%:  592-block 144
    %%%%%:  592-block 145
    %%%%%:  592-block 146
    %%%%%:  592-block 147
    %%%%%:  592-block 148
    %%%%%:  592-block 149
    %%%%%:  592-block 150
    %%%%%:  592-block 151
    %%%%%:  592-block 152
    %%%%%:  592-block 153
    %%%%%:  592-block 154
    %%%%%:  592-block 155
    %%%%%:  592-block 156
    %%%%%:  592-block 157
    %%%%%:  592-block 158
    %%%%%:  592-block 159
    %%%%%:  592-block 160
    %%%%%:  592-block 161
    %%%%%:  592-block 162
    %%%%%:  592-block 163
    %%%%%:  592-block 164
    %%%%%:  592-block 165
   273280:  592-block 166
    %%%%%:  592-block 167
   273280:  592-block 168
    %%%%%:  592-block 169
   273280:  592-block 170
    %%%%%:  592-block 171
   273280:  592-block 172
    %%%%%:  592-block 173
    %%%%%:  592-block 174
    %%%%%:  592-block 175
    %%%%%:  592-block 176
    %%%%%:  592-block 177
    %%%%%:  592-block 178
    %%%%%:  592-block 179
    %%%%%:  592-block 180
    %%%%%:  592-block 181
    %%%%%:  592-block 182
    %%%%%:  592-block 183
    %%%%%:  592-block 184
    %%%%%:  592-block 185
    %%%%%:  592-block 186
    %%%%%:  592-block 187
    %%%%%:  592-block 188
    %%%%%:  592-block 189
    %%%%%:  592-block 190
    %%%%%:  592-block 191
    %%%%%:  592-block 192
    %%%%%:  592-block 193
    %%%%%:  592-block 194
    %%%%%:  592-block 195
    %%%%%:  592-block 196
    %%%%%:  592-block 197
    %%%%%:  592-block 198
    %%%%%:  592-block 199
    %%%%%:  592-block 200
    %%%%%:  592-block 201
    %%%%%:  592-block 202
    %%%%%:  592-block 203
    %%%%%:  592-block 204
    %%%%%:  592-block 205
    %%%%%:  592-block 206
    %%%%%:  592-block 207
    %%%%%:  592-block 208
    %%%%%:  592-block 209
    %%%%%:  592-block 210
    %%%%%:  592-block 211
    %%%%%:  592-block 212
    %%%%%:  592-block 213
    %%%%%:  592-block 214
    %%%%%:  592-block 215
    %%%%%:  592-block 216
    %%%%%:  592-block 217
    %%%%%:  592-block 218
    %%%%%:  592-block 219
    %%%%%:  592-block 220
    %%%%%:  592-block 221
    %%%%%:  592-block 222
    %%%%%:  592-block 223
    %%%%%:  592-block 224
    %%%%%:  592-block 225
    %%%%%:  592-block 226
    %%%%%:  592-block 227
    %%%%%:  592-block 228
    %%%%%:  592-block 229
    %%%%%:  592-block 230
    %%%%%:  592-block 231
    %%%%%:  592-block 232
    %%%%%:  592-block 233
    %%%%%:  592-block 234
    %%%%%:  592-block 235
    %%%%%:  592-block 236
    %%%%%:  592-block 237
    %%%%%:  592-block 238
    %%%%%:  592-block 239
    %%%%%:  592-block 240
    %%%%%:  592-block 241
    %%%%%:  592-block 242
    %%%%%:  592-block 243
    %%%%%:  592-block 244
    %%%%%:  592-block 245
    %%%%%:  592-block 246
    %%%%%:  592-block 247
    %%%%%:  592-block 248
    %%%%%:  592-block 249
    %%%%%:  592-block 250
    %%%%%:  592-block 251
    %%%%%:  592-block 252
    %%%%%:  592-block 253
    %%%%%:  592-block 254
    %%%%%:  592-block 255
    %%%%%:  592-block 256
    %%%%%:  592-block 257
    %%%%%:  592-block 258
    %%%%%:  592-block 259
    %%%%%:  592-block 260
    %%%%%:  592-block 261
    %%%%%:  592-block 262
    %%%%%:  592-block 263
    %%%%%:  592-block 264
    %%%%%:  592-block 265
    %%%%%:  592-block 266
    %%%%%:  592-block 267
    %%%%%:  592-block 268
    %%%%%:  592-block 269
    %%%%%:  592-block 270
    %%%%%:  592-block 271
    %%%%%:  592-block 272
    %%%%%:  592-block 273
    %%%%%:  592-block 274
    %%%%%:  592-block 275
    %%%%%:  592-block 276
    %%%%%:  592-block 277
    %%%%%:  592-block 278
    %%%%%:  592-block 279
    %%%%%:  592-block 280
    %%%%%:  592-block 281
    %%%%%:  592-block 282
    %%%%%:  592-block 283
    %%%%%:  592-block 284
    %%%%%:  592-block 285
    %%%%%:  592-block 286
    %%%%%:  592-block 287
    %%%%%:  592-block 288
    %%%%%:  592-block 289
    %%%%%:  592-block 290
    %%%%%:  592-block 291
    %%%%%:  592-block 292
    %%%%%:  592-block 293
    %%%%%:  592-block 294
    %%%%%:  592-block 295
    %%%%%:  592-block 296
    %%%%%:  592-block 297
    %%%%%:  592-block 298
    %%%%%:  592-block 299
    %%%%%:  592-block 300
    %%%%%:  592-block 301
    %%%%%:  592-block 302
    %%%%%:  592-block 303
    %%%%%:  592-block 304
    %%%%%:  592-block 305
    %%%%%:  592-block 306
    %%%%%:  592-block 307
    %%%%%:  592-block 308
    %%%%%:  592-block 309
    %%%%%:  592-block 310
    %%%%%:  592-block 311
    %%%%%:  592-block 312
    %%%%%:  592-block 313
    %%%%%:  592-block 314
    %%%%%:  592-block 315
    %%%%%:  592-block 316
    %%%%%:  592-block 317
    %%%%%:  592-block 318
    %%%%%:  592-block 319
    %%%%%:  592-block 320
    %%%%%:  592-block 321
    %%%%%:  592-block 322
    %%%%%:  592-block 323
    %%%%%:  592-block 324
    %%%%%:  592-block 325
    %%%%%:  592-block 326
    %%%%%:  592-block 327
    %%%%%:  592-block 328
    %%%%%:  592-block 329
    %%%%%:  592-block 330
    %%%%%:  592-block 331
    %%%%%:  592-block 332
    %%%%%:  592-block 333
    %%%%%:  592-block 334
    %%%%%:  592-block 335
    %%%%%:  592-block 336
    %%%%%:  592-block 337
    %%%%%:  592-block 338
    %%%%%:  592-block 339
    %%%%%:  592-block 340
    %%%%%:  592-block 341
    %%%%%:  592-block 342
    %%%%%:  592-block 343
    %%%%%:  592-block 344
    %%%%%:  592-block 345
    %%%%%:  592-block 346
    %%%%%:  592-block 347
   273280:  592-block 348
    %%%%%:  592-block 349
   273280:  592-block 350
    %%%%%:  592-block 351
   273280:  592-block 352
    %%%%%:  592-block 353
    %%%%%:  592-block 354
    %%%%%:  592-block 355
    %%%%%:  592-block 356
    %%%%%:  592-block 357
    %%%%%:  592-block 358
    %%%%%:  592-block 359
    %%%%%:  592-block 360
    %%%%%:  592-block 361
 1366400*:  593:                      CLAMP(y, height) * ystride;
    %%%%%:  593-block  0
    %%%%%:  593-block  1
    %%%%%:  593-block  2
    %%%%%:  593-block  3
    %%%%%:  593-block  4
    %%%%%:  593-block  5
    %%%%%:  593-block  6
    %%%%%:  593-block  7
    %%%%%:  593-block  8
    %%%%%:  593-block  9
    %%%%%:  593-block 10
    %%%%%:  593-block 11
    %%%%%:  593-block 12
    %%%%%:  593-block 13
    %%%%%:  593-block 14
    %%%%%:  593-block 15
    %%%%%:  593-block 16
    %%%%%:  593-block 17
    %%%%%:  593-block 18
    %%%%%:  593-block 19
    %%%%%:  593-block 20
    %%%%%:  593-block 21
    %%%%%:  593-block 22
    %%%%%:  593-block 23
    %%%%%:  593-block 24
    %%%%%:  593-block 25
    %%%%%:  593-block 26
    %%%%%:  593-block 27
    %%%%%:  593-block 28
    %%%%%:  593-block 29
    %%%%%:  593-block 30
    %%%%%:  593-block 31
    %%%%%:  593-block 32
    %%%%%:  593-block 33
    %%%%%:  593-block 34
    %%%%%:  593-block 35
    %%%%%:  593-block 36
    %%%%%:  593-block 37
    %%%%%:  593-block 38
    %%%%%:  593-block 39
    %%%%%:  593-block 40
    %%%%%:  593-block 41
    %%%%%:  593-block 42
    %%%%%:  593-block 43
    %%%%%:  593-block 44
    %%%%%:  593-block 45
    %%%%%:  593-block 46
    %%%%%:  593-block 47
    %%%%%:  593-block 48
    %%%%%:  593-block 49
    %%%%%:  593-block 50
    %%%%%:  593-block 51
    %%%%%:  593-block 52
    %%%%%:  593-block 53
    %%%%%:  593-block 54
    %%%%%:  593-block 55
    %%%%%:  593-block 56
    %%%%%:  593-block 57
    %%%%%:  593-block 58
    %%%%%:  593-block 59
    %%%%%:  593-block 60
    %%%%%:  593-block 61
    %%%%%:  593-block 62
    %%%%%:  593-block 63
    %%%%%:  593-block 64
    %%%%%:  593-block 65
    %%%%%:  593-block 66
    %%%%%:  593-block 67
    %%%%%:  593-block 68
    %%%%%:  593-block 69
    %%%%%:  593-block 70
    %%%%%:  593-block 71
    %%%%%:  593-block 72
    %%%%%:  593-block 73
    %%%%%:  593-block 74
    %%%%%:  593-block 75
    %%%%%:  593-block 76
    %%%%%:  593-block 77
    %%%%%:  593-block 78
    %%%%%:  593-block 79
    %%%%%:  593-block 80
    %%%%%:  593-block 81
    %%%%%:  593-block 82
    %%%%%:  593-block 83
    %%%%%:  593-block 84
    %%%%%:  593-block 85
    %%%%%:  593-block 86
    %%%%%:  593-block 87
    %%%%%:  593-block 88
    %%%%%:  593-block 89
    %%%%%:  593-block 90
    %%%%%:  593-block 91
    %%%%%:  593-block 92
    %%%%%:  593-block 93
    %%%%%:  593-block 94
    %%%%%:  593-block 95
    %%%%%:  593-block 96
    %%%%%:  593-block 97
    %%%%%:  593-block 98
    %%%%%:  593-block 99
    %%%%%:  593-block 100
    %%%%%:  593-block 101
    %%%%%:  593-block 102
    %%%%%:  593-block 103
    %%%%%:  593-block 104
    %%%%%:  593-block 105
    %%%%%:  593-block 106
    %%%%%:  593-block 107
    %%%%%:  593-block 108
    %%%%%:  593-block 109
    %%%%%:  593-block 110
    %%%%%:  593-block 111
    %%%%%:  593-block 112
    %%%%%:  593-block 113
    %%%%%:  593-block 114
    %%%%%:  593-block 115
    %%%%%:  593-block 116
    %%%%%:  593-block 117
    %%%%%:  593-block 118
    %%%%%:  593-block 119
    %%%%%:  593-block 120
    %%%%%:  593-block 121
    %%%%%:  593-block 122
    %%%%%:  593-block 123
    %%%%%:  593-block 124
    %%%%%:  593-block 125
    %%%%%:  593-block 126
    %%%%%:  593-block 127
    %%%%%:  593-block 128
    %%%%%:  593-block 129
    %%%%%:  593-block 130
    %%%%%:  593-block 131
    %%%%%:  593-block 132
    %%%%%:  593-block 133
    %%%%%:  593-block 134
    %%%%%:  593-block 135
    %%%%%:  593-block 136
    %%%%%:  593-block 137
    %%%%%:  593-block 138
    %%%%%:  593-block 139
    %%%%%:  593-block 140
    %%%%%:  593-block 141
    %%%%%:  593-block 142
    %%%%%:  593-block 143
    %%%%%:  593-block 144
    %%%%%:  593-block 145
    %%%%%:  593-block 146
    %%%%%:  593-block 147
    %%%%%:  593-block 148
    %%%%%:  593-block 149
    %%%%%:  593-block 150
    %%%%%:  593-block 151
    %%%%%:  593-block 152
    %%%%%:  593-block 153
    %%%%%:  593-block 154
    %%%%%:  593-block 155
    %%%%%:  593-block 156
    %%%%%:  593-block 157
    %%%%%:  593-block 158
    %%%%%:  593-block 159
    %%%%%:  593-block 160
    %%%%%:  593-block 161
    %%%%%:  593-block 162
    %%%%%:  593-block 163
    %%%%%:  593-block 164
    %%%%%:  593-block 165
    %%%%%:  593-block 166
    %%%%%:  593-block 167
    %%%%%:  593-block 168
    %%%%%:  593-block 169
    %%%%%:  593-block 170
    %%%%%:  593-block 171
    %%%%%:  593-block 172
    %%%%%:  593-block 173
    %%%%%:  593-block 174
    %%%%%:  593-block 175
    %%%%%:  593-block 176
    %%%%%:  593-block 177
    %%%%%:  593-block 178
    %%%%%:  593-block 179
    %%%%%:  593-block 180
    %%%%%:  593-block 181
    %%%%%:  593-block 182
    %%%%%:  593-block 183
    %%%%%:  593-block 184
    %%%%%:  593-block 185
    %%%%%:  593-block 186
    %%%%%:  593-block 187
    %%%%%:  593-block 188
    %%%%%:  593-block 189
    %%%%%:  593-block 190
    %%%%%:  593-block 191
    %%%%%:  593-block 192
    %%%%%:  593-block 193
    %%%%%:  593-block 194
    %%%%%:  593-block 195
    %%%%%:  593-block 196
    %%%%%:  593-block 197
    %%%%%:  593-block 198
    %%%%%:  593-block 199
    %%%%%:  593-block 200
    %%%%%:  593-block 201
    %%%%%:  593-block 202
    %%%%%:  593-block 203
    %%%%%:  593-block 204
    %%%%%:  593-block 205
    %%%%%:  593-block 206
    %%%%%:  593-block 207
    %%%%%:  593-block 208
    %%%%%:  593-block 209
    %%%%%:  593-block 210
    %%%%%:  593-block 211
    %%%%%:  593-block 212
    %%%%%:  593-block 213
    %%%%%:  593-block 214
    %%%%%:  593-block 215
    %%%%%:  593-block 216
    %%%%%:  593-block 217
    %%%%%:  593-block 218
    %%%%%:  593-block 219
    %%%%%:  593-block 220
    %%%%%:  593-block 221
    %%%%%:  593-block 222
    %%%%%:  593-block 223
    %%%%%:  593-block 224
    %%%%%:  593-block 225
    %%%%%:  593-block 226
    %%%%%:  593-block 227
    %%%%%:  593-block 228
    %%%%%:  593-block 229
    %%%%%:  593-block 230
    %%%%%:  593-block 231
    %%%%%:  593-block 232
    %%%%%:  593-block 233
    %%%%%:  593-block 234
    %%%%%:  593-block 235
    %%%%%:  593-block 236
    %%%%%:  593-block 237
    %%%%%:  593-block 238
    %%%%%:  593-block 239
    %%%%%:  593-block 240
    %%%%%:  593-block 241
    %%%%%:  593-block 242
    %%%%%:  593-block 243
    %%%%%:  593-block 244
    %%%%%:  593-block 245
    %%%%%:  593-block 246
    %%%%%:  593-block 247
   273280:  593-block 248
    %%%%%:  593-block 249
   273280:  593-block 250
   273280:  593-block 251
   273280:  593-block 252
    %%%%%:  593-block 253
   273280:  593-block 254
   273280:  593-block 255
   273280:  593-block 256
    %%%%%:  593-block 257
   273280:  593-block 258
   273280:  593-block 259
    %%%%%:  593-block 260
    %%%%%:  593-block 261
    %%%%%:  593-block 262
    %%%%%:  593-block 263
    %%%%%:  593-block 264
    %%%%%:  593-block 265
    %%%%%:  593-block 266
    %%%%%:  593-block 267
    %%%%%:  593-block 268
    %%%%%:  593-block 269
    %%%%%:  593-block 270
    %%%%%:  593-block 271
    %%%%%:  593-block 272
    %%%%%:  593-block 273
    %%%%%:  593-block 274
    %%%%%:  593-block 275
    %%%%%:  593-block 276
    %%%%%:  593-block 277
    %%%%%:  593-block 278
    %%%%%:  593-block 279
    %%%%%:  593-block 280
    %%%%%:  593-block 281
    %%%%%:  593-block 282
    %%%%%:  593-block 283
    %%%%%:  593-block 284
    %%%%%:  593-block 285
    %%%%%:  593-block 286
    %%%%%:  593-block 287
    %%%%%:  593-block 288
    %%%%%:  593-block 289
    %%%%%:  593-block 290
    %%%%%:  593-block 291
    %%%%%:  593-block 292
    %%%%%:  593-block 293
    %%%%%:  593-block 294
    %%%%%:  593-block 295
    %%%%%:  593-block 296
    %%%%%:  593-block 297
    %%%%%:  593-block 298
    %%%%%:  593-block 299
    %%%%%:  593-block 300
    %%%%%:  593-block 301
    %%%%%:  593-block 302
    %%%%%:  593-block 303
    %%%%%:  593-block 304
    %%%%%:  593-block 305
    %%%%%:  593-block 306
    %%%%%:  593-block 307
    %%%%%:  593-block 308
    %%%%%:  593-block 309
    %%%%%:  593-block 310
    %%%%%:  593-block 311
    %%%%%:  593-block 312
    %%%%%:  593-block 313
    %%%%%:  593-block 314
    %%%%%:  593-block 315
    %%%%%:  593-block 316
    %%%%%:  593-block 317
    %%%%%:  593-block 318
    %%%%%:  593-block 319
    %%%%%:  593-block 320
    %%%%%:  593-block 321
    %%%%%:  593-block 322
    %%%%%:  593-block 323
    %%%%%:  593-block 324
    %%%%%:  593-block 325
    %%%%%:  593-block 326
    %%%%%:  593-block 327
    %%%%%:  593-block 328
    %%%%%:  593-block 329
    %%%%%:  593-block 330
    %%%%%:  593-block 331
    %%%%%:  593-block 332
    %%%%%:  593-block 333
    %%%%%:  593-block 334
    %%%%%:  593-block 335
    %%%%%:  593-block 336
    %%%%%:  593-block 337
    %%%%%:  593-block 338
    %%%%%:  593-block 339
    %%%%%:  593-block 340
    %%%%%:  593-block 341
    %%%%%:  593-block 342
    %%%%%:  593-block 343
    %%%%%:  593-block 344
    %%%%%:  593-block 345
    %%%%%:  593-block 346
    %%%%%:  593-block 347
    %%%%%:  593-block 348
    %%%%%:  593-block 349
    %%%%%:  593-block 350
    %%%%%:  593-block 351
    %%%%%:  593-block 352
    %%%%%:  593-block 353
    %%%%%:  593-block 354
    %%%%%:  593-block 355
    %%%%%:  593-block 356
    %%%%%:  593-block 357
    %%%%%:  593-block 358
    %%%%%:  593-block 359
    %%%%%:  593-block 360
    %%%%%:  593-block 361
    %%%%%:  593-block 362
    %%%%%:  593-block 363
    %%%%%:  593-block 364
    %%%%%:  593-block 365
    %%%%%:  593-block 366
    %%%%%:  593-block 367
    %%%%%:  593-block 368
    %%%%%:  593-block 369
    %%%%%:  593-block 370
    %%%%%:  593-block 371
    %%%%%:  593-block 372
    %%%%%:  593-block 373
    %%%%%:  593-block 374
    %%%%%:  593-block 375
    %%%%%:  593-block 376
    %%%%%:  593-block 377
    %%%%%:  593-block 378
    %%%%%:  593-block 379
    %%%%%:  593-block 380
    %%%%%:  593-block 381
    %%%%%:  593-block 382
    %%%%%:  593-block 383
    %%%%%:  593-block 384
    %%%%%:  593-block 385
    %%%%%:  593-block 386
    %%%%%:  593-block 387
    %%%%%:  593-block 388
    %%%%%:  593-block 389
    %%%%%:  593-block 390
    %%%%%:  593-block 391
    %%%%%:  593-block 392
    %%%%%:  593-block 393
    %%%%%:  593-block 394
    %%%%%:  593-block 395
    %%%%%:  593-block 396
    %%%%%:  593-block 397
    %%%%%:  593-block 398
    %%%%%:  593-block 399
    %%%%%:  593-block 400
    %%%%%:  593-block 401
    %%%%%:  593-block 402
    %%%%%:  593-block 403
    %%%%%:  593-block 404
    %%%%%:  593-block 405
    %%%%%:  593-block 406
    %%%%%:  593-block 407
    %%%%%:  593-block 408
    %%%%%:  593-block 409
    %%%%%:  593-block 410
    %%%%%:  593-block 411
    %%%%%:  593-block 412
    %%%%%:  593-block 413
    %%%%%:  593-block 414
    %%%%%:  593-block 415
    %%%%%:  593-block 416
    %%%%%:  593-block 417
    %%%%%:  593-block 418
    %%%%%:  593-block 419
    %%%%%:  593-block 420
    %%%%%:  593-block 421
    %%%%%:  593-block 422
    %%%%%:  593-block 423
    %%%%%:  593-block 424
    %%%%%:  593-block 425
    %%%%%:  593-block 426
    %%%%%:  593-block 427
    %%%%%:  593-block 428
    %%%%%:  593-block 429
    %%%%%:  593-block 430
    %%%%%:  593-block 431
    %%%%%:  593-block 432
    %%%%%:  593-block 433
    %%%%%:  593-block 434
    %%%%%:  593-block 435
    %%%%%:  593-block 436
    %%%%%:  593-block 437
    %%%%%:  593-block 438
    %%%%%:  593-block 439
    %%%%%:  593-block 440
    %%%%%:  593-block 441
    %%%%%:  593-block 442
    %%%%%:  593-block 443
    %%%%%:  593-block 444
    %%%%%:  593-block 445
    %%%%%:  593-block 446
    %%%%%:  593-block 447
    %%%%%:  593-block 448
    %%%%%:  593-block 449
    %%%%%:  593-block 450
    %%%%%:  593-block 451
    %%%%%:  593-block 452
    %%%%%:  593-block 453
    %%%%%:  593-block 454
    %%%%%:  593-block 455
    %%%%%:  593-block 456
    %%%%%:  593-block 457
    %%%%%:  593-block 458
    %%%%%:  593-block 459
    %%%%%:  593-block 460
    %%%%%:  593-block 461
    %%%%%:  593-block 462
    %%%%%:  593-block 463
    %%%%%:  593-block 464
    %%%%%:  593-block 465
    %%%%%:  593-block 466
    %%%%%:  593-block 467
    %%%%%:  593-block 468
    %%%%%:  593-block 469
    %%%%%:  593-block 470
    %%%%%:  593-block 471
    %%%%%:  593-block 472
    %%%%%:  593-block 473
    %%%%%:  593-block 474
    %%%%%:  593-block 475
    %%%%%:  593-block 476
    %%%%%:  593-block 477
    %%%%%:  593-block 478
    %%%%%:  593-block 479
    %%%%%:  593-block 480
    %%%%%:  593-block 481
    %%%%%:  593-block 482
    %%%%%:  593-block 483
    %%%%%:  593-block 484
    %%%%%:  593-block 485
    %%%%%:  593-block 486
    %%%%%:  593-block 487
    %%%%%:  593-block 488
    %%%%%:  593-block 489
    %%%%%:  593-block 490
    %%%%%:  593-block 491
    %%%%%:  593-block 492
    %%%%%:  593-block 493
    %%%%%:  593-block 494
    %%%%%:  593-block 495
    %%%%%:  593-block 496
    %%%%%:  593-block 497
    %%%%%:  593-block 498
    %%%%%:  593-block 499
    %%%%%:  593-block 500
    %%%%%:  593-block 501
    %%%%%:  593-block 502
    %%%%%:  593-block 503
    %%%%%:  593-block 504
    %%%%%:  593-block 505
    %%%%%:  593-block 506
    %%%%%:  593-block 507
    %%%%%:  593-block 508
    %%%%%:  593-block 509
    %%%%%:  593-block 510
    %%%%%:  593-block 511
    %%%%%:  593-block 512
    %%%%%:  593-block 513
    %%%%%:  593-block 514
    %%%%%:  593-block 515
    %%%%%:  593-block 516
    %%%%%:  593-block 517
    %%%%%:  593-block 518
    %%%%%:  593-block 519
    %%%%%:  593-block 520
    %%%%%:  593-block 521
    %%%%%:  593-block 522
    %%%%%:  593-block 523
    %%%%%:  593-block 524
    %%%%%:  593-block 525
    %%%%%:  593-block 526
   273280:  593-block 527
    %%%%%:  593-block 528
   273280:  593-block 529
   273280:  593-block 530
   273280:  593-block 531
    %%%%%:  593-block 532
   273280:  593-block 533
   273280:  593-block 534
    %%%%%:  593-block 535
    %%%%%:  593-block 536
    %%%%%:  593-block 537
    %%%%%:  593-block 538
    %%%%%:  593-block 539
    %%%%%:  593-block 540
    %%%%%:  593-block 541
    %%%%%:  593-block 542
    %%%%%:  593-block 543
    %%%%%:  593-block 544
    %%%%%:  593-block 545
    %%%%%:  593-block 546
        -:  594:    }
        -:  595:
        -:  596:    /**
        -:  597:     * @brief operator () returns a pointer to a pixel at (x, y)
        -:  598:     * with normalized coordinates (values in [0, 1]).
        -:  599:     * @param x is the horizontal coordinate in pixels
        -:  600:     * @param y is the vertical coordinate in pixels
        -:  601:     * @return This function returns a pointer to data at location (x, y).
        -:  602:     */
        -:  603:    float *operator()(float x, float y)
        -:  604:    {
        -:  605:        int ix = CLAMP(int(floorf(x * width)), width);
        -:  606:        int iy = CLAMP(int(floorf(y * height)), height);
        -:  607:        return data + ix * xstride + iy * ystride;
        -:  608:    }
        -:  609:
        -:  610:    /**
        -:  611:     * @brief getLL returns a pointer to a pixel given a normalized
        -:  612:     * direction and assuming longituted-latitude mapping of the image.
        -:  613:     * @param x the x-coordinate of the unit-vector
        -:  614:     * @param y the y-coordinate of the unit-vector
        -:  615:     * @param z the z-coordinate of the unit-vector
        -:  616:     * @return This function returns a pointer to data at location (x, y, z)
        -:  617:     * that is normalized; i.e., sqrt(x^2+y^2+z^2) == 1.
        -:  618:     */
        -:  619:    float *getLL(float x, float y, float z)
        -:  620:    {
        -:  621:        float xf = 1.0f - ((atan2f(z, -x) * C_INV_PI) * 0.5f + 0.5f);
        -:  622:        float yf = (acosf(y) * C_INV_PI);
        -:  623:
        -:  624:        int ix = CLAMP(int(floorf(x * width)), width);
        -:  625:        int iy = CLAMP(int(floorf(y * height)), height);
        -:  626:
        -:  627:        return data + ix * xstride + iy * ystride;
        -:  628:    }
        -:  629:
        -:  630:    /**
        -:  631:     * @brief getNormalizedCoords computes normalized coordinates
        -:  632:     * (nx, ny) of (x, y).
        -:  633:     * @param x is the horizontal coordinate in pixels
        -:  634:     * @param y is the vertical coordinate in pixels
        -:  635:     * @param nx is the horizontal coordinate in [0, 1]
        -:  636:     * @param ny is the vertical coordinate in [0, 1]
        -:  637:     */
        -:  638:    void getNormalizedCoords(int x, int y, float &nx, float &ny)
        -:  639:    {
        -:  640:        nx = float(x) / width1f;
        -:  641:        ny = float(y) / height1f;
        -:  642:    }
        -:  643:
        -:  644:    /**
        -:  645:     * @brief getAddress calculates a memory address from (x, y)
        -:  646:     * @param x is the horizontal coordinate in pixels
        -:  647:     * @param y is the vertical coordinate in pixels
        -:  648:     * @return This function returns the memory address for (x, y)
        -:  649:     */
    #####:  650:    int getAddress(int x, int y)
    %%%%%:  650-block  0
    %%%%%:  650-block  1
    %%%%%:  650-block  2
    %%%%%:  650-block  3
    %%%%%:  650-block  4
    %%%%%:  650-block  5
    %%%%%:  650-block  6
    %%%%%:  650-block  7
    %%%%%:  650-block  8
    %%%%%:  650-block  9
    %%%%%:  650-block 10
    %%%%%:  650-block 11
    %%%%%:  650-block 12
    %%%%%:  650-block 13
        -:  651:    {
    #####:  652:        x = CLAMP(x, width);
    %%%%%:  652-block  0
    %%%%%:  652-block  1
    %%%%%:  652-block  2
    %%%%%:  652-block  3
    %%%%%:  652-block  4
    %%%%%:  652-block  5
    %%%%%:  652-block  6
    %%%%%:  652-block  7
    %%%%%:  652-block  8
    %%%%%:  652-block  9
    %%%%%:  652-block 10
    %%%%%:  652-block 11
    %%%%%:  652-block 12
    %%%%%:  652-block 13
    %%%%%:  652-block 14
    %%%%%:  652-block 15
    %%%%%:  652-block 16
    %%%%%:  652-block 17
    %%%%%:  652-block 18
    %%%%%:  652-block 19
    %%%%%:  652-block 20
    %%%%%:  652-block 21
    %%%%%:  652-block 22
    %%%%%:  652-block 23
    %%%%%:  652-block 24
    %%%%%:  652-block 25
    %%%%%:  652-block 26
    %%%%%:  652-block 27
    %%%%%:  652-block 28
    %%%%%:  652-block 29
    %%%%%:  652-block 30
    %%%%%:  652-block 31
    %%%%%:  652-block 32
    %%%%%:  652-block 33
    %%%%%:  652-block 34
    %%%%%:  652-block 35
    %%%%%:  652-block 36
    %%%%%:  652-block 37
    %%%%%:  652-block 38
    %%%%%:  652-block 39
    %%%%%:  652-block 40
    %%%%%:  652-block 41
    %%%%%:  652-block 42
    %%%%%:  652-block 43
    %%%%%:  652-block 44
    %%%%%:  652-block 45
    %%%%%:  652-block 46
    %%%%%:  652-block 47
    #####:  653:        y = CLAMP(y, height);
    %%%%%:  653-block  0
    %%%%%:  653-block  1
    %%%%%:  653-block  2
    %%%%%:  653-block  3
    %%%%%:  653-block  4
    %%%%%:  653-block  5
    %%%%%:  653-block  6
    %%%%%:  653-block  7
    %%%%%:  653-block  8
    %%%%%:  653-block  9
    %%%%%:  653-block 10
    %%%%%:  653-block 11
    %%%%%:  653-block 12
    %%%%%:  653-block 13
    %%%%%:  653-block 14
    %%%%%:  653-block 15
    %%%%%:  653-block 16
    %%%%%:  653-block 17
    %%%%%:  653-block 18
    %%%%%:  653-block 19
    %%%%%:  653-block 20
    %%%%%:  653-block 21
    %%%%%:  653-block 22
    %%%%%:  653-block 23
    %%%%%:  653-block 24
    %%%%%:  653-block 25
    %%%%%:  653-block 26
    %%%%%:  653-block 27
    %%%%%:  653-block 28
    %%%%%:  653-block 29
    %%%%%:  653-block 30
    %%%%%:  653-block 31
    %%%%%:  653-block 32
    %%%%%:  653-block 33
        -:  654:
    #####:  655:        return x * xstride + y * ystride;
    %%%%%:  655-block  0
    %%%%%:  655-block  1
    %%%%%:  655-block  2
    %%%%%:  655-block  3
    %%%%%:  655-block  4
    %%%%%:  655-block  5
    %%%%%:  655-block  6
    %%%%%:  655-block  7
    %%%%%:  655-block  8
    %%%%%:  655-block  9
    %%%%%:  655-block 10
    %%%%%:  655-block 11
    %%%%%:  655-block 12
    %%%%%:  655-block 13
    %%%%%:  655-block 14
    %%%%%:  655-block 15
    %%%%%:  655-block 16
    %%%%%:  655-block 17
    %%%%%:  655-block 18
    %%%%%:  655-block 19
    %%%%%:  655-block 20
    %%%%%:  655-block 21
    %%%%%:  655-block 22
    %%%%%:  655-block 23
    %%%%%:  655-block 24
    %%%%%:  655-block 25
    %%%%%:  655-block 26
    %%%%%:  655-block 27
    %%%%%:  655-block 28
    %%%%%:  655-block 29
    %%%%%:  655-block 30
        -:  656:    }
        -:  657:
        -:  658:    /**
        -:  659:     * @brief getAddress calculates a memory address from (x, y, t)
        -:  660:     * @param x is the horizontal coordinate in pixels
        -:  661:     * @param y is the vertical coordinate in pixels
        -:  662:     * @param t is the temporal coordinate in pixels
        -:  663:     * @return This function returns the memory address for (x, y, t)
        -:  664:     */
        -:  665:    int getAddress(int x, int y, int t)
        -:  666:    {
        -:  667:        x = CLAMP(x, width);
        -:  668:        y = CLAMP(y, height);
        -:  669:        t = CLAMP(t, frames);
        -:  670:
        -:  671:        return x * xstride + y * ystride + t * tstride;
        -:  672:    }
        -:  673:
        -:  674:    /**
        -:  675:     * @brief reverseAddress computes (x, y) given a memory address
        -:  676:     * @param ind is the memory input address
        -:  677:     * @param x is the output horizontal coordinate for ind
        -:  678:     * @param y is the output vertical coordinate for ind
        -:  679:     */
        -:  680:    void reverseAddress(int ind, int &x, int &y)
        -:  681:    {
        -:  682:        ind = ind / channels;
        -:  683:        y   = ind / width;
        -:  684:        x   = ind - (y * width);
        -:  685:    }
        -:  686:
        -:  687:    /**
        -:  688:     * @brief allocateSimilarOne creates an Image with similar size
        -:  689:     * of the calling instance.
        -:  690:     * @return This returns an Image with the same size of the calling instance.
        -:  691:     */
        -:  692:    Image *allocateSimilarOne();
        -:  693:
        -:  694:    /**
        -:  695:     * @brief allocateSimilarTo allocate an Image with similar size
        -:  696:     * of the passed by.
        -:  697:     */
        -:  698:    void allocateSimilarTo(Image *img);
        -:  699:
        -:  700:    /**
        -:  701:     * @brief Clone creates a deep copy of the calling instance.
        -:  702:     * @return This returns a deep copy of the calling instance.
        -:  703:     */
        -:  704:    Image *clone() const;
        -:  705:
        -:  706:    /**
        -:  707:     * @brief Read opens an Image from a file on the disk.
        -:  708:     * @param nameFile is the file name.
        -:  709:     * @param typeLoad is an option for LDR images only:
        -:  710:     * LT_NOR means that the input image values will be normalized in [0,1].
        -:  711:     * LT_NOR_GAMMA means that the input image values will be normalized in [0,1], and
        -:  712:     * gamma correction 2.2 will be removed.
        -:  713:     * LT_NONE means that image values are not modified.
        -:  714:     *
        -:  715:     * The default is LT_NOR_GAMMA assuming that
        -:  716:     * we are storing normalized and linearized values in Image.
        -:  717:     *
        -:  718:     * @return This returns true if the reading succeeds, false otherwise.
        -:  719:     */
        -:  720:    bool Read (std::string nameFile, LDR_type typeLoad);
        -:  721:
        -:  722:    /**
        -:  723:     * @brief Write saves an Image into a file on the disk.
        -:  724:     * @param nameFile is the file name.
        -:  725:     * @param typeWrite is an option for LDR images only:
        -:  726:     * LT_NOR means that Image ha normalized values and the output image
        -:  727:     * values will be multiplied by 255 to have values in [0,255].
        -:  728:     * LT_NOR_GAMMA means that Image ha normalized and linearized values. The output image
        -:  729:     * values will be gamma corrected (2.2) and multiplied by 255 to have values in [0,255].
        -:  730:     * LT_NONE means that Image values are the same of the output.
        -:  731:     *
        -:  732:     * The default is LT_NOR_GAMMA assuming that
        -:  733:     * we are storing normalized and linearized values in Image.
        -:  734:     *
        -:  735:     * @param writerCounter is the frame that we want to write on the disk in the case Image is a video.
        -:  736:     * The default writerCounter value is 0.
        -:  737:     * @return This returns true if the writing succeeds, false otherwise.
        -:  738:     */
        -:  739:    bool Write(std::string nameFile, LDR_type typeWrite, int writerCounter);
        -:  740:
        -:  741:
        -:  742:    /**
        -:  743:     * @brief changeOwnership
        -:  744:     * @param notOwned
        -:  745:     */
        -:  746:    void changeOwnership(bool notOwned)
        -:  747:    {
        -:  748:        this->notOwned = notOwned;
        -:  749:    }
        -:  750:
        -:  751:    /**
        -:  752:     * @brief operator =
        -:  753:     * @param a
        -:  754:     */
        -:  755:    void operator =(const Image &a);
        -:  756:
        -:  757:    /**
        -:  758:     * @brief operator =
        -:  759:     * @param a
        -:  760:     */
        -:  761:    void operator =(const float &a);
        -:  762:
        -:  763:    /**
        -:  764:     * @brief operator +=
        -:  765:     * @param a
        -:  766:     */
        -:  767:    void operator +=(const float &a);
        -:  768:
        -:  769:    /**
        -:  770:     * @brief operator +
        -:  771:     * @param a
        -:  772:     * @return it returns (this + a)
        -:  773:     */
        -:  774:    Image operator +(const float &a) const;
        -:  775:
        -:  776:    /**
        -:  777:     * @brief operator +=
        -:  778:     * @param a
        -:  779:     */
        -:  780:    void operator +=(const Image &a);
        -:  781:
        -:  782:    /**
        -:  783:     * @brief operator +
        -:  784:     * @param a
        -:  785:     * @return it returns (this + a)
        -:  786:     */
        -:  787:    Image operator +(const Image &a) const;
        -:  788:
        -:  789:    /**
        -:  790:     * @brief operator *=
        -:  791:     * @param a
        -:  792:     */
        -:  793:    void operator *=(const float &a);
        -:  794:
        -:  795:    /**
        -:  796:     * @brief operator *
        -:  797:     * @param a
        -:  798:     * @return it returns (this * a)
        -:  799:     */
        -:  800:    Image operator *(const float &a) const;
        -:  801:
        -:  802:    /**
        -:  803:     * @brief operator *=
        -:  804:     * @param a
        -:  805:     */
        -:  806:    void operator *=(const Image &a);
        -:  807:
        -:  808:    /**
        -:  809:     * @brief operator *
        -:  810:     * @param a
        -:  811:     * @return it returns (this * a)
        -:  812:     */
        -:  813:    Image operator *(const Image &a) const;
        -:  814:
        -:  815:    /**
        -:  816:     * @brief operator -=
        -:  817:     * @param a
        -:  818:     */
        -:  819:    void operator -=(const float &a);
        -:  820:
        -:  821:    /**
        -:  822:     * @brief operator -
        -:  823:     * @param a
        -:  824:     * @return it returns (this - a)
        -:  825:     */
        -:  826:    Image operator -(const float &a) const;
        -:  827:
        -:  828:    /**
        -:  829:     * @brief operator -=
        -:  830:     * @param a
        -:  831:     */
        -:  832:    void operator -=(const Image &a);
        -:  833:
        -:  834:    /**
        -:  835:     * @brief operator -
        -:  836:     * @param a
        -:  837:     * @return it returns (this - a)
        -:  838:     */
        -:  839:    Image operator -(const Image &a) const;
        -:  840:
        -:  841:    /**
        -:  842:     * @brief operator /=
        -:  843:     * @param a
        -:  844:     */
        -:  845:    void operator /=(const float &a);
        -:  846:
        -:  847:    /**
        -:  848:     * @brief operator /
        -:  849:     * @param a
        -:  850:     * @return it returns (this / a)
        -:  851:     */
        -:  852:    Image operator /(const float &a) const;
        -:  853:
        -:  854:    /**
        -:  855:     * @brief operator /=
        -:  856:     * @param a
        -:  857:     */
        -:  858:    void operator /=(const Image &a);
        -:  859:
        -:  860:    /**
        -:  861:     * @brief operator /
        -:  862:     * @param a
        -:  863:     * @return it returns (this / a)
        -:  864:     */
        -:  865:    Image operator /(const Image &a) const;
        -:  866:
        -:  867:    /**
        -:  868:     * @brief sort
        -:  869:     * @return
        -:  870:     */
        -:  871:    float *sort()
        -:  872:    {
        -:  873:        if(!isValid()) {
        -:  874:            return NULL;
        -:  875:        }
        -:  876:
        -:  877:        int size_i = size();
        -:  878:        float *tmp = new float[size_i];
        -:  879:        memcpy(tmp, data, sizeof(float) * size_i);
        -:  880:        std::sort(tmp, tmp + size_i);
        -:  881:        return tmp;
        -:  882:    }
        -:  883:};
        -:  884:
       11:  885:PIC_INLINE void Image::setNULL()
        -:  886:{
       11:  887:    nameFile = "";
       11:  887-block  0
       11:  888:    notOwned = false;
        -:  889:
       11:  890:    alpha = -1;
       11:  891:    tstride = -1;
       11:  892:    ystride = -1;
       11:  893:    xstride = -1;
       11:  894:    width = -1;
       11:  895:    height = -1;
       11:  896:    frames = -1;
       11:  897:    depth = -1;
       11:  898:    channels = -1;
        -:  899:
       11:  900:    channelsf = -1.0f;
       11:  901:    widthf = -1.0f;
       11:  902:    heightf = -1.0f;
       11:  903:    width1f = -1.0f;
       11:  904:    height1f = -1.0f;
       11:  905:    framesf = -1.0f;
       11:  906:    frames1f = -1.0f;
        -:  907:
       11:  908:    data = NULL;
       11:  909:    dataUC = NULL;
       11:  910:    dataRGBE = NULL;
       11:  911:    typeLoad = LT_NONE;
        -:  912:
        -:  913:#ifdef PIC_ENABLE_OPEN_EXR
        -:  914:    dataEXR = NULL;
        -:  915:#endif
        -:  916:
       11:  917:    flippedEXR = false;
        -:  918:
       11:  919:    readerCounter = 0;
       11:  920:    exposure = 1.0f;
       11:  921:}
        -:  922:
        7:  923:PIC_INLINE Image::Image()
        7:  923-block  0
    $$$$$:  923-block  1
        -:  924:{
        7:  925:    setNULL();
        7:  925-block  0
        7:  926:}
        7:  926-block  0
        -:  927:
    #####:  928:PIC_INLINE Image::Image(Image *imgIn, bool deepCopy = true)
    %%%%%:  928-block  0
    $$$$$:  928-block  1
        -:  929:{
    #####:  930:    setNULL();
    %%%%%:  930-block  0
        -:  931:    
    #####:  932:    if(imgIn == NULL) {
    %%%%%:  932-block  0
        -:  933:        return;
        -:  934:    }
        -:  935:
    #####:  936:    if(deepCopy) {
    %%%%%:  936-block  0
    #####:  937:        assign(imgIn);
    %%%%%:  937-block  0
        -:  938:    } else {
    #####:  939:        width = imgIn->width;
    #####:  940:        height = imgIn->height;
    #####:  941:        channels = imgIn->channels;
    #####:  942:        frames = imgIn->frames;
        -:  943:
    #####:  944:        widthf = imgIn->widthf;
    #####:  945:        heightf = imgIn->heightf;
    #####:  946:        channelsf = imgIn->channelsf;
    #####:  947:        framesf = imgIn->framesf;
        -:  948:
    #####:  949:        data = imgIn->data;
        -:  950:
    #####:  951:        notOwned = true;
    #####:  952:        exposure = imgIn->exposure;
    #####:  953:        nameFile = imgIn->nameFile;
    %%%%%:  953-block  0
    #####:  954:        flippedEXR = imgIn->flippedEXR;
    #####:  955:        typeLoad = imgIn->typeLoad;
        -:  956:
    #####:  957:        allocateAux();
    %%%%%:  957-block  0
        -:  958:    }
        -:  959:
        -:  960:}
        -:  961:
        -:  962:PIC_INLINE Image::Image(int width, int height, int channels = 3)
        -:  963:{
        -:  964:    setNULL();
        -:  965:    allocate(width, height, channels, 1);
        -:  966:}
        -:  967:
        4:  968:PIC_INLINE Image::Image(int frames, int width, int height, int channels,
        4:  969:                        float *data = NULL)
        4:  969-block  0
    $$$$$:  969-block  1
        -:  970:{
        4:  971:    setNULL();
        4:  971-block  0
        -:  972:
        4:  973:    if(data == NULL) {
        4:  973-block  0
        4:  974:        allocate(width, height, channels, frames);
        4:  974-block  0
        -:  975:    } else {
    #####:  976:        this->frames   = frames;
    #####:  977:        this->channels = channels;
    #####:  978:        this->width    = width;
    #####:  979:        this->height   = height;
    #####:  980:        this->notOwned = true;
    #####:  981:        this->data = data;
        -:  982:
    #####:  983:        allocateAux();
    %%%%%:  983-block  0
        -:  984:    }
        4:  985:}
        4:  985-block  0
        -:  986:
        -:  987:PIC_INLINE Image::Image(std::string nameFile, LDR_type typeLoad = LT_NOR_GAMMA)
        -:  988:{
        -:  989:    setNULL();
        -:  990:    Read(nameFile, typeLoad);
        -:  991:}
        -:  992:
        -:  993:PIC_INLINE Image::Image(float *color, int channels)
        -:  994:{
        -:  995:    typeLoad = LT_NONE;
        -:  996:    setNULL();
        -:  997:
        -:  998:    if(color != NULL) {
        -:  999:        allocate(1, 1, channels, 1);
        -: 1000:        memcpy(data, color, channels);
        -: 1001:    }
        -: 1002:}
        -: 1003:
       11: 1004:PIC_INLINE Image::~Image()
        -: 1005:{
       11: 1006:    release();
       11: 1006-block  0
       11: 1007:}
        -: 1008:
       11: 1009:PIC_INLINE void Image::release()
        -: 1010:{
        -: 1011:    //release all allocated resources
       11: 1012:    if(!notOwned) {
       11: 1012-block  0
       22: 1013:        data = delete_vec_s(data);
       11: 1013-block  0
       11: 1013-block  1
        -: 1014:    }
        -: 1015:
       11: 1016:    dataUC = delete_vec_s(dataUC);
       11: 1016-block  0
       11: 1017:    dataRGBE = delete_vec_s(dataRGBE);
       11: 1017-block  0
        -: 1018:
        -: 1019:    #ifdef PIC_ENABLE_OPEN_EXR
        -: 1020:        delete_vec_s(dataEXR);
        -: 1021:    #endif
       11: 1022:}
        -: 1023:
        4: 1024:PIC_INLINE void Image::allocate(int width, int height, int channels, int frames)
        -: 1025:{
        4: 1026:    if(width < 1 || height < 1 || channels < 1 || frames < 1) {
        4: 1026-block  0
        4: 1026-block  1
        -: 1027:        #ifdef PIC_DEBUG
        -: 1028:            printf("Image::Allocate: not a valid image to be allocated.\n");
        -: 1029:        #endif
        -: 1030:        return;
        -: 1031:    }
        -: 1032:
       4*: 1033:    if(this->width > 0 && this->height > 0 && this->channels > 0 &&
        4: 1033-block  0
    %%%%%: 1033-block  1
    %%%%%: 1033-block  2
    #####: 1034:       this->frames > 0 && data != NULL) {
    %%%%%: 1034-block  0
    %%%%%: 1034-block  1
        -: 1035:        #ifdef PIC_DEBUG
        -: 1036:            printf("Image::Allocate: already allocated image.\n");
        -: 1037:        #endif
        -: 1038:        return;
        -: 1039:    }
        -: 1040:
        4: 1041:    this->frames = frames;
        4: 1042:    this->channels = channels;
        4: 1043:    this->width = width;
        4: 1044:    this->height = height;
        4: 1045:    this->notOwned = false;
        -: 1046:
        4: 1047:    data = new float [size()];
        4: 1047-block  0
        -: 1048:
        4: 1049:    allocateAux();
        -: 1050:}
        -: 1051:
       11: 1052:PIC_INLINE void Image::allocateAux()
        -: 1053:{
       11: 1054:    this->fullBox = getFullBox();
        -: 1055:
       11: 1056:    this->depth    = frames;
       11: 1057:    this->widthf   = float(width);
       11: 1058:    this->width1f  = float(width - 1);
       11: 1059:    this->heightf  = float(height);
       11: 1060:    this->height1f = float(height - 1);
       11: 1061:    this->channelsf = float(channels);
       11: 1062:    this->framesf  = float(frames);
       11: 1063:    this->frames1f = float(frames -1);
        -: 1064:
       11: 1065:    calculateStrides();
       11: 1066:}
        -: 1067:
       11: 1068:PIC_INLINE BBox Image::getFullBox()
        -: 1069:{
       11: 1070:    BBox fullBox;
       11: 1071:    fullBox.setBox(0, width, 0, height, 0, frames, width,
        -: 1072:                             height, frames);
        -: 1073:
       11: 1074:    return fullBox;
        -: 1075:}
        -: 1076:
        1: 1077:PIC_INLINE void Image::assign(const Image *imgIn)
        -: 1078:{
        1: 1079:    if(imgIn == NULL) {
        1: 1079-block  0
        -: 1080:        return;
        -: 1081:    }
        -: 1082:
       2*: 1083:    if(!isSimilarType(imgIn)) {
    #####: 1084:        release();
    #####: 1085:        allocate(imgIn->width, imgIn->height, imgIn->channels, imgIn->frames);
        -: 1086:    }
        -: 1087:
        1: 1088:    exposure = imgIn->exposure;
        2: 1089:    nameFile = imgIn->nameFile;
        1: 1090:    typeLoad = imgIn->typeLoad;
        1: 1091:    flippedEXR = imgIn->flippedEXR;
        -: 1092:
        1: 1093:    memcpy(data, imgIn->data, size() * sizeof(float));
        -: 1094:}
        -: 1095:
    #####: 1096:PIC_INLINE void Image::clamp(float a = 0.0f, float b = 1.0f)
        -: 1097:{
    #####: 1098:    int size_i = size();
        -: 1099:
    #####: 1100:    #pragma omp parallel for
        -: 1101:    for(int i = 0; i < size_i; i++) {
        -: 1102:        data[i] = CLAMPi(data[i], a, b);
        -: 1103:    }
    #####: 1104:}
        -: 1105:
        1: 1106:PIC_INLINE void Image::removeSpecials()
        -: 1107:{
        1: 1108:    int size_i = size();
        -: 1109:
        1: 1110:    #pragma omp parallel for
        -: 1111:    for(int i = 0; i < size_i; i++) {
        -: 1112:        float val = data[i];
        -: 1113:
        -: 1114:        if(isnan(val) || isinf(val)) {
        -: 1115:            data[i] = 0.0f;
        -: 1116:        }
        -: 1117:    }
        1: 1118:}
        -: 1119:
       9*: 1120:PIC_INLINE bool Image::isSimilarType(const Image *img)
        -: 1121:{
       6*: 1122:    if(img == NULL) {
    %%%%%: 1122-block  0
    %%%%%: 1122-block  1
    %%%%%: 1122-block  2
        6: 1122-block  3
        -: 1123:        return false;
        -: 1124:    }
        -: 1125:
       8*: 1126:    bool ret =	(width      ==  img->width) &&
    %%%%%: 1126-block  0
    %%%%%: 1126-block  1
    %%%%%: 1126-block  2
    %%%%%: 1126-block  3
    %%%%%: 1126-block  4
        1: 1126-block  5
    %%%%%: 1126-block  6
    %%%%%: 1126-block  7
    %%%%%: 1126-block  8
    %%%%%: 1126-block  9
    %%%%%: 1126-block 10
    %%%%%: 1126-block 11
    %%%%%: 1126-block 12
    %%%%%: 1126-block 13
    %%%%%: 1126-block 14
    %%%%%: 1126-block 15
    %%%%%: 1126-block 16
    %%%%%: 1126-block 17
        6: 1126-block 18
    %%%%%: 1126-block 19
        1: 1126-block 20
        -: 1127:                (height     ==  img->height) &&
       9*: 1128:                (frames     ==  img->frames) &&
    %%%%%: 1128-block  0
    %%%%%: 1128-block  1
    %%%%%: 1128-block  2
    %%%%%: 1128-block  3
    %%%%%: 1128-block  4
    %%%%%: 1128-block  5
    %%%%%: 1128-block  6
    %%%%%: 1128-block  7
    %%%%%: 1128-block  8
        6: 1128-block  9
        1: 1128-block 10
    %%%%%: 1128-block 11
        1: 1128-block 12
    %%%%%: 1128-block 13
        1: 1128-block 14
       7*: 1129:                (channels   ==  img->channels) &&
    %%%%%: 1129-block  0
    %%%%%: 1129-block  1
    %%%%%: 1129-block  2
    %%%%%: 1129-block  3
    %%%%%: 1129-block  4
    %%%%%: 1129-block  5
    %%%%%: 1129-block  6
    %%%%%: 1129-block  7
    %%%%%: 1129-block  8
        6: 1129-block  9
        1: 1129-block 10
       7*: 1130:                (flippedEXR ==  img->flippedEXR);
    %%%%%: 1130-block  0
    %%%%%: 1130-block  1
    %%%%%: 1130-block  2
    %%%%%: 1130-block  3
    %%%%%: 1130-block  4
    %%%%%: 1130-block  5
    %%%%%: 1130-block  6
    %%%%%: 1130-block  7
    %%%%%: 1130-block  8
        6: 1130-block  9
    %%%%%: 1130-block 10
    %%%%%: 1130-block 11
    %%%%%: 1130-block 12
    %%%%%: 1130-block 13
        1: 1130-block 14
        -: 1131:
        -: 1132:#ifdef PIC_DEBUG
        -: 1133:
        -: 1134:    if(!ret) {
        -: 1135:        printf("\nImage::isSimilarType: ERROR The two compared images are not similar.\n");
        -: 1136:    }
        -: 1137:
        -: 1138:#endif
        -: 1139:
        -: 1140:    return ret;
        -: 1141:}
        -: 1142:
      40*: 1143:PIC_INLINE bool Image::isValid()
        -: 1144:{
      40*: 1145:    return (width > 0) && (height > 0) && (channels > 0) && (frames > 0) &&
        1: 1145-block  0
        1: 1145-block  1
        1: 1145-block  2
        1: 1145-block  3
    %%%%%: 1145-block  4
    %%%%%: 1145-block  5
    %%%%%: 1145-block  6
    %%%%%: 1145-block  7
    %%%%%: 1145-block  8
    %%%%%: 1145-block  9
    %%%%%: 1145-block 10
    %%%%%: 1145-block 11
    %%%%%: 1145-block 12
    %%%%%: 1145-block 13
    %%%%%: 1145-block 14
    %%%%%: 1145-block 15
    %%%%%: 1145-block 16
    %%%%%: 1145-block 17
    %%%%%: 1145-block 18
    %%%%%: 1145-block 19
    %%%%%: 1145-block 20
    %%%%%: 1145-block 21
    %%%%%: 1145-block 22
    %%%%%: 1145-block 23
    %%%%%: 1145-block 24
    %%%%%: 1145-block 25
    %%%%%: 1145-block 26
    %%%%%: 1145-block 27
    %%%%%: 1145-block 28
    %%%%%: 1145-block 29
    %%%%%: 1145-block 30
    %%%%%: 1145-block 31
        7: 1145-block 32
        7: 1145-block 33
        7: 1145-block 34
        7: 1145-block 35
       21: 1145-block 36
       21: 1145-block 37
       21: 1145-block 38
       21: 1145-block 39
        5: 1145-block 40
        5: 1145-block 41
        5: 1145-block 42
        5: 1145-block 43
    %%%%%: 1145-block 44
    %%%%%: 1145-block 45
    %%%%%: 1145-block 46
        2: 1145-block 47
        2: 1145-block 48
        2: 1145-block 49
        2: 1145-block 50
        2: 1145-block 51
        2: 1145-block 52
    %%%%%: 1145-block 53
    %%%%%: 1145-block 54
    %%%%%: 1145-block 55
    %%%%%: 1145-block 56
    %%%%%: 1145-block 57
    %%%%%: 1145-block 58
    %%%%%: 1145-block 59
    %%%%%: 1145-block 60
    %%%%%: 1145-block 61
    %%%%%: 1145-block 62
    %%%%%: 1145-block 63
    %%%%%: 1145-block 64
        1: 1145-block 65
        1: 1145-block 66
        1: 1145-block 67
        1: 1145-block 68
        1: 1145-block 69
        1: 1145-block 70
    %%%%%: 1145-block 71
    %%%%%: 1145-block 72
    %%%%%: 1145-block 73
    %%%%%: 1145-block 74
    %%%%%: 1145-block 75
    %%%%%: 1145-block 76
    %%%%%: 1145-block 77
    %%%%%: 1145-block 78
    %%%%%: 1145-block 79
    %%%%%: 1145-block 80
    %%%%%: 1145-block 81
    %%%%%: 1145-block 82
      40*: 1146:           (data != NULL);
        1: 1146-block  0
    %%%%%: 1146-block  1
    %%%%%: 1146-block  2
    %%%%%: 1146-block  3
    %%%%%: 1146-block  4
    %%%%%: 1146-block  5
    %%%%%: 1146-block  6
    %%%%%: 1146-block  7
        7: 1146-block  8
       21: 1146-block  9
        5: 1146-block 10
    %%%%%: 1146-block 11
        2: 1146-block 12
        2: 1146-block 13
    %%%%%: 1146-block 14
    %%%%%: 1146-block 15
    %%%%%: 1146-block 16
    %%%%%: 1146-block 17
        1: 1146-block 18
        1: 1146-block 19
    %%%%%: 1146-block 20
    %%%%%: 1146-block 21
    %%%%%: 1146-block 22
    %%%%%: 1146-block 23
        -: 1147:}
        -: 1148:
        -: 1149:PIC_INLINE void Image::copySubImage(Image *imgIn, int startX, int startY)
        -: 1150:{
        -: 1151:    Buffer<float>::copySubBuffer(imgIn->data, imgIn->width, imgIn->height, imgIn->channels,
        -: 1152:                                 startX, startY,
        -: 1153:                                 data, width, height, channels);
        -: 1154:}
        -: 1155:
        -: 1156:PIC_INLINE void Image::scaleCosine()
        -: 1157:{
        -: 1158:    int half_h = height >> 1;
        -: 1159:
        -: 1160:    #pragma omp parallel for
        -: 1161:    for(int i = 0; i < height; i++) {
        -: 1162:        float angle  = C_PI * float(i - half_h) / float(height);
        -: 1163:        float cosAng = MAX(cosf(angle), 0.0f);
        -: 1164:
        -: 1165:        for(int j = 0; j < width; j++) {
        -: 1166:            float *tmp_data = (*this)(j, i);
        -: 1167:
        -: 1168:            for(int k = 0; k < channels; k++) {
        -: 1169:                tmp_data[k] *= cosAng;
        -: 1170:            }
        -: 1171:        }
        -: 1172:    }
        -: 1173:}
        -: 1174:
    #####: 1175:PIC_INLINE void Image::applyFunction(float(*func)(float))
        -: 1176:{
    #####: 1177:    if(!isValid()) {
    %%%%%: 1177-block  0
        -: 1178:        return;
        -: 1179:    }
        -: 1180:
    #####: 1181:    int size_i = size();
        -: 1182:
    #####: 1183:    #pragma omp parallel for
    %%%%%: 1183-block  0
        -: 1184:    for(int i = 0; i < size_i; i++) {
        -: 1185:        data[i] = (*func)(data[i]);
        -: 1186:    }
        -: 1187:}
        -: 1188:
    #####: 1189:PIC_INLINE void Image::applyFunctionParam(float(*func)(float, std::vector<float>&), std::vector<float> &param)
        -: 1190:{
    #####: 1191:    if(!isValid()) {
    %%%%%: 1191-block  0
        -: 1192:        return;
        -: 1193:    }
        -: 1194:
    #####: 1195:    int size_i = size();
        -: 1196:
    #####: 1197:    #pragma omp parallel for
    %%%%%: 1197-block  0
        -: 1198:    for(int i = 0; i < size_i; i++) {
        -: 1199:        data[i] = (*func)(data[i], param);
        -: 1200:    }
        -: 1201:}
        -: 1202:
    #####: 1203:PIC_INLINE float *Image::getPercentileVal(float percentile, BBox *box, float *ret)
        -: 1204:{
    #####: 1205:    if(!isValid()) {
    %%%%%: 1205-block  0
        -: 1206:        return ret;
        -: 1207:    }
        -: 1208:
    #####: 1209:    if(box == NULL) {
    %%%%%: 1209-block  0
    #####: 1210:        box = &fullBox;
    %%%%%: 1210-block  0
        -: 1211:    }
        -: 1212:
    #####: 1213:    if(ret == NULL) {
    %%%%%: 1213-block  0
    #####: 1214:        ret = new float[channels << 1];
    %%%%%: 1214-block  0
    %%%%%: 1214-block  1
    %%%%%: 1214-block  2
        -: 1215:    }
        -: 1216:
    #####: 1217:    int size_i = box->Size();
    %%%%%: 1217-block  0
    #####: 1218:    float *dataTMP = new float[size_i];
    %%%%%: 1218-block  0
    %%%%%: 1218-block  1
        -: 1219:
    #####: 1220:    for(int ch = 0; ch < channels; ch++) {
    %%%%%: 1220-block  0
    %%%%%: 1220-block  1
    #####: 1221:        int counter = 0;
    #####: 1222:        for(int k = box->z0; k < box->z1; k++) {
    %%%%%: 1222-block  0
    %%%%%: 1222-block  1
    %%%%%: 1222-block  2
    #####: 1223:            for(int j = box->y0; j < box->y1; j++) {
    %%%%%: 1223-block  0
    %%%%%: 1223-block  1
    %%%%%: 1223-block  2
    #####: 1224:                for(int i = box->x0; i < box->x1; i++) {
    %%%%%: 1224-block  0
    %%%%%: 1224-block  1
    #####: 1225:                    dataTMP[counter] = (*this)(i, j, k)[ch];
    #####: 1226:                    counter++;
    %%%%%: 1226-block  0
        -: 1227:                }
        -: 1228:            }
        -: 1229:        }
        -: 1230:
    #####: 1231:        std::sort(dataTMP, dataTMP + size_i);
    %%%%%: 1231-block  0
        -: 1232:
    #####: 1233:        int size_i_t = size_i - 1;
    #####: 1234:        int index_r = ch << 1;
        -: 1235:
    #####: 1236:        float index_f;
    #####: 1237:        int index;
        -: 1238:
    #####: 1239:        float size_i_t_f = float(size_i_t);
        -: 1240:
    #####: 1241:        index_f = percentile * size_i_t_f;
    #####: 1242:        index = CLAMPi(int(index_f), 0, size_i_t);
    %%%%%: 1242-block  0
    #####: 1243:        ret[index_r    ] = dataTMP[index];
        -: 1244:
    #####: 1245:        index_f = (1.0f - percentile) * size_i_t_f;
    #####: 1246:        index = CLAMPi(int(index_f), 0, size_i_t);
    %%%%%: 1246-block  0
    %%%%%: 1246-block  1
    #####: 1247:        ret[index_r + 1] = dataTMP[index];
    %%%%%: 1247-block  0
        -: 1248:    }
        -: 1249:
    #####: 1250:    delete[] dataTMP;
        -: 1251:
    #####: 1252:    return ret;
    %%%%%: 1252-block  0
        -: 1253:}
        -: 1254:
        -: 1255:PIC_INLINE float *Image::getMedVal(BBox *box, float *ret)
        -: 1256:{
        -: 1257:    return getPercentileVal(0.5f, box, ret);
        -: 1258:}
        -: 1259:
        -: 1260:PIC_INLINE float Image::getDynamicRange(bool bRobust = false, float percentile = 0.99f)
        -: 1261:{
        -: 1262:    if(!isValid()) {
        -: 1263:        return -1.0f;
        -: 1264:    }
        -: 1265:
        -: 1266:    if(bRobust) {
        -: 1267:        if(percentile <= 0.5f) {
        -: 1268:            percentile = 0.99f;
        -: 1269:        }
        -: 1270:
        -: 1271:        float percentile_low = 1.0f - percentile;
        -: 1272:
        -: 1273:        float *values = getPercentileVal(percentile_low, NULL, NULL);
        -: 1274:        float min_val = values[0];
        -: 1275:        float max_val = values[1];
        -: 1276:
        -: 1277:        if(min_val > 0.0f) {
        -: 1278:            return max_val / min_val;
        -: 1279:        } else {
        -: 1280:            if(percentile > 0.5f) {
        -: 1281:                return getDynamicRange(true, percentile * 0.99f);
        -: 1282:            } else {
        -: 1283:                return 0.0f;
        -: 1284:            }
        -: 1285:        }
        -: 1286:    } else {
        -: 1287:        float ret = -1.0f;
        -: 1288:
        -: 1289:        float *min_val_v = getMinVal(NULL, NULL);
        -: 1290:        float *max_val_v = getMaxVal(NULL, NULL);
        -: 1291:
        -: 1292:        int ind;
        -: 1293:        float min_val = Arrayf::getMin(min_val_v, channels, ind);
        -: 1294:        float max_val = Arrayf::getMax(max_val_v, channels, ind);
        -: 1295:
        -: 1296:        if(min_val <= 0.0f) {
        -: 1297:            IntCoord coord;
        -: 1298:            IndexedArray<float>::findSimple(data, size(), IndexedArray<float>::bFuncNotNeg, coord);
        -: 1299:            min_val = IndexedArray<float>::min(data, coord);
        -: 1300:
        -: 1301:            if(min_val != max_val) {
        -: 1302:                if(max_val > min_val) {
        -: 1303:                    ret = max_val / min_val;
        -: 1304:                } else {
        -: 1305:                    ret = -2.0f;
        -: 1306:                }
        -: 1307:            } else {
        -: 1308:                ret = 0.0f;
        -: 1309:            }
        -: 1310:        }
        -: 1311:
        -: 1312:        delete_vec_s(min_val_v);
        -: 1313:        delete_vec_s(max_val_v);
        -: 1314:
        -: 1315:        return ret;
        -: 1316:    }
        -: 1317:}
        -: 1318:
        -: 1319:PIC_INLINE void Image::blend(Image *img, Image *weight)
        -: 1320:{
        -: 1321:    if(img == NULL || weight == NULL) {
        -: 1322:        return;
        -: 1323:    }
        -: 1324:
        -: 1325:    if( (weight->channels != 1) &&
        -: 1326:        (weight->channels != img->channels)) {
        -: 1327:        return;
        -: 1328:    }
        -: 1329:
        -: 1330:    int size = height * width;
        -: 1331:
        -: 1332:    #pragma omp parallel for
        -: 1333:    for(int ind = 0; ind < size; ind++) {
        -: 1334:        int i = ind * channels;
        -: 1335:
        -: 1336:        int indx_w = ind * weight->channels;
        -: 1337:        //int indx_w = i_w;// + (j % weight->channels);
        -: 1338:        float w0 = weight->data[indx_w];
        -: 1339:        float w1 = 1.0f - w0;
        -: 1340:
        -: 1341:        for(int j = 0; j < channels; j++) {
        -: 1342:            int indx = i + j;
        -: 1343:
        -: 1344:            data[indx] = data[indx] * w0 + img->data[indx] * w1;
        -: 1345:        }
        -: 1346:    }
        -: 1347:}
        -: 1348:
        -: 1349:PIC_INLINE void Image::minimum(Image *img)
        -: 1350:{
        -: 1351:    if(!isValid() || !isSimilarType(img)) {
        -: 1352:        return;
        -: 1353:    }
        -: 1354:
        -: 1355:    int n = size();
        -: 1356:
        -: 1357:    #pragma omp parallel for
        -: 1358:
        -: 1359:    for(int i = 0; i < n; i++) {
        -: 1360:        data[i] = data[i] > img->data[i] ? img->data[i] : data[i];
        -: 1361:    }
        -: 1362:}
        -: 1363:
        -: 1364:PIC_INLINE void Image::maximum(Image *img)
        -: 1365:{
        -: 1366:    if(!isValid() || !isSimilarType(img)) {
        -: 1367:        return;
        -: 1368:    }
        -: 1369:
        -: 1370:    int n = size();
        -: 1371:
        -: 1372:    #pragma omp parallel for
        -: 1373:    for(int i = 0; i < n; i++) {
        -: 1374:        data[i] = data[i] < img->data[i] ? img->data[i] : data[i];
        -: 1375:    }
        -: 1376:}
        -: 1377:
    #####: 1378:PIC_INLINE void Image::setZero()
        -: 1379:{
    #####: 1380:    if(!isValid()) {
    %%%%%: 1380-block  0
        -: 1381:        return;
        -: 1382:    }
        -: 1383:
    #####: 1384:    Buffer<float>::assign(data, size(), 0.0f);
    %%%%%: 1384-block  0
        -: 1385:}
        -: 1386:
        -: 1387:PIC_INLINE void Image::setRand(unsigned int seed = 1)
        -: 1388:{
        -: 1389:    if(!isValid()) {
        -: 1390:        return;
        -: 1391:    }
        -: 1392:
        -: 1393:    std::mt19937 m(seed);
        -: 1394:    int n = size();
        -: 1395:
        -: 1396:    for(int i = 0; i < n; i++) {
        -: 1397:        data[i] = float(m()) / 4294967295.0f;
        -: 1398:    }
        -: 1399:}
        -: 1400:
        1: 1401:PIC_INLINE float *Image::getMaxVal(BBox *box = NULL, float *ret = NULL)
        -: 1402:{
        1: 1403:    if(!isValid()) {
        1: 1403-block  0
        -: 1404:        return ret;
        -: 1405:    }
        -: 1406:
        1: 1407:    if(box == NULL) {
        1: 1407-block  0
        1: 1408:        box = new BBox(width, height, frames);
        1: 1408-block  0
        -: 1409:    }
        -: 1410:
        1: 1411:    if(ret == NULL) {
        1: 1411-block  0
    #####: 1412:        ret = new float[channels];
    %%%%%: 1412-block  0
    %%%%%: 1412-block  1
    %%%%%: 1412-block  2
        -: 1413:    }
        -: 1414:
        2: 1415:    for(int l = 0; l < channels; l++) {
        1: 1415-block  0
        2: 1415-block  1
        1: 1416:        ret[l] = -FLT_MAX;
        1: 1416-block  0
        -: 1417:    }
        -: 1418:
        2: 1419:    for(int k = box->z0; k < box->z1; k++) {
        1: 1419-block  0
        2: 1419-block  1
        1: 1419-block  2
      428: 1420:        for(int j = box->y0; j < box->y1; j++) {
        1: 1420-block  0
      428: 1420-block  1
      427: 1420-block  2
   273707: 1421:            for(int i = box->x0; i < box->x1; i++) {
      427: 1421-block  0
   273707: 1421-block  1
   273280: 1421-block  2
   273280: 1422:                float *tmp_data = (*this)(i, j, k);
        -: 1423:
   546560: 1424:                for(int l = 0; l < channels; l++) {
   273280: 1424-block  0
   546560: 1424-block  1
   273280: 1425:                    ret[l] = ret[l] < tmp_data[l] ? tmp_data[l] : ret[l];
   273280: 1425-block  0
        -: 1426:                }
        -: 1427:            }
        -: 1428:        }
        -: 1429:    }
        -: 1430:
        -: 1431:    return ret;
        -: 1432:}
        -: 1433:
        1: 1434:PIC_INLINE float *Image::getMinVal(BBox *box = NULL, float *ret = NULL)
        -: 1435:{
        1: 1436:    if(!isValid()) {
        1: 1436-block  0
        -: 1437:        return ret;
        -: 1438:    }
        -: 1439:
        1: 1440:    if(box == NULL) {
        1: 1440-block  0
        1: 1441:        box = new BBox(width, height, frames);
        1: 1441-block  0
        -: 1442:    }
        -: 1443:
        1: 1444:    if(ret == NULL) {
        1: 1444-block  0
    #####: 1445:        ret = new float[channels];
    %%%%%: 1445-block  0
    %%%%%: 1445-block  1
    %%%%%: 1445-block  2
        -: 1446:    }
        -: 1447:
        2: 1448:    for(int l = 0; l < channels; l++) {
        1: 1448-block  0
        2: 1448-block  1
        1: 1449:        ret[l] = FLT_MAX;
        1: 1449-block  0
        -: 1450:    }
        -: 1451:
        2: 1452:    for(int k = box->z0; k < box->z1; k++) {
        1: 1452-block  0
        2: 1452-block  1
        1: 1452-block  2
      428: 1453:        for(int j = box->y0; j < box->y1; j++) {
        1: 1453-block  0
      428: 1453-block  1
      427: 1453-block  2
   273707: 1454:            for(int i = box->x0; i < box->x1; i++) {
      427: 1454-block  0
   273707: 1454-block  1
   273280: 1454-block  2
   273280: 1455:                float *tmp_data = (*this)(i, j, k);
        -: 1456:
   546560: 1457:                for(int l = 0; l < channels; l++) {
   273280: 1457-block  0
   546560: 1457-block  1
   273280: 1458:                    ret[l] = ret[l] > tmp_data[l] ? tmp_data[l] : ret[l];
   273280: 1458-block  0
        -: 1459:                }
        -: 1460:            }
        -: 1461:        }
        -: 1462:    }
        -: 1463:
        -: 1464:    return ret;
        -: 1465:}
        -: 1466:
    #####: 1467:PIC_INLINE float *Image::getSumVal(BBox *box = NULL, float *ret = NULL)
        -: 1468:{
    #####: 1469:    if(!isValid()) {
    %%%%%: 1469-block  0
        -: 1470:        return ret;
        -: 1471:    }
        -: 1472:
    #####: 1473:    if(box == NULL) {
    %%%%%: 1473-block  0
    #####: 1474:        box = &fullBox;
    %%%%%: 1474-block  0
        -: 1475:    }
        -: 1476:
    #####: 1477:    if(ret == NULL) {
    %%%%%: 1477-block  0
    #####: 1478:        ret = new float[channels];
    %%%%%: 1478-block  0
        -: 1479:    }
        -: 1480:
    #####: 1481:    Arrayf::assign(0.0f, ret, channels);
    %%%%%: 1481-block  0
        -: 1482:
    #####: 1483:    for(int k = box->z0; k < box->z1; k++) {
    %%%%%: 1483-block  0
    %%%%%: 1483-block  1
    %%%%%: 1483-block  2
    #####: 1484:        for(int j = box->y0; j < box->y1; j++) {
    %%%%%: 1484-block  0
    %%%%%: 1484-block  1
    %%%%%: 1484-block  2
    #####: 1485:            for(int i = box->x0; i < box->x1; i++) {
    %%%%%: 1485-block  0
    %%%%%: 1485-block  1
    #####: 1486:                float *tmp_data = (*this)(i, j, k);
        -: 1487:
    #####: 1488:                Arrayf::add(tmp_data, channels, ret);
    %%%%%: 1488-block  0
    %%%%%: 1488-block  1
        -: 1489:            }
        -: 1490:        }
        -: 1491:    }
        -: 1492:
        -: 1493:    return ret;
        -: 1494:}
        -: 1495:
    #####: 1496:PIC_INLINE float *Image::getMeanVal(BBox *box = NULL, float *ret = NULL)
        -: 1497:{
    #####: 1498:    if(!isValid()) {
    %%%%%: 1498-block  0
        -: 1499:        return ret;
        -: 1500:    }
        -: 1501:
    #####: 1502:    if(box == NULL) {
    %%%%%: 1502-block  0
    #####: 1503:        box = &fullBox;
    %%%%%: 1503-block  0
        -: 1504:    }
        -: 1505:
    #####: 1506:    ret = getSumVal(box, ret);
    %%%%%: 1506-block  0
        -: 1507:
    #####: 1508:    float totf = float(box->Size());
        -: 1509:
    #####: 1510:    Arrayf::div(ret, channels, totf);
        -: 1511:
        -: 1512:    return ret;
        -: 1513:}
        -: 1514:
        -: 1515:PIC_INLINE float *Image::getMomentsVal(int x0, int y0, int radius, float *ret = NULL)
        -: 1516:{
        -: 1517:    if(!isValid()) {
        -: 1518:        return ret;
        -: 1519:    }
        -: 1520:
        -: 1521:    int channels_2 = channels << 1;
        -: 1522:
        -: 1523:    if(ret == NULL) {
        -: 1524:        ret = new float[channels_2];
        -: 1525:    }
        -: 1526:
        -: 1527:    Arrayf::assign(0.0f, ret, channels_2);
        -: 1528:
        -: 1529:    for(int j = -radius; j <= radius; j++) {
        -: 1530:        int y = y0 + j;
        -: 1531:
        -: 1532:        for(int i = -radius; i <= radius; i++) {
        -: 1533:            int x = x0 + i;
        -: 1534:
        -: 1535:            float *tmp_data = (*this)(x, y);
        -: 1536:
        -: 1537:            for(int l = 0; l < channels_2; l += 2) {
        -: 1538:                ret[l    ] += j * tmp_data[l];
        -: 1539:                ret[l + 1] += i * tmp_data[l];
        -: 1540:            }
        -: 1541:        }
        -: 1542:    }
        -: 1543:
        -: 1544:    return ret;
        -: 1545:}
        -: 1546:
    #####: 1547:PIC_INLINE float *Image::getVarianceVal(float *meanVal = NULL,
        -: 1548:                                        BBox *box = NULL,
        -: 1549:                                        float *ret = NULL)
        -: 1550:{
    #####: 1551:    if(!isValid()) {
    %%%%%: 1551-block  0
        -: 1552:        return ret;
        -: 1553:    }
        -: 1554:
    #####: 1555:    if(box == NULL) {
    %%%%%: 1555-block  0
    #####: 1556:        box = &fullBox;
    %%%%%: 1556-block  0
        -: 1557:    }
        -: 1558:
    #####: 1559:    bool bDeleteMeanVal = false;
        -: 1560:
    #####: 1561:    if(meanVal == NULL) {
    %%%%%: 1561-block  0
    #####: 1562:        meanVal = getMeanVal(box, NULL);
    #####: 1563:        bDeleteMeanVal = true;
    %%%%%: 1563-block  0
        -: 1564:    }
        -: 1565:
    #####: 1566:    if(ret == NULL) {
    %%%%%: 1566-block  0
    #####: 1567:        ret = new float[channels];
    %%%%%: 1567-block  0
    %%%%%: 1567-block  1
    %%%%%: 1567-block  2
        -: 1568:    }
        -: 1569:
    #####: 1570:    Arrayf::assign(0.0f, ret, channels);
    %%%%%: 1570-block  0
        -: 1571:
    #####: 1572:    for(int k = box->z0; k < box->z1; k++) {
    %%%%%: 1572-block  0
    %%%%%: 1572-block  1
    %%%%%: 1572-block  2
    #####: 1573:        for(int j = box->y0; j < box->y1; j++) {
    %%%%%: 1573-block  0
    %%%%%: 1573-block  1
    %%%%%: 1573-block  2
    #####: 1574:            for(int i = box->x0; i < box->x1; i++) {
    %%%%%: 1574-block  0
    %%%%%: 1574-block  1
    %%%%%: 1574-block  2
    #####: 1575:                float *tmp_data = (*this)(i, j, k);
        -: 1576:
    #####: 1577:                for(int l = 0; l < channels; l++) {
    %%%%%: 1577-block  0
    %%%%%: 1577-block  1
    #####: 1578:                    float tmp = tmp_data[l] - meanVal[l];
    #####: 1579:                    ret[l] += tmp * tmp;
    %%%%%: 1579-block  0
        -: 1580:                }
        -: 1581:            }
        -: 1582:        }
        -: 1583:    }
        -: 1584:
    #####: 1585:    float totf = float(box->Size() - 1);
    %%%%%: 1585-block  0
        -: 1586:
    #####: 1587:    Arrayf::div(ret, channels, totf);
    %%%%%: 1587-block  0
        -: 1588:
    #####: 1589:    if(bDeleteMeanVal) {
    %%%%%: 1589-block  0
    #####: 1590:        delete[] meanVal;
    %%%%%: 1590-block  0
    %%%%%: 1590-block  1
        -: 1591:    }
        -: 1592:
        -: 1593:    return ret;
        -: 1594:}
        -: 1595:
        -: 1596:
    #####: 1597:PIC_INLINE float *Image::getCovMtxVal(float *meanVal, BBox *box, float *ret)
        -: 1598:{
    #####: 1599:    if(!isValid()) {
    %%%%%: 1599-block  0
        -: 1600:        return ret;
        -: 1601:    }
        -: 1602:
    #####: 1603:    if(box == NULL) {
    %%%%%: 1603-block  0
    #####: 1604:        box = &fullBox;
    %%%%%: 1604-block  0
        -: 1605:    }
        -: 1606:
    #####: 1607:    bool bMeanValAllocated = false;
        -: 1608:
    #####: 1609:    if(meanVal == NULL) {
    %%%%%: 1609-block  0
    #####: 1610:        meanVal = getMeanVal(box, NULL);
    #####: 1611:        bMeanValAllocated = true;
    %%%%%: 1611-block  0
        -: 1612:    }
        -: 1613:
    #####: 1614:    int n = channels * channels;
        -: 1615:
    #####: 1616:    if(ret == NULL) {
    %%%%%: 1616-block  0
    #####: 1617:        ret = new float[n];
    %%%%%: 1617-block  0
        -: 1618:    }
        -: 1619:
    #####: 1620:    Arrayf::assign(0.0f, ret, n);
    %%%%%: 1620-block  0
        -: 1621:
    #####: 1622:    for(int k = box->z0; k < box->z1; k++) {
    %%%%%: 1622-block  0
    %%%%%: 1622-block  1
    %%%%%: 1622-block  2
    #####: 1623:        for(int j = box->y0; j < box->y1; j++) {
    %%%%%: 1623-block  0
    %%%%%: 1623-block  1
    %%%%%: 1623-block  2
    #####: 1624:            for(int i = box->x0; i < box->x1; i++) {
    %%%%%: 1624-block  0
    %%%%%: 1624-block  1
    %%%%%: 1624-block  2
    #####: 1625:                float *tmp_data = (*this)(i, j, k);
        -: 1626:
    #####: 1627:                for(int l = 0; l < channels; l++) {
    %%%%%: 1627-block  0
    %%%%%: 1627-block  1
    %%%%%: 1627-block  2
    #####: 1628:                    float tmp1 = (tmp_data[l] - meanVal[l]);
        -: 1629:
    #####: 1630:                    for(int m = 0; m < channels; m++) {
    %%%%%: 1630-block  0
    %%%%%: 1630-block  1
    #####: 1631:                        float tmp2 = (tmp_data[m] - meanVal[m]);
        -: 1632:
    #####: 1633:                        ret[l * channels + m] += tmp1 * tmp2;
    %%%%%: 1633-block  0
        -: 1634:                    }
        -: 1635:                }
        -: 1636:            }
        -: 1637:        }
        -: 1638:    }
        -: 1639:
    #####: 1640:    float totf = float(box->Size() - 1);
    %%%%%: 1640-block  0
        -: 1641:
    #####: 1642:    Arrayf::div(ret, n, totf);
    %%%%%: 1642-block  0
        -: 1643:
    #####: 1644:    if(bMeanValAllocated) {
    %%%%%: 1644-block  0
    #####: 1645:        delete[] meanVal;
    %%%%%: 1645-block  0
    %%%%%: 1645-block  1
        -: 1646:    }
        -: 1647:
        -: 1648:    return ret;
        -: 1649:}
        -: 1650:
        2: 1651:PIC_INLINE float *Image::getLogMeanVal(BBox *box = NULL, float *ret = NULL)
        -: 1652:{
        2: 1653:    if(!isValid()) {
        2: 1653-block  0
        -: 1654:        return ret;
        -: 1655:    }
        -: 1656:
        2: 1657:    if(box == NULL) {
        2: 1657-block  0
        2: 1658:        box = &fullBox;
        2: 1658-block  0
        -: 1659:    }
        -: 1660:
        2: 1661:    if(ret == NULL) {
        2: 1661-block  0
    #####: 1662:        ret = new float[channels];
    %%%%%: 1662-block  0
        -: 1663:    }
        -: 1664:
        2: 1665:    Arrayf::assign(0.0f, ret, channels);
        2: 1665-block  0
        -: 1666:
        4: 1667:    for(int k = box->z0; k < box->z1; k++) {
        2: 1667-block  0
        4: 1667-block  1
        2: 1667-block  2
      856: 1668:        for(int j = box->y0; j < box->y1; j++) {
        2: 1668-block  0
      856: 1668-block  1
      854: 1668-block  2
   547414: 1669:            for(int i = box->x0; i < box->x1; i++) {
      854: 1669-block  0
   547414: 1669-block  1
   546560: 1669-block  2
   546560: 1670:                float *tmp_data = (*this)(i, j, k);
        -: 1671:
  1093120: 1672:                for(int l = 0; l < channels; l++) {
   546560: 1672-block  0
  1093120: 1672-block  1
   546560: 1673:                    ret[l] += logf(tmp_data[l] + 1e-6f);
   546560: 1673-block  0
        -: 1674:                }
        -: 1675:            }
        -: 1676:        }
        -: 1677:    }
        -: 1678:
        2: 1679:    float totf = float(box->Size());
        2: 1679-block  0
        -: 1680:
        4: 1681:    for(int l = 0; l < channels; l++) {
        2: 1681-block  0
        4: 1681-block  1
        2: 1682:        ret[l] = expf(ret[l] / totf);
        2: 1682-block  0
        -: 1683:    }
        -: 1684:
        -: 1685:    return ret;
        -: 1686:}
        -: 1687:
        -: 1688:PIC_INLINE void Image::convertFromMask(bool *mask, int width, int height)
        -: 1689:{
        -: 1690:    if((mask == NULL) || (width < 1) || (height < 1)) {
        -: 1691:        return;
        -: 1692:    }
        -: 1693:
        -: 1694:    if(!isValid() || this->width != width || this->height != height) {
        -: 1695:        allocate(width, height, 1, 1);
        -: 1696:    }
        -: 1697:
        -: 1698:    int size = (width * height);
        -: 1699:
        -: 1700:    #pragma omp parallel for
        -: 1701:    for(int i = 0; i < size; i++) {
        -: 1702:        data[i] = mask[i] ? 1.0f : 0.0f;
        -: 1703:    }
        -: 1704:}
        -: 1705:
        -: 1706:PIC_INLINE bool *Image::convertToMask(float *color = NULL, float threshold = 0.25f,
        -: 1707:                                      bool cmp = true,  bool *mask = NULL)
        -: 1708:{
        -: 1709:    if(!isValid()) {
        -: 1710:        return NULL;
        -: 1711:    }
        -: 1712:    
        -: 1713:    bool bColorAllocated = false;
        -: 1714:
        -: 1715:    if(color == NULL) {
        -: 1716:        bColorAllocated = true;
        -: 1717:        color = new float[channels];
        -: 1718:
        -: 1719:        Arrayf::assign(0.0f, color, channels);
        -: 1720:    }
        -: 1721:
        -: 1722:    int n = width * height;
        -: 1723:
        -: 1724:    if(mask == NULL) {
        -: 1725:        mask = new bool[n];
        -: 1726:    }
        -: 1727:
        -: 1728:    float tmpThreshold = threshold * float(channels);
        -: 1729:
        -: 1730:    #pragma omp parallel for
        -: 1731:    for(int i = 0; i < n; i++) {
        -: 1732:        int ind = i * channels;
        -: 1733:
        -: 1734:        float val = 0.0f;
        -: 1735:
        -: 1736:        for(int k = 0; k < channels; k++) {
        -: 1737:            val += fabsf(data[ind + k] - color[k]);
        -: 1738:        }
        -: 1739:
        -: 1740:        bool bMask = val > tmpThreshold;
        -: 1741:        mask[i] = cmp ? bMask : !bMask;
        -: 1742:
        -: 1743:        /*
        -: 1744:        if(cmp) {
        -: 1745:            mask[i] = val > tmpThreshold;
        -: 1746:        } else {
        -: 1747:            mask[i] = val < tmpThreshold;
        -: 1748:        }*/
        -: 1749:    }
        -: 1750:
        -: 1751:    if(bColorAllocated) {
        -: 1752:        delete[] color;
        -: 1753:    }
        -: 1754:
        -: 1755:    return mask;
        -: 1756:}
        -: 1757:
        7: 1758:PIC_INLINE bool Image::Read(std::string nameFile,
        -: 1759:                               LDR_type typeLoad = LT_NOR_GAMMA)
        -: 1760:{
        7: 1761:    this->nameFile = nameFile;
        7: 1761-block  0
        -: 1762:
        7: 1763:    this->typeLoad = typeLoad;
        -: 1764:
        7: 1765:    LABEL_IO_EXTENSION label;
        -: 1766:
        7: 1767:    bool bReturn = false;
        -: 1768:
        -: 1769:    //read the image in an HDR format
        7: 1770:    label = getLabelHDRExtension(nameFile);
        -: 1771:
        7: 1772:    if(label != IO_NULL) {
        7: 1772-block  0
    #####: 1773:        float *dataReader = NULL;
    #####: 1774:        float *tmp = NULL;
        -: 1775:
    #####: 1776:        if(data != NULL) {
    %%%%%: 1776-block  0
    #####: 1777:            dataReader = &data[tstride * readerCounter];
    %%%%%: 1777-block  0
        -: 1778:#ifdef PIC_ENABLE_OPEN_EXR
        -: 1779:            dataEXR = new Imf::Rgba[width * height];
        -: 1780:#endif
        -: 1781:        } else {
    #####: 1782:            channels = 3;
    %%%%%: 1782-block  0
        -: 1783:        }
        -: 1784:
    #####: 1785:        switch(label) {
    %%%%%: 1785-block  0
    #####: 1786:        case IO_TMP:
    #####: 1787:            tmp = ReadTMP(nameFile, dataReader, width, height, channels, frames);
    %%%%%: 1787-block  0
    %%%%%: 1787-block  1
    $$$$$: 1787-block  2
    #####: 1788:            break;
    %%%%%: 1788-block  0
        -: 1789:
    #####: 1790:        case IO_HDR:
    #####: 1791:            tmp = ReadHDR(nameFile, dataReader, width, height);
    %%%%%: 1791-block  0
    %%%%%: 1791-block  1
    $$$$$: 1791-block  2
    #####: 1792:            break;
    %%%%%: 1792-block  0
        -: 1793:
    #####: 1794:        case IO_PFM:
    #####: 1795:            tmp = ReadPFM(nameFile, dataReader, width, height, channels);
    %%%%%: 1795-block  0
    %%%%%: 1795-block  1
    $$$$$: 1795-block  2
    #####: 1796:            break;
    %%%%%: 1796-block  0
        -: 1797:
    #####: 1798:        case IO_EXR:
        -: 1799:#ifdef PIC_ENABLE_OPEN_EXR
        -: 1800:            tmp = ReadEXR(nameFile, dataReader, width, height, channels, dataEXR);
        -: 1801:#else
        -: 1802:#ifndef PIC_DISABLE_TINY_EXR
    #####: 1803:            tmp = ReadEXR(nameFile, dataReader, width, height, channels);
    %%%%%: 1803-block  0
    %%%%%: 1803-block  1
    $$$$$: 1803-block  2
        -: 1804:#endif
        -: 1805:#endif
    #####: 1806:            break;
    %%%%%: 1806-block  0
        -: 1807:
    #####: 1808:        case IO_VOL:
    #####: 1809:            tmp = ReadVOL(nameFile, dataReader, width, height, frames, channels);
    %%%%%: 1809-block  0
    %%%%%: 1809-block  1
    $$$$$: 1809-block  2
    #####: 1810:            depth = frames;
    #####: 1811:            break;
    %%%%%: 1811-block  0
        -: 1812:
        -: 1813:        default:
        -: 1814:            tmp = NULL;
        -: 1815:        }
        -: 1816:
    #####: 1817:        if(tmp != NULL) {
    %%%%%: 1817-block  0
    #####: 1818:            if(data == NULL) {
    %%%%%: 1818-block  0
    #####: 1819:                data = tmp;
        -: 1820:
    #####: 1821:                if(frames <= 0) {
    %%%%%: 1821-block  0
    #####: 1822:                    frames = 1;
    %%%%%: 1822-block  0
        -: 1823:                }
        -: 1824:            }
        -: 1825:
    #####: 1826:            allocateAux();
    #####: 1827:            bReturn = true;
    %%%%%: 1827-block  0
        -: 1828:        } else {
        -: 1829:            bReturn = false;
        -: 1830:        }
        -: 1831:    } else {
        -: 1832:        //read the image using an LDR codec
        7: 1833:        label = getLabelLDRExtension(nameFile);
        7: 1833-block  0
        7: 1834:        unsigned char *dataReader = NULL;
        7: 1835:        unsigned char *tmp = NULL;
        7: 1836:        bool bExt = false;
        -: 1837:
        7: 1838:        if(dataUC != NULL) {
        -: 1839:            dataReader = dataUC;
        -: 1840:        }
        -: 1841:
        7: 1842:        switch(label) {
        7: 1842-block  0
    #####: 1843:        case IO_BMP: {
    #####: 1844:            tmp = ReadBMP(nameFile, dataReader, width, height, channels);
    %%%%%: 1844-block  0
    %%%%%: 1844-block  1
    $$$$$: 1844-block  2
    #####: 1845:        } break;
        -: 1846:
    #####: 1847:        case IO_PPM: {
    #####: 1848:            tmp = ReadPPM(nameFile, dataReader, width, height, channels);
    %%%%%: 1848-block  0
    %%%%%: 1848-block  1
    $$$$$: 1848-block  2
    #####: 1849:        } break;
        -: 1850:
    #####: 1851:        case IO_PGM: {
    #####: 1852:            tmp = ReadPGM(nameFile, dataUC, width, height, channels);
    %%%%%: 1852-block  0
    %%%%%: 1852-block  1
    $$$$$: 1852-block  2
    #####: 1853:        } break;
        -: 1854:
    #####: 1855:        case IO_TGA: {
    #####: 1856:            tmp = ReadTGA(nameFile, dataReader, width, height, channels);
    %%%%%: 1856-block  0
    %%%%%: 1856-block  1
    $$$$$: 1856-block  2
    #####: 1857:        } break;
        -: 1858:
        7: 1859:        case IO_JPG: {
        7: 1860:            bExt = true;
        -: 1861:
        7: 1862:            EXIFInfo info;
        7: 1862-block  0
    $$$$$: 1862-block  1
       14: 1863:            readEXIF(nameFile, info);
        7: 1863-block  0
        7: 1863-block  1
    $$$$$: 1863-block  2
    $$$$$: 1863-block  3
        7: 1864:            exposure = estimateAverageLuminance(info.exposureTime, info.aperture, info.iso);
        7: 1864-block  0
        -: 1865:
        7: 1866:        } break;
        -: 1867:
        -: 1868:        case IO_PNG: {
        -: 1869:            bExt = true;
        -: 1870:        } break;
        -: 1871:
        -: 1872:        default: {
        -: 1873:            tmp = NULL;
        -: 1874:        } break;
        -: 1875:
        -: 1876:        }
        -: 1877:
       7*: 1878:         if(bExt) {
    %%%%%: 1878-block  0
    %%%%%: 1878-block  1
    %%%%%: 1878-block  2
    %%%%%: 1878-block  3
        7: 1878-block  4
       14: 1879:             tmp = ReadSTB(nameFile, width, height, channels);
        7: 1879-block  0
        7: 1879-block  1
        7: 1879-block  2
        -: 1880:         }
        -: 1881:
        7: 1882:         if(tmp != NULL) { //move the handle where it's trackable
        7: 1882-block  0
        7: 1883:             if(dataUC == NULL) {
        7: 1883-block  0
        7: 1884:                 dataUC = tmp;
        7: 1884-block  0
        -: 1885:             }
        -: 1886:         }
        -: 1887:
        7: 1888:         if(typeLoad == LT_LDR) {
        7: 1888-block  0
    #####: 1889:             return dataUC != NULL;
    %%%%%: 1889-block  0
        -: 1890:         }
        -: 1891:
        7: 1892:         float *tmpFloat = NULL;
        -: 1893:
        7: 1894:         if(data != NULL) {
        7: 1894-block  0
    #####: 1895:             tmpFloat = &data[tstride * readerCounter];
    %%%%%: 1895-block  0
        -: 1896:         }
        -: 1897:
        7: 1898:         float *tmpConv = convertLDR2HDR(tmp, tmpFloat, sizeFrame(), typeLoad);
        7: 1898-block  0
        -: 1899:
        7: 1900:         if(tmpConv != NULL) {
        7: 1901:             if(data == NULL) {
        7: 1901-block  0
        7: 1902:                 data = tmpConv;                 
        7: 1903:                 frames = frames > 0 ? frames : 1;
        7: 1904:                 allocateAux();
        7: 1904-block  0
        -: 1905:             }
        -: 1906:
        -: 1907:             bReturn = true;
        -: 1908:         } else {
        -: 1909:             bReturn = false;
        -: 1910:         }
        -: 1911:    }
        -: 1912:
        7: 1913:    readerCounter = (readerCounter + 1) % frames;
        7: 1914:    return bReturn;
        7: 1914-block  0
        -: 1915:}
        -: 1916:
        2: 1917:PIC_INLINE bool Image::Write(std::string nameFile, LDR_type typeWrite = LT_NOR_GAMMA,
        -: 1918:                                int writerCounter = 0)
        -: 1919:{
        4: 1920:    if(!isValid()) {
        2: 1920-block  0
        2: 1920-block  1
        -: 1921:        return false;
        -: 1922:    }
        -: 1923:
        2: 1924:    LABEL_IO_EXTENSION label;
        -: 1925:
        -: 1926:    //read an image in an HDR format
        2: 1927:    label = getLabelHDRExtension(nameFile);
        2: 1927-block  0
        -: 1928:
        2: 1929:    if(label != IO_NULL) {
        2: 1929-block  0
        1: 1930:        float *dataWriter = NULL;
        -: 1931:
       1*: 1932:        if((writerCounter > 0) && (writerCounter < frames)) {
        1: 1932-block  0
    %%%%%: 1932-block  1
    #####: 1933:            dataWriter = &data[tstride * writerCounter];
    %%%%%: 1933-block  0
        -: 1934:        } else {
        1: 1935:            dataWriter = data;
        1: 1935-block  0
        -: 1936:        }
        -: 1937:
        1: 1938:        bool ret = false;
        -: 1939:
        1: 1940:        switch(label) {
        1: 1940-block  0
    #####: 1941:        case IO_TMP:
    #####: 1942:            ret = WriteTMP(nameFile, dataWriter, width, height, channels, frames);
    %%%%%: 1942-block  0
    %%%%%: 1942-block  1
    $$$$$: 1942-block  2
    #####: 1943:            break;
    %%%%%: 1943-block  0
        -: 1944:
        1: 1945:        case IO_HDR:
        1: 1946:            ret = WriteHDR(nameFile, dataWriter, width, height, channels);
        1: 1946-block  0
        1: 1946-block  1
    $$$$$: 1946-block  2
        1: 1947:            break;
        1: 1947-block  0
        -: 1948:
    #####: 1949:        case IO_PFM:
    #####: 1950:            ret = WritePFM(nameFile, dataWriter, width, height, channels);
    %%%%%: 1950-block  0
    %%%%%: 1950-block  1
    $$$$$: 1950-block  2
    #####: 1951:            break;
    %%%%%: 1951-block  0
        -: 1952:
    #####: 1953:        case IO_EXR:
        -: 1954:#ifdef PIC_ENABLE_OPEN_EXR
        -: 1955:            ret = WriteEXR(nameFile, dataWriter, width, height, channels);
        -: 1956:#else
        -: 1957:#ifndef PIC_DISABLE_TINY_EXR
    #####: 1958:            ret = WriteEXR(nameFile, dataWriter, width, height, channels);
    %%%%%: 1958-block  0
    %%%%%: 1958-block  1
    $$$$$: 1958-block  2
        -: 1959:#endif
        -: 1960:#endif
    #####: 1961:            break;
    %%%%%: 1961-block  0
        -: 1962:
    #####: 1963:        case IO_VOL:
    #####: 1964:            ret = WriteVOL(nameFile, dataWriter, width, height, frames, channels);
    %%%%%: 1964-block  0
    %%%%%: 1964-block  1
    $$$$$: 1964-block  2
    #####: 1965:            break;
    %%%%%: 1965-block  0
        -: 1966:
        -: 1967:        default:
        -: 1968:            ret = false;
        -: 1969:        }
        -: 1970:
        1: 1971:        return ret;
        1: 1971-block  0
        -: 1972:    } else {
        -: 1973:        //write the image into an LDR format
        1: 1974:        label = getLabelLDRExtension(nameFile);
        1: 1974-block  0
        -: 1975:
        1: 1976:        bool bExt = (label == IO_JPG) || (label == IO_PNG);
        -: 1977:
        -: 1978:        //allocate memory: begin
        1: 1979:        float *dataWriter = NULL;
        -: 1980:
       1*: 1981:        if((writerCounter > 0) && (writerCounter < frames)) {
        1: 1981-block  0
    %%%%%: 1981-block  1
    #####: 1982:            dataWriter = &data[tstride * writerCounter];
    %%%%%: 1982-block  0
        -: 1983:        } else {
        1: 1984:            dataWriter = data;
        1: 1984-block  0
        -: 1985:        }
        -: 1986:
        1: 1987:        unsigned char *tmp;
        1: 1988:        tmp = convertHDR2LDR(dataWriter, dataUC, sizeFrame(), typeWrite);
        1: 1988-block  0
        -: 1989:
        1: 1990:        if(dataUC == NULL) {
        1: 1991:            dataUC = tmp;
        1: 1991-block  0
        -: 1992:        } else {
    #####: 1993:            dataUC = delete_vec_s(dataUC);
    %%%%%: 1993-block  0
    #####: 1994:            dataUC = tmp;
        -: 1995:        }
        -: 1996:        //allocate memory: end
        -: 1997:
        1: 1998:        if(bExt) {
        1: 1998-block  0
        2: 1999:            return WriteSTB(nameFile, dataUC, width, height, channels);
        1: 1999-block  0
        1: 1999-block  1
        1: 1999-block  2
    $$$$$: 1999-block  3
        -: 2000:        } else {
    #####: 2001:            switch(label) {
    %%%%%: 2001-block  0
    #####: 2002:            case IO_BMP:
    #####: 2003:                return WriteBMP(nameFile, dataUC, width, height, channels);
    %%%%%: 2003-block  0
    %%%%%: 2003-block  1
    %%%%%: 2003-block  2
    $$$$$: 2003-block  3
    #####: 2004:                break;
        -: 2005:
    #####: 2006:            case IO_TGA:
        -: 2007:                //values are stored with a vertical flip
    #####: 2008:                Buffer<unsigned char>::flipV(dataUC, width, height, channels, 1);
    %%%%%: 2008-block  0
        -: 2009:
        -: 2010:                //values needs to be stored as BGR
    #####: 2011:                Buffer<unsigned char>::BGRtoRGB(dataUC, width, height, channels, 1);
    %%%%%: 2011-block  0
        -: 2012:
    #####: 2013:                return WriteTGA(nameFile, dataUC, width, height, channels);
    %%%%%: 2013-block  0
    %%%%%: 2013-block  1
    %%%%%: 2013-block  2
    $$$$$: 2013-block  3
    #####: 2014:                break;
        -: 2015:
    #####: 2016:            case IO_PPM:
    #####: 2017:                return WritePPM(nameFile, dataUC, width, height, channels);
    %%%%%: 2017-block  0
    %%%%%: 2017-block  1
    %%%%%: 2017-block  2
    $$$$$: 2017-block  3
    #####: 2018:                break;
        -: 2019:
    #####: 2020:            case IO_PGM:
    #####: 2021:                return WritePGM(nameFile, dataUC, width, height, channels);
    %%%%%: 2021-block  0
    %%%%%: 2021-block  1
    %%%%%: 2021-block  2
        -: 2022:                break;
        -: 2023:
        -: 2024:            default:
        -: 2025:                return false;
        -: 2026:            }
        -: 2027:        }
        -: 2028:    }
        -: 2029:}
        -: 2030:
    #####: 2031:PIC_INLINE Image *Image::allocateSimilarOne()
        -: 2032:{
    #####: 2033:    Image *ret = new Image(frames, width, height, channels);
    %%%%%: 2033-block  0
    $$$$$: 2033-block  1
    #####: 2034:    ret->flippedEXR = flippedEXR;
    #####: 2035:    ret->exposure = exposure;
    #####: 2036:    ret->alpha = alpha;
    #####: 2037:    return ret;
    %%%%%: 2037-block  0
        -: 2038:}
        -: 2039:
    #####: 2040:PIC_INLINE void Image::allocateSimilarTo(Image *img)
        -: 2041:{
    #####: 2042:    if(img != NULL) {
    %%%%%: 2042-block  0
    #####: 2043:        if(img->isValid()) {
    %%%%%: 2043-block  0
    #####: 2044:            allocate(img->width, img->height, img->channels, img->frames);
    %%%%%: 2044-block  0
        -: 2045:        }
        -: 2046:    }
    #####: 2047:}
        -: 2048:
        1: 2049:PIC_INLINE Image *Image::clone() const
        -: 2050:{
        1: 2051:    Image *ret = new Image(frames, width, height, channels);
        1: 2051-block  0
    $$$$$: 2051-block  1
        -: 2052:
        1: 2053:    ret->fullBox = fullBox;
        1: 2054:    ret->flippedEXR = flippedEXR;
        1: 2055:    ret->exposure = exposure;
        1: 2056:    ret->nameFile = nameFile;
        1: 2056-block  0
        1: 2057:    ret->alpha = alpha;
        1: 2058:    ret->typeLoad = typeLoad;
        -: 2059:
        1: 2060:    memcpy(ret->data, data, width * height * channels * sizeof(float));
        -: 2061:
        1: 2062:    return ret;
        -: 2063:}
        -: 2064:
        -: 2065:PIC_INLINE float* Image::getColorSamples(float *samples,
        -: 2066:                                         int &nSamples,
        -: 2067:                                         float percentage = 1.0f)
        -: 2068:{    
        -: 2069:    percentage = CLAMPi(percentage, 0.0f, 1.0f);
        -: 2070:
        -: 2071:    int nTot = nPixels();
        -: 2072:    nSamples = int(ceilf(float(nTot) * percentage));
        -: 2073:
        -: 2074:    if(samples == NULL) {
        -: 2075:        samples = new float[nSamples * channels];
        -: 2076:    }
        -: 2077:
        -: 2078:    int shift = 1;
        -: 2079:
        -: 2080:    if(nSamples < nTot) {
        -: 2081:        shift = nTot / nSamples;
        -: 2082:    }
        -: 2083:
        -: 2084:    for(int i = 0; i < nSamples; i++) {
        -: 2085:        int index = i * channels;
        -: 2086:        int index_d = index * shift;
        -: 2087:
        -: 2088:        for(int j = 0; j < channels; j++) {
        -: 2089:            samples[index + j] = data[index_d + j];
        -: 2090:        }
        -: 2091:    }
        -: 2092:
        -: 2093:    return samples;
        -: 2094:}
        -: 2095:
       1*: 2096:PIC_INLINE void Image::operator =(const Image &a)
        -: 2097:{
       1*: 2098:    this->assign(&a);
        1: 2098-block  0
    %%%%%: 2098-block  1
    %%%%%: 2098-block  2
    #####: 2099:}
    %%%%%: 2099-block  0
        -: 2100:
    #####: 2101:PIC_INLINE void Image::operator =(const float &a)
        -: 2102:{
    #####: 2103:    Buffer<float>::assign(data, size(), a);
    %%%%%: 2103-block  0
    %%%%%: 2103-block  1
    %%%%%: 2103-block  2
    %%%%%: 2103-block  3
    #####: 2104:}
    %%%%%: 2104-block  0
        -: 2105:
        -: 2106:PIC_INLINE void Image::operator +=(const float &a)
        -: 2107:{
        -: 2108:    Buffer<float>::add(data, size(), a);
        -: 2109:}
        -: 2110:
        -: 2111:PIC_INLINE Image Image::operator +(const float &a) const
        -: 2112:{
        -: 2113:    Image *out = this->clone();
        -: 2114:    *out += a;
        -: 2115:    return Image(out, false);
        -: 2116:}
        -: 2117:
    #####: 2118:PIC_INLINE void Image::operator +=(const Image &a)
        -: 2119:{
    #####: 2120:    if(isSimilarType(&a)) {
    %%%%%: 2120-block  0
    #####: 2121:        Buffer<float>::add(data, a.data, size());
    %%%%%: 2121-block  0
        -: 2122:    } else {
    #####: 2123:        if((nPixels() == a.nPixels()) && (a.channels == 1)) {
    %%%%%: 2123-block  0
    %%%%%: 2123-block  1
    #####: 2124:            Buffer<float>::addS(data, a.data, nPixels(), channels);
    %%%%%: 2124-block  0
        -: 2125:        }
        -: 2126:    }
        -: 2127:
    #####: 2128:}
        -: 2129:
        -: 2130:PIC_INLINE Image Image::operator +(const Image &a) const
        -: 2131:{
        -: 2132:    Image *out = this->clone();
        -: 2133:    *out += a;
        -: 2134:    return Image(out, false);
        -: 2135:}
        -: 2136:
        -: 2137:PIC_INLINE void Image::operator *=(const float &a)
        -: 2138:{
        -: 2139:    Buffer<float>::mul(data, size(), a);
        -: 2140:}
        -: 2141:
        -: 2142:PIC_INLINE Image Image::operator *(const float &a) const
        -: 2143:{
        -: 2144:    Image *out = this->clone();
        -: 2145:    *out *= a;
        -: 2146:    return Image(out, false);
        -: 2147:}
        -: 2148:
        1: 2149:PIC_INLINE void Image::operator *=(const Image &a)
        -: 2150:{
       1*: 2151:    if(isSimilarType(&a)) {
        1: 2151-block  0
    #####: 2152:        Buffer<float>::mul(data, a.data, size());
    %%%%%: 2152-block  0
        -: 2153:    } else {
        1: 2154:        if((nPixels() == a.nPixels()) && (a.channels == 1)) {
        1: 2154-block  0
        1: 2154-block  1
        1: 2155:            Buffer<float>::mulS(data, a.data, nPixels(), channels);
        1: 2155-block  0
        -: 2156:        }
        -: 2157:    }
        1: 2158:}
        -: 2159:
        -: 2160:PIC_INLINE Image Image::operator *(const Image &a) const
        -: 2161:{
        -: 2162:    Image *out = this->clone();
        -: 2163:    *out *= a;
        -: 2164:    return Image(out, false);
        -: 2165:}
        -: 2166:
        -: 2167:PIC_INLINE void Image::operator -=(const float &a)
        -: 2168:{
        -: 2169:    Buffer<float>::sub(data, size(), a);
        -: 2170:}
        -: 2171:
        -: 2172:PIC_INLINE Image Image::operator -(const float &a) const
        -: 2173:{
        -: 2174:    Image *out = this->clone();
        -: 2175:    *out -= a;
        -: 2176:    return Image(out, false);
        -: 2177:}
        -: 2178:
    #####: 2179:PIC_INLINE void Image::operator -=(const Image &a)
        -: 2180:{
    #####: 2181:    if(isSimilarType(&a)) {
    %%%%%: 2181-block  0
    #####: 2182:        Buffer<float>::sub(data, a.data, size());
    %%%%%: 2182-block  0
        -: 2183:    } else {
    #####: 2184:        if((nPixels() == a.nPixels()) && (a.channels == 1)) {
    %%%%%: 2184-block  0
    %%%%%: 2184-block  1
    #####: 2185:            Buffer<float>::subS(data, a.data, nPixels(), channels);
    %%%%%: 2185-block  0
        -: 2186:        }
        -: 2187:    }
    #####: 2188:}
        -: 2189:
        -: 2190:PIC_INLINE Image Image::operator -(const Image &a) const
        -: 2191:{
        -: 2192:    Image *out = this->clone();
        -: 2193:    *out -= a;
        -: 2194:    return Image(out, false);
        -: 2195:}
        -: 2196:
        -: 2197:PIC_INLINE void Image::operator /=(const float &a)
        -: 2198:{
        -: 2199:    Buffer<float>::div(data, size(), a);
        -: 2200:}
        -: 2201:
        -: 2202:PIC_INLINE Image Image::operator /(const float &a) const
        -: 2203:{
        -: 2204:    Image *out = this->clone();
        -: 2205:    *out /= a;
        -: 2206:    return Image(out, false);
        -: 2207:}
        -: 2208:
        1: 2209:PIC_INLINE void Image::operator /=(const Image &a)
        -: 2210:{
       1*: 2211:    if(isSimilarType(&a)) {
        1: 2211-block  0
    #####: 2212:        Buffer<float>::div(data, a.data, size());
    %%%%%: 2212-block  0
        -: 2213:    } else {
        1: 2214:        if((nPixels() == a.nPixels()) && (a.channels == 1)) {
        1: 2214-block  0
        1: 2214-block  1
        1: 2215:            Buffer<float>::divS(data, a.data, nPixels(), channels);
        1: 2215-block  0
        -: 2216:        }
        -: 2217:    }
        1: 2218:}
        -: 2219:
        -: 2220:PIC_INLINE Image Image::operator /(const Image &a) const
        -: 2221:{
        -: 2222:    Image *out = this->clone();
        -: 2223:    *out /= a;
        -: 2224:    return Image(out, false);
        -: 2225:}
        -: 2226:
        -: 2227:} // end namespace pic
        -: 2228:
        -: 2229:#endif /* PIC_IMAGE_HPP */
        -: 2230:
